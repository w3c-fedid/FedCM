<pre class='metadata'>
Title: Federated Credential Management API
Shortname: fedcm
Level: 1
Status: w3c/ED
Group: fedid
TR: http://www.w3.org/TR/fedcm/
ED: https://w3c-fedid.github.io/FedCM/
Prepare for TR: true
Repository: w3c-fedid/FedCM
Editor: Nicolás Peña Moreno, w3cid 103755, Google Inc. https://google.com, npm@chromium.org
Former Editor: Sam Goto, w3cid 50308, Google Inc. https://google.com, goto@google.com

Markup Shorthands: markdown yes, biblio yes
Default Biblio Display: inline

Text Macro: FALSE <code>false</code>
Text Macro: TRUE <code>true</code>
Text Macro: RP Relying Party
Text Macro: IDP Identity Provider

Abstract: A Web Platform API that allows users to login to websites with their federated accounts in a privacy-preserving manner.

Test Suite: https://github.com/web-platform-tests/wpt/tree/master/fedcm
</pre>

<pre class=anchors>
spec: ecma262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: internal method; url: sec-ordinary-object-internal-methods-and-internal-slots

spec: credential-management-1; urlPrefix: https://w3c.github.io/webappsec-credential-management/
    type: dfn
        text: same-origin with its ancestors; url: same-origin-with-its-ancestors
    type: dfn
        text: requires user mediation; url: origin-requires-user-mediation
spec: webdriver; urlPrefix: https://w3c.github.io/webdriver/
    type: dfn
        text: endpoint node; url: dfn-endpoint-node
        text: extension capability; url: dfn-extension-capability
        text: getting a property; url: dfn-getting-properties
        text: matching capabilities; url: dfn-matching-capabilities
        text: no such alert; url: dfn-no-such-alert
        text: error code; url: dfn-error-code
        text: validating capabilities; url: dfn-validate-capabilities
spec: webappsec-fetch-metadata; urlPrefix: https://w3c.github.io/webappsec-fetch-metadata/
    type: dfn
        text: Directly User-Initiated Requests; url: directly-user-initiated
spec: login-status; urlPrefix: https://w3c-fedid.github.io/login-status
    type: dfn
        text: logged-in; url: logged-in
        text: logged-out; url: logged-out
        text: unknown; url: unknown
        text: get the login status; url: get-the-login-status
        text: set the login status; url: set-the-login-status
</pre>

<pre class=link-defaults>
spec:infra; type:dfn; text:list
spec:infra; type:dfn; text:user agent
spec:html; type:dfn; for:environment settings object; text:global object
spec:html; type:dfn; for:html-origin-def; text:origin
spec:webidl; type:dfn; text:resolve
spec:webdriver2; type:dfn; text:error
spec:webdriver2; type:dfn; text:remote end steps
spec:fetch; type:dfn; for:/; text:response
</pre>

<style>
dl.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
dl.domintro dt a {
    color: inherit; border-bottom-style: none;
}
dl.domintro dt code {
    font-size: inherit;
}
.idp-normative-text {
    background-color: rgba(165, 42, 42, 0.3);
    margin: 16px 0px;
    padding: 8px;
    border-left: 8px solid brown;
}

/* temporary fixes to the typogram diagrams
   to support dark mode properly */
script + svg :is(polygon, line, rect):not(.grid) {
  stroke: currentcolor;
}
script + svg :is(polygon, text) {
  fill: currentcolor;
}
</style>

<script src="https://w3c-fedid.github.io/FedCM/static/underscore-min.js"></script>
<script src="https://w3c-fedid.github.io/FedCM/static/raphael.min.js"></script>
<script src="https://w3c-fedid.github.io/FedCM/static/webfont.js"></script>
<script src="https://w3c-fedid.github.io/FedCM/static/typogram.js"></script>

<!-- ============================================================ -->
# Introduction # {#introduction}
<!-- ============================================================ -->

*This section is non-normative.*

As the web has evolved there have been ongoing privacy-oriented changes
(e.g [Safari](https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/),
[Firefox](https://blog.mozilla.org/blog/2019/09/03/todays-firefox-blocks-third-party-tracking-cookies-and-cryptomining-by-default/),
[Chrome](https://blog.google/products/chrome/privacy-sustainability-and-the-importance-of-and/))
and changes to the underlying privacy principles (e.g. [[PRIVACY-MODEL]]).

With this evolution, fundamental assumptions of the web
platform are being redefined or removed. Access to cookies in a third-party
context are one of those assumptions. While overall good for the
web, the third-party cookie deprecation removes a fundamental building block
used by certain designs of federated identity.

The Federated Credential Management API aims to bridge the gap for the
federated identity designs which relied on third-party cookies.
The API provides the primitives needed to support federated identity when/where
it depends on third-party cookies, from sign-in to sign-out and revocation.

In order to provide the federated identity primitives without the use of
third-party cookies the API places the [=user agent=] as a mediator between a
<dfn><abbr title="Relying Party">RP</abbr></dfn> (website that requests user information for
federated sign in) and an <dfn><abbr title="Identity Provider">IDP</abbr></dfn> (website that provides
user information for federated sign in). This mediation requires user
permission before allowing the [=RPs=] and [=IDPs=] to know about their
connection to the user.

The specification leans heavily on changes in the [=user agent=] and [=IDP=]
and minimally on the [=RP=]. The FedCM API provides a way to authenticate and
fetch tokens.

<div class=example>
Example showing how a website allowing for a single logged in account
could be implemented.

```html
<html>
<head>
  <title>Welcome to my Website</title>
</head>
<body>
  <button onclick="login()">Login with idp.example</button>

  <script>
  let nonce;
  async function login() {
    try {
      // Assume there is a method returning a random number. Store the value in a variable which can
      // later be used to check against the value in the token returned.
      nonce = random();
      // Prompt the user to select an account from the IDP to use for
      // federated login within the RP. If resolved successfully, the Promise
      // returns an IdentityCredential object from which the |token| can be
      // extracted. This is an opaque string passed from the IDP to the RP.
      let token = await navigator.credentials.get({
        identity: {
          providers: [{
            configURL: "https://idp.example/manifest.json",
            clientId: "123",
            nonce: nonce,
          }]
        }
      });
    } catch(e) {
      // The FedCM call was not successful.
    }
  }
  </script>
</body>
</html>
```
</div>


At a high level, the Federated Credential Management API works by the
intermediation of cooperating [=IDP=]s and [=RP=]s.

The [[#idp-api]] defines a set of HTTP APIs that [=IDP=]s expose as well as the entry points in the
[[#browser-api]] that they can use.

<script type="text/typogram">
+-----------+                  +-----------+                      +-----------+
|           |                  |           |                      |           |
|  Relying  |                  |   User    |                      | Identity  |
|   Party   |                  |   Agent   |                      | Provider  |
|           |                  |           |                      |           |
|           |                  | Federated |                      |           |
|           |   +----------->*-+ Credential|     +------------->*-+ Well-Known|
|           |   |              | Management|     |                |           |
|           |   |              |    API    |     +------------->*-+ Config    |
|           |   |              |           |     |                |           |
|           |   |              |           |     +------------->*-+ Accounts  |
|           |   |              |           |     |                |           |
|           |   |              |           |     +------------->*-+ Client    |
|           |   |              |           |     |                | Metadata  |
|           |   |              |           |     |                |           |
|           |   |              |           |     +------------->*-+ Assertion |
|           |   |              |           |     |                |           |
|           |   |              |           |     |                |           |
| +-------+ |   |              | +-------+ |     |                |           |
| | JS    +-+---+              | + HTTP  +-+-----+                |           |
| +-------+ |                  | +-------+ |                      |           |
|           |                  |           |                      |           |
|           |                  |           |                      |           |
+-----------+                  +-----------+                      +-----------+
</script>

The user agent intermediates in such a matter that makes it impractical for the
API to be used for tracking purposes, while preserving the functionality of
identity federation.

<script type="text/typogram">
    Relying                             User                            Identity
    Party                               Agent                           Provider

      |                                   |                                 |
      | "navigator.credentials.get({    " | "(1) The RP invokes the API."   |
      | "  identity: {                  " |                                 |
      | "    providers: [{              " |                                 |
      | "      configURL: 'config.json'," |                                 |
      | "      clientId: clientId,      " |                                 |
      | "      nonce: nonce,            " |                                 |
      | "    }]                         " |                                 |
      | "  }                            " |                                 |
      | "})                             " |                                 |
      |                                   |                                 |
      |---------------------------------->|                                 |
      |                                   |                                 |
      |                                   |                                 |
      | "(2) From the configURL, the    " | "GET /.well-known/web-identity" |
      | "browser makes two requests     " |-------------------------------->|
      | "in parallel.                   " |                                 |
      |                                   | "GET /config.json"              |
      |                                   |-------------------------------->|
      |                                   |                                 |
      | "(3) The IdP responds with a    " |                                 |
      | "well-known file and a          " |                                 |
      | "config file.                   " |                                 |
      |                                   |                                 |
      |                                   |                                 |
      |                                   |                                 |
      | "The well-known file            " | "Well-Known file"               |
      | "contains a list of valid       " |<--------------------------------| "{"
      | "config URLs.                   " |                                 |   "provider_urls: [ ... ]"
      |                                   |                                 | "}"
      |                                   |                                 |
      | "The config file contains       " | "Config file"                   |
      | "information about the IdP.     " |<--------------------------------| "{"
      |                                   |                                 |   "id_assertion_endpoint: ...,"
      |                                   |                                 |   "accounts_endpoint: /accounts,"
      |                                   |                                 |   "client_metadata_endpoint: ...,"
      |                                   |                                 |   "branding: ...,"
      |                                   |                                 | "}"
      |                                   |                                 |
      | "(4) The browser proceeds to    " | "GET /accounts"                 |
      | "fetch the list of accounts     " | "Cookie: name=value"            |
      | "that the user is logged in     " |-------------------------------->|
      | "to.                            " |<--------------------------------| "{"
      |                                   |                                 |   "accounts: [ ... ]"
      |                                   |                                 | "}"
      |                                   |                                 |
      |                                   |                                 |
      | "(5) The browser then           " | "GET /client_metadata"          |
      | "fetches metadata about the     " | "client_id"                     |
      | "Relying Party.                 " |-------------------------------->|
      |                                   |<--------------------------------| "{"
      |                                   |                                 |   "terms_of_service_url: ...,"
      |                                   |                                 |   "privacy_policy_url: ...,"
      |                                   |                                 | "}"
      |                                   |                                 |
      |                                   |                                 |
      |                     +-------------+ "(6) With all of this, the    " |
      |                     |             | "browser asks for the user's  " |
      |                     |             | "permission to sign-in to the " |
      |  "account chooser"  |             | "RP with the IdP's account.   " |
      |                     |             |                                 |
      |                     |             |                                 |
      |                     +------------>|                                 |
      |                                   |                                 |
      |                                   |                                 |
      |                                   |                                 |
      | "(7) Once the user selects an   " | "POST /assertion"               |
      | "account and permission, the    " | "client_id, cookies, account"   |
      | "browser fetches the token.     " |-------------------------------->|
      |                                   |<--------------------------------| "{"
      |                                   |                                 |   "token: ...,"
      |                                   |                                 | "}"
      |                                   |                                 |
      |                "{ token }"        | "(8) Which is then ultimately " |
      |<----------------------------------| "used to resolve the promise. " |
      |                                   |                                 |
      |                                   |                                 |
     -+-                                 -+-                               -+-
</script>

<!-- ============================================================ -->
# The Browser API # {#browser-api}
<!-- ============================================================ -->

The Browser API exposes APIs to [=RP=]s and [=IDP=]s to call and intermediates
the exchange of the user's identity.

The Sign-up/Sign-in API is used by the [=RP=]s to ask the browser
to intermediate the relationship with the [=IDP=] and the
provisioning of a token.

NOTE: The [=RP=] makes no delineation between Sign-up and Sign-in, but
rather calls the same API indistinguishably.

If all goes well, the Relying Party receives back an {{IdentityCredential}}
which contains a token it can use to authenticate the user.

<div class=example>
```js
const credential = await navigator.credentials.get({
  identity: {
    providers: [{
      configURL: "https://idp.example/manifest.json",
      clientId: "123",
    }]
  }
});
```
</div>

For fetches that are sent with cookies, unpartitioned cookies are included,
as if the resource was loaded as a same-origin request, e.g.
regardless of the
[SameSite](https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#name-the-samesite-attribute-2)
value (which is used when a resource loaded as a third-party, not first-party). This makes it easy
for an [=IDP=] to adopt the FedCM API. It doesn't introduce security issues on the API because the
[=RP=] cannot inspect the results from the fetches in any way.

<!-- ============================================================ -->
## The connected accounts set ## {#browser-connected-accounts-set}
<!-- ============================================================ -->

Each [=user agent=] has a global <dfn>connected accounts set</dfn>, an initially empty
[=ordered set=]. Its [=list/items=] are triples of the form (|rp|, |idp|, |account|) where |rp| is
the [=/origin=] of the [=RP=], |idp| is the [=/origin=] of the [=IDP=], and |account| is a string representing
an account identifier. It represents the set of triples such that the user has used FedCM to login to
the |rp| via the |idp| |account|.

Issue: the [=connected accounts set=] should be double keyed in the [=RP=] (i.e., it should include
both the requester and the embedder, or in other words the iframe and the top-level). Otherwise the
top-level's state could be used and modified by the embedder, which introduces leaks and unwanted
cross-origin communication.

If a user clears browsing data for an |origin| (cookies, localStorage, etc.), the user agent MUST
[=list/remove=] all triples with an [=/origin=] matching the |origin| from <a>connected accounts set</a>.

<div algorithm>
To <dfn>compute the connected account key</dfn> given an {{IdentityProviderConfig}} |provider|, an
{{IdentityProviderAccount}} |account|, and a |globalObject|, run the following steps. It returns a
triple of the form (rp, idp, account).
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. Let |idpOrigin| be the [=url/origin=] corresponding to |configUrl|.
    1. Let |rpOrigin| be |globalObject|'s [=associated Document=]'s [=Document/origin=].
    1. Let |accountId| be |account|'s {{IdentityProviderAccount/id}}.
    1. Return (|rpOrigin|, |idpOrigin|, |accountId|).
</div>

<div algorithm>
When asked whether an {{IdentityProviderAccount}} |account| is
<dfn>eligible for auto reauthentication</dfn> given an {{IdentityProviderConfig}} |provider| and a
|globalObject|, run the following steps. This returns a boolean.
    1. If |account| [=map/contains=] {{IdentityProviderAccount/approved_clients}} and
        |account|'s {{IdentityProviderAccount/approved_clients}} does not [=list/contain=]
        |provider|'s {{IdentityProviderConfig/clientId}}, return false.
    1. Let |triple| be the result of running [=compute the connected account key=] given |provider|,
        |account|, and |globalObject|.
    1. Return whether [=connected accounts set=] [=list/contains=] |triple|.
</div>

<div algorithm="compute the connection status">
When asked to <dfn>compute the connection status</dfn> given an {{IdentityProviderAccount}}
|account|, an {{IdentityProviderConfig}} |provider| and a |globalObject|, run the following steps.
This returns <dfn for="compute the connection status">connected</dfn> or
<dfn for="compute the connection status">disconnected</dfn>.
    1. If |account| [=map/contains=] {{IdentityProviderAccount/approved_clients}}:
        1. If |account|'s {{IdentityProviderAccount/approved_clients}} [=list/contains=]|provider|'s
            {{IdentityProviderConfig/clientId}}, return [=compute the connection status/connected=].
        1. Return [=compute the connection status/disconnected=].
    1. Let |triple| be the result of running [=compute the connected account key=] given |provider|,
        |account|, and |globalObject|.
    1. If [=connected accounts set=] [=list/contains=] |triple|, return
        [=compute the connection status/connected=].
    1. Return [=compute the connection status/disconnected=].
</div>

<div algorithm>
To <dfn>create a connection between the RP and the IdP account</dfn> given an
{{IdentityProviderConfig}} |provider|, an {{IdentityProviderAccount}} |account|, and a
|globalObject| (the [=RP=]'s), run the following steps:
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. Let |idpOrigin| be the [=url/origin=] corresponding to |configUrl|.
    1. Let |rpOrigin| be |globalObject|'s [=associated Document=]'s [=Document/origin=].
    1. Let |accountId| be |account|'s {{IdentityProviderAccount/id}}.
    1. Let |triple| be (|rpOrigin|, |idpOrigin|, |accountId|).
    1. [=set/Append=] |triple| to [=connected accounts set=].
</div>

<div algorithm>
To <dfn>remove a connection</dfn>: given |accountId|, |rpOrigin|, and |idpOrigin|, run the
following steps. It returns whether the |accountId| connection was successfully removed.
    1. Let |triple| be (|rpOrigin|, |idpOrigin|, |accountId|).
    1. If [=connected accounts set=] [=list/contains=] |triple|:
        1. [=list/Remove=] |triple| from the [=connected accounts set=].
        1. Return true.
    1. Return false.
</div>

<div algorithm>
To <dfn>remove all connections</dfn>: given |rpOrigin| and |idpOrigin|, run the following steps:
    1. For every (|rp|, |idp|, <var ignore="">accountId</var>) |triple| in the
        [=connected accounts set=]:
        1. If |rp| equals |rpOrigin| and |idp| equals |idpOrigin|, [=list/remove=] |triple| from the
            [=connected accounts set=].
</div>

<!-- ============================================================ -->
## The IdentityCredential Interface ## {#browser-api-identity-credential-interface}
<!-- ============================================================ -->

This specification introduces a new type of {{Credential}}, called an {{IdentityCredential}}:

<pre class="idl">
  dictionary IdentityCredentialDisconnectOptions : IdentityProviderConfig {
    required USVString accountHint;
  };

  [Exposed=Window, SecureContext]
  interface IdentityCredential : Credential {
    static Promise&lt;undefined&gt; disconnect(optional IdentityCredentialDisconnectOptions options = {});
    readonly attribute USVString? token;
    readonly attribute boolean isAutoSelected;
  };
</pre>

<dl>
    :   <b>{{Credential/id}}</b>
    ::  The {{Credential/id}}'s attribute getter returns the empty string.
    :   <b>{{IdentityCredential/token}}</b>
    ::  The {{IdentityCredential/token}}'s attribute getter returns the value it is set to.
        It represents the minted {{IdentityProviderToken/token}} provided by the [=IDP=].
    :   <b>{{IdentityCredential/isAutoSelected}}</b>
    ::  {{IdentityCredential/isAutoSelected}}'s attribute getter returns the value it is
        set to. It represents whether the user's identity credential was automatically selected when
        going through the UI flow which resulted in this {{IdentityCredential}}.
    :   <b>{{Credential/[[type]]}}</b>
    ::  The {{IdentityCredential}}'s {{Credential/[[type]]}}'s value is "<b>identity</b>".
    :   <b>{{Credential/[[discovery]]}}</b>
    ::  The {{IdentityCredential}}'s {{Credential/[[discovery]]}}'s value is
        {{Credential/[[discovery]]/remote}}.
</dl>

The main entrypoint in this specification is through the entrypoints exposed
by the [[CM]] API.

<!-- ============================================================ -->
### The disconnect method ### {#browser-api-identity-credential-disconnect}
<!-- ============================================================ -->

<div algorithm="identity-credential-disconnect">
When the static {{IdentityCredential/disconnect}} method is invoked, given an
{{IdentityCredentialDisconnectOptions}} |options|, perform the following steps:

    1. Let |globalObject| be the [=current global object=].
    1. Let |document| be |globalObject|'s [=associated Document=].
    1. If |document| is not [=allowed to use=] the [=identity-credentials-get=]
        [=policy-controlled feature=], throw a "{{NotAllowedError}}" {{DOMException}}.
    1. Let |promise| be a new {{Promise}}.
    1. [=In parallel=], [=attempt to disconnect=] given |options|, |promise|, and |globalObject|.
    1. Return |promise|.
</div>

<div algorithm>
When asked to <dfn>attempt to disconnect</dfn> given an {{IdentityCredentialDisconnectOptions}}
|options|, a {{Promise}} |promise|, and a |globalObject|, perform the following steps:

    1. Assert: these steps are running [=in parallel=].
    1. Let |configUrl| be the result of running [=parse url=] with |options|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. If |configUrl| is failure, [=reject=] |promise| with an "{{InvalidStateError}}"
        {{DOMException}}.
    1. Run a [[!CSP]] check with a [[CSP#directive-connect-src|connect-src]] directive on the URL
        passed as |configUrl|. If it fails, [=reject=] |promise| with a "{{NetworkError}}"
        {{DOMException}}.
    1. If there is another pending {{IdentityCredential/disconnect}} call for this |globalObject|
        (e.g., it has not yet thrown an exception or its associated {{Promise}} has not yet been
        resolved), [=reject=] |promise| with a "{{NetworkError}}" {{DOMException}}.
    1. If |configUrl| is not a [=potentially trustworthy origin=], [=reject=] |promise| with a
        "{{NetworkError}}" {{DOMException}}.
    1. If the user has disabled the FedCM API on the |globalObject|, [=reject=] |promise| with a
        "{{NetworkError}}" {{DOMException}}.
    1. If there does not exist an account |account| such that [=connected accounts set=]
        [=list/contains=] the result of [=compute the connected account key=] given |account|,
        |options|, and |globalObject|, then [=reject=] |promise| with a "{{NetworkError}}"
        {{DOMException}}. This check can be performed by iterating over the
        [=connected accounts set=] or by keeping a separate data structure to make this lookup fast.
    1. Let |config| be the result of running [=fetch the config file=] with
        |provider| and |globalObject|.
    1. If |config| is failure, [=reject=] |promise| with a "{{NetworkError}}" {{DOMException}}.
    1. Let |disconnectUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|.{{IdentityProviderAPIConfig/disconnect_endpoint}}, and |globalObject|.
    1. If |disconnectUrl| is failure, [=reject=] |promise| with a "{{NetworkError}}"
        {{DOMException}}.
    1. [=Send a disconnect request=] with |disconnectUrl|, |options|, and |globalObject|, and let
        |result| be the result.
    1. Let |idpOrigin| be the [=url/origin=] corresponding to |configUrl|.
    1. Let |rpOrigin| be |globalObject|'s [=associated Document=]'s [=Document/origin=].
    1. If |result| is failure:
        1. [=Remove all connections=] given |rpOrigin| and |idpOrigin|.
        1. [=Reject=] |promise| with a "{{NetworkError}}" {{DOMException}}.
        1. Return.
    1. Let |accountId| be |result| (note that it is not failure).
    1. [=Remove a connection=] using |accountId|, |rpOrigin|, and |idpOrigin|, and let
        |wasAccountRemoved| be the result.
    1. If |wasAccountRemoved| is false, [=remove all connections=] given |rpOrigin| and |idpOrigin|.
    1. [=Resolve=] |promise|.
</div>

<!-- ============================================================ -->
#### Disconnect request #### {#disconnect-request}
<!-- ============================================================ -->

The [=send a disconnect request=] algorithm sends a request to disconnect an account that has
previously been used for federated login in the [=RP=].

<div algorithm>
When asked to <dfn>send a disconnect request</dfn>, given a <a spec=url for=/>URL</a>
|disconnectUrl|, and {{IdentityCredentialDisconnectOptions}} |options|, and a |globalObject|,
perform the following steps. This returns an {{USVString}} or failure.

    1. Let |requestBody| be the result of running [=urlencoded serializer=] with a list containing:
        1. ("client_id", |options|'s {{IdentityProviderConfig/clientId}})
        1. ("account_hint",  |options|'s {{IdentityCredentialDisconnectOptions/accountHint}})
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |disconnectUrl|
        :  [=request/method=]
        :: "POST"
        :  [=request/body=]
        :: the [=UTF-8 encode=] of |requestBody|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: |globalObject|'s [=associated document=]'s [=Document/origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/x-www-form-urlencoded`
        :  [=request/credentials mode=]
        :: "include"
        :  [=request/mode=]
        :: "cors"

    1. Let |accountId| be null.
    1. [=Fetch request=] with |request| and |globalObject|, and with
        <var ignore>processResponseConsumeBody</var> set to the following steps given a
        <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to a {{DisconnectedAccount}}, |account|.
        1. If one of the previous two steps threw an exception, set |accountId| to failure
            and return.
        1. Set |accountId| to |account|'s {{DisconnectedAccount/account_id}}.
    1. Wait for |accountId| to be set.
    1. Return |accountId|.
</div>

<xmp class="idl">
dictionary DisconnectedAccount {
  required USVString account_id;
};
</xmp>

<!-- ============================================================ -->
### The CredentialRequestOptions ### {#browser-api-credential-request-options}
<!-- ============================================================ -->

This section defines the dictionaries passed into the JavaScript call:

<div class=example>
```js
const credential = await navigator.credentials.get({
  identity: { // IdentityCredentialRequestOptions
    providers: [{  // sequence<IdentityCredentialRequestOptions>
      configURL: "https://idp.example/manifest.json", // IdentityProviderConfig.configURL
      clientId: "123", // IdentityProviderConfig.clientId
      nonce: "nonce" // IdentityProviderConfig.nonce
    }]
  }
});
```
</div>

This specification introduces an extension to the {{CredentialRequestOptions}} object:

<pre class="idl">
  partial dictionary CredentialRequestOptions {
    IdentityCredentialRequestOptions identity;
  };
</pre>

The {{IdentityCredentialRequestOptions}} contains a list of
{{IdentityProviderConfig}}s that the [=RP=] supports and has
pre-registered with (i.e. the [=IDP=] has given the [=RP=] a `clientId`).
The {{IdentityCredentialRequestOptions}} also contains a {{IdentityCredentialRequestOptionsContext}}
which the user agent can use to provide a more meaningful dialog to users.

<xmp class=idl>
enum IdentityCredentialRequestOptionsContext {
  "signin",
  "signup",
  "use",
  "continue"
};

dictionary IdentityCredentialRequestOptions {
  required sequence<IdentityProviderRequestOptions> providers;
  IdentityCredentialRequestOptionsContext context = "signin";
};
</xmp>

Each {{IdentityProviderConfig}} represents an [=IDP=] that
the [=RP=] supports (e.g. that it has a pre-registration agreement with).

<xmp class=idl>
dictionary IdentityProviderConfig {
  required USVString configURL;
  required USVString clientId;
};

dictionary IdentityProviderRequestOptions : IdentityProviderConfig {
  USVString nonce;
  DOMString loginHint;
  DOMString domainHint;
};
</xmp>

<dl>
    :   <b>{{IdentityProviderConfig/configURL}}</b>
    ::  The URL of the configuration file for the identity provider.
    :   <b>{{IdentityProviderConfig/clientId}}</b>
    ::  The {{id_assertion_endpoint_request/client_id}} provided to the [=RP=] out of band by the [=IDP=]
    :   <b>{{IdentityProviderRequestOptions/nonce}}</b>
    ::  A random number of the choice of the [=RP=]. It is generally used to associate a client
        session with a {{IdentityProviderToken/token}} and to mitigate replay attacks. Therefore, this value should have
        sufficient entropy such that it would be hard to guess.
    :   <b>{{IdentityProviderRequestOptions/loginHint}}</b>
    ::  A string representing the login hint corresponding to an account which the RP wants the user
        agent to show to the user. If provided, the user agent will not show accounts which do not
        match this login hint value. It generally matches some attribute from the desired
        {{IdentityProviderAccount}}.
    :   <b>{{IdentityProviderRequestOptions/domainHint}}</b>
    ::  A string representing the domain hint corresponding to a domain which the [=RP=] is
        interested in, or "any" if the [=RP=] wants any account associated with at least one domain
        hint. If provided, the user agent will not show accounts which do not match the domain hint
        value.
</dl>

<!-- ============================================================ -->
### The <code>\[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</code> internal method ### {#browser-api-rp-sign-in}
<!-- ============================================================ -->

The {{Credential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}
algorithm runs in parallel inside [[credential-management#algorithm-request]] to request
credentials and returns an {{IdentityCredential}} or an error.

This [=internal method=] accepts three arguments:

<dl dfn-type="argument" dfn-for="IdentityCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">
    :   <dfn>origin</dfn>
    ::  This argument is the [=relevant settings object=]'s
         [=environment settings object/origin=], as determined by the
         calling {{CredentialsContainer/get()}} implementation, i.e.,
         {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a>
         abstract operation.
    :   <dfn>options</dfn>
    ::  This argument is a {{CredentialRequestOptions}} object whose
        {{CredentialRequestOptions/identity}} member [=map/exists=].
    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the
         caller's [=environment settings object=] is
         [=same-origin with its ancestors=]. It is [FALSE] if caller is cross-origin.

        Note: Invocation of this [=internal method=] indicates that it was allowed by
        [=permissions policy=], which is evaluated at the [[!CREDENTIAL-MANAGEMENT-1]] level.
        See [[#permissions-policy-integration]]. As such,
            <var ignore=''>sameOriginWithAncestors</var> is unused.

</dl>

The <var ignore="">options</var>.{{CredentialRequestOptions/signal}} is used as an abort signal for the
requests.

<div algorithm="[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">
When the {{IdentityCredential}}'s
<dfn for="IdentityCredential" method>\[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</dfn>
algorithm is invoked, the user agent MUST execute the following steps. This returns an
{{IdentityCredential}} (or throws an error to the caller).

    1. Assert: These steps are running [=in parallel=].
    1. If the [=list/size=] of
        |options|["{{CredentialRequestOptions/identity}}"]["{{IdentityCredentialRequestOptions/providers}}"]
        is not equal to 1, [=queue a global task=] on the [=DOM manipulation task source=] given
        |globalObject| to throw a new "{{NetworkError}}" {{DOMException}}

        Note: The |globalObject| is not currently passed onto the
        {{Credential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}
        algorithm. See <a href="https://github.com/w3c/webappsec-credential-management/issues/210">issue</a>.


        Issue: Support choosing accounts from multiple [=IDP=]s, as described [here](https://github.com/fedidcg/FedCM/issues/319).
    1. The user agent can decide when to continue with the next steps.

        Note: For example, user agents may show an identity provider selector before making
            network requests, or provide a button in the URL bar and wait for user input
            before continuing.
    1. Let |provider| be |options|["{{CredentialRequestOptions/identity}}"]["{{IdentityCredentialRequestOptions/providers}}"][0].
    1. Let |credential| be the result of running [=create an IdentityCredential=] with |provider|,
        |options|, and |globalObject|.
    1. If |credential| is a pair:
        1. Let |throwImmediately| be the value of the second element of the pair.
        1. The user agent SHOULD wait a random amount of time
            before the next step if all of the following conditions hold:
            * |throwImmediately| is false
            * The <dfn>promise rejection delay</dfn> was not disabled by
                [=setdelayenabled|user agent automation=]
            * The user agent has not implemented another way to prevent
                exposing to the RP whether the user has an account logged
                in to the RP

            Note: The intention here is as follows. If the the promise was resolved immediately,
                then an RP could infer that no dialog was shown because the promise was
                resolved quickly, after just the network delay. A shown dialog implies
                that the user is logged in to one or more accounts of the IDP. To prevent
                this information leakage, especially without user confirmation, this delay is specified.
                However, UAs may have different UI approaches here and prevent it in a different way.
        1. [=Queue a global task=] on the [=DOM manipulation task source=]
            to throw a new "{{NetworkError}}" {{DOMException}}.
    1. Otherwise, return |credential|.
</div>

<!-- ============================================================ -->
### Create an IdentityCredential ### {#create-identity-credential}
<!-- ============================================================ -->

The <a>create an IdentityCredential</a> algorithm invokes the various FedCM fetches, shows the user
agent UI, and creates the {{IdentityCredential}} that is then returned to the [=RP=].

<div algorithm="create an IdentityCredential">
To <dfn>create an IdentityCredential</dfn> given an {{IdentityProviderRequestOptions}}
|provider|, a {{CredentialRequestOptions}} |options|, and a
|globalObject|, run the following steps. This returns an {{IdentityCredential}}
or a pair (failure, bool), where the bool indicates whether to skip delaying
the exception thrown.
    1. Assert: These steps are running [=in parallel=].
    1. Let |loginStatus| be the result of [=get the login status=] with
        the [=/origin=] of |provider|'s {{IdentityProviderConfig/configURL}}.
    1. If |loginStatus| is [=unknown=], a user agent MAY set it to [=logged-out=].
    1. If |loginStatus| is [=logged-out=], the user agent MUST do one of the following:

        * Return (failure, false).
        * Prompt the user whether to continue. If the user continues, the user
            agent SHOULD set |loginStatus| to [=unknown=]. This MAY include an
            affordance to [=show an IDP login dialog=].

            * If the user cancels this dialog, return (failure, true).
            * If the user triggers this affordance:
                1. Let |config| be the result of running [=fetch the config file=]
                    with |provider| and |globalObject|.
                1. If |config| is failure, return (failure, true).
                1. [=Show an IDP login dialog=] with |config| and |provider|.
                1. If that algorithm returns failure, return (failure, true).

        Issue: We should perhaps provide a way to let the [=RP=] request that
            the second option is provided, possibly gated on a user gesture.
            See [this issue](https://github.com/fedidcg/FedCM/issues/442) for discussion.
    1. Let |requiresUserMediation| be |provider|'s {{IdentityProviderConfig/configURL}}'s [=/origin=]'s
        [=requires user mediation=].
    1. Let |mediation| be |options|'s {{CredentialRequestOptions/mediation}}.
    1. If |requiresUserMediation| is true and |mediation| is
        "{{CredentialMediationRequirement/silent}}", return (failure, true).
    1. Let |config| be the result of running [=fetch the config file=] with
        |provider| and |globalObject|.
    1. If |config| is failure, return (failure, false).
    1. <dfn>Fetch accounts step</dfn>: Let |accountsList| be the result of
        [=fetch the accounts=] with |config|, |provider|, and |globalObject|.
    1. If |accountsList| is failure, or the size of |accountsList| is 0:
        1. [=Set the login status=] for the [=/origin=] of the
            {{IdentityProviderConfig/configURL}} to [=logged-out=].
            A user agent may decide to skip this step if no credentials were
            sent to server.

            Note: For example, if the fetch failed due to a DNS error, no
                credentials were sent and therefore the [=IDP=] did not learn
                the user's identity. In this situation, we do not know whether
                the user is signed in or not and so we may not want to reset
                the status.
        1. <dfn>Mismatch dialog step</dfn>: If |loginStatus| is [=logged-in=], show a
            dialog to the user. The contents of this dialog are defined by the user
            agent. This dialog SHOULD provide an affordance for the user to trigger
            the [=show an IDP login dialog=] algorithm with |config| and |provider|;
            this dialog is the <dfn>confirm IDP login dialog</dfn>.

            Note: This situation happens when the browser expects the user
                to be signed in, but the accounts fetch indicated that the user
                is signed out.

            Note: This dialog ensures that silent tracking of the user is
                impossible by always showing UI of some kind when credentials
                were sent to the server.

            1. Wait until one of the following occurs:

                * If the user closes the dialog, return (failure, true).

                * If the [=show an IDP login dialog=] algorithm was triggered:

                    1. Let |result| be the result of that algorithm.
                    1. If |result| is failure, return (failure, true). The user
                        agent MAY show a dialog to the user before or after
                        returning failure indicating this failure.
                    1. Otherwise, go back to the [=fetch accounts step=].

    1. Assert: |accountsList| is not failure and the size of |accountsList| is not 0.
    1. [=Set the login status=] for the [=/origin=] of the
        {{IdentityProviderConfig/configURL}} to [=logged-in=].
    1. If |provider|'s {{IdentityProviderRequestOptions/loginHint}} is not empty:
        1. For every |account| in |accountList|, remove |account| from |accountList| if |account|'s
            {{IdentityProviderAccount/login_hints}} does not [=list/contain=] |provider|'s
            {{IdentityProviderRequestOptions/loginHint}}.
        1. If |accountList| is now empty, go to the [=mismatch dialog step=].
    1. If |provider|'s {{IdentityProviderRequestOptions/domainHint}} is not empty:
        1. For every |account| in |accountList|:
            1. If {{IdentityProviderRequestOptions/domainHint}} is "any":
                1. If |account|'s {{IdentityProviderAccount/domain_hints}} is empty, remove
                    |account| from |accountList|.
            1. Otherwise, remove |account| from |accountList| if |account|'s
                {{IdentityProviderAccount/domain_hints}} does not [=list/contain=] |provider|'s
                {{IdentityProviderRequestOptions/domainHint}}.
        1. If |accountList| is now empty, go to the [=mismatch dialog step=].
    1. For each |acc| in |accountsList|:
        1. If |acc|["{{IdentityProviderAccount/picture}}"] is present, [=fetch the account picture=]
            with |acc| and |globalObject|.

        Note: The [=user agent=] may choose to show UI which does not initially require fetching the
        account pictures. In these cases, the [=user agent=] may delay these fetches until they are
        needed. Because errors from these fetches are ignored, they can happen in any order.
    1. Let |registeredAccount|, |numRegisteredAccounts| be null and 0, respectively.
    1. Let |account| be null.
    1. For each |acc| in |accountsList|:
        1. If |acc| is [=eligible for auto reauthentication=] given |provider|, and |globalObject|,
            set |registeredAccount| to |acc| and increase |numRegisteredAccounts| by 1.
    1. Let |permission|, |disclosureTextShown|, and |isAutoSelected| be set to false.
    1. If |mediation| is not "{{CredentialMediationRequirement/required}}", |requiresUserMediation|
        is false, and |numRegisteredAccounts| is equal to 1:
        1. Set |account| to |registeredAccount| and |permission| to true. When doing this, the user
            agent MAY show some UI to the user indicating that they are being
            <dfn>auto-reauthenticated</dfn>.
        1. Set |isAutoSelected| to true.
    1. Otherwise, if |mediation| is "{{CredentialMediationRequirement/silent}}", return (failure, true).
    1. Otherwise, if |accountsList|'s size is 1:
        1. Set |account| to |accountsList|[0].
        1. If [=compute the connection status=] of |account|, |provider| and |globalObject| returns
            [=compute the connection status/connected=], show a dialog to request user permission to sign
            in via |account|, and set the result in |permission|. The user agent MAY use |options|'s
            {{IdentityCredentialRequestOptions/context}} to customize the dialog.
        1. Otherwise, let |permission| be the result of running [=request permission to sign-up=]
            algorithm with |account|, |config|, |provider|, and |globalObject|. Also set
            |disclosureTextShown| to true.
    1. Otherwise:
        1. Set |account| to the result of running the [=select an account=] from the
            |accountsList|.
        1. If |account| is failure, return (failure, true).
        1. If [=compute the connection status=] of |account|, |provider| and |globalObject| is
            [=compute the connection status/connected=], set |permission| to true.
        1. Otherwise:
            1. Let |permission| be the result of running the [=request permission to sign-up=]
                algorithm with |account|, |config|, |provider|, and |globalObject|.
            1. Set |disclosureTextShown| to true.
    1. Wait until the [=user agent=]'s dialogs requesting for user choice or permission to be
        closed, if any are created in the previous steps.
    1. Assert: |account| is not null.
    1. If |permission| is false, then return (failure, true).
    1. Let |credential| be the result of running the [=fetch an identity assertion=] algorithm with
        |account|'s {{IdentityProviderAccount/id}}, |disclosureTextShown|, |isAutoSelected|,
        |provider|, |config|, and |globalObject|.
    1. Return |credential|.
</div>

<!-- ============================================================ -->
### Fetch the config file ### {#fetch-config-file}
<!-- ============================================================ -->

The <a>fetch the config file</a> algorithm fetches both the [=well-known file=] and the config file from
the [=IDP=], checks that the config file is mentioned in the [=well-known file=], and returns the config.

<div algorithm>
To <dfn>fetch the config file</dfn> given an {{IdentityProviderRequestOptions}} |provider| and
|globalObject|, run the following steps. This returns an {{IdentityProviderAPIConfig}}
or failure.
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. If |configUrl| is failure, return failure.
    1. Run a [[!CSP]] check with a [[CSP#directive-connect-src|connect-src]] directive on the URL
        passed as |configUrl|. If it fails, return failure.
    1. If |configUrl| is not a [=potentially trustworthy URL=], return failure.
    1. Let |rootUrl| be a new [=/URL=].
    1. Set |rootUrl|'s [=url/scheme=] to |configUrl|'s [=url/scheme=].
    1. Set |rootUrl|'s [=url/host=] to |configUrl|'s [=url/host=]'s [=host/registrable domain=].
    1. Set |rootUrl|'s [=url/path=] to the <a>list</a> «".well-known", "web-identity"».
    1. Let |config|, |configInWellKnown| both be null.
    1. Let |rpOrigin| be |globalObject|'s [=associated Document=]'s [=Document/origin=].
    1. If |rpOrigin| is not an [=opaque origin=], and |rootUrl|'s [=url/host=] is equal
        to |rpOrigin|'s [=host/registrable domain=], and |rootUrl|'s [=url/scheme=] is
        equal to |rpOrigin|'s [=origin/scheme=], set |configInWellKnown| to true.

        Note: Because domain cookies are valid across an entire site, there is no privacy
            benefit from doing the well-known check if the RP and IDP are in the same site.
    1. Otherwise:
        1. Let |wellKnownRequest| be a new [=/request=] as follows:

            :  [=request/URL=]
            :: |rootUrl|
            :  [=request/client=]
            :: null
            :  [=request/window=]
            :: "no-window"
            :  [=request/service-workers mode=]
            :: "none"
            :  [=request/destination=]
            :: "webidentity"
            :  [=request/origin=]
            :: a unique [=opaque origin=]
            :  [=request/header list=]
            :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
                [=header/value=] set to `application/json`
            :  [=request/referrer policy=]
            :: "no-referrer"
            :  [=request/credentials mode=]
            :: "omit"
            :  [=request/mode=]
            :: "no-cors"

            Issue: The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
            with [=request/mode=] set to "user-agent-no-cors". See the relevant
            [pull request](https://github.com/whatwg/fetch/pull/1533) for details.

        1. [=Fetch request=] with |wellKnownRequest| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
            set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
            1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
                |responseBody|.
            1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderWellKnown}},
                |discovery|.
            1. If one of the previous two steps threw an exception, or if the
                [=list/size=] of |discovery|["{{IdentityProviderWellKnown/provider_urls}}"] is
                greater than 1, set |configInWellKnown| to false.

                Issue: [relax](https://github.com/fedidcg/FedCM/issues/333) the size of the
                provider_urls array.

            1. Otherwise, set to |configInWellKnown| to true if
                |discovery|["{{IdentityProviderWellKnown/provider_urls}}"][0] [=string/is=] equal to
                |provider|'s {{IdentityProviderConfig/configURL}}, and to false otherwise.

    1. Let |configRequest| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |configUrl|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/json`
        :  [=request/referrer policy=]
        :: "no-referrer"
        :  [=request/credentials mode=]
        :: "omit"
        :  [=request/mode=]
        :: "no-cors"

        Issue: The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
        with [=request/mode=] set to "user-agent-no-cors". See the relevant
        [pull request](https://github.com/whatwg/fetch/pull/1533) for details.

    1. [=Fetch request=] with |configRequest| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderAPIConfig}} stored
            in |config|.
        1. If one of the previous two steps threw an exception, set |config| to failure.
        1. Set |config|.{{IdentityProviderAPIConfig/login_url}} to the result of [=computing
            the manifest URL=] with |provider|, |config| and |globalObject|.
        1. If |config|.{{IdentityProviderAPIConfig/login_url}} is null, return failure.
    1. Wait for both |config| and |configInWellKnown| to be set.
    1. If |configInWellKnown| is true, return |config|. Otherwise, return failure.
</div>

NOTE: a two-tier file system is used in order to prevent the [=IDP=] from easily determining the [=RP=]
that a user is visiting by encoding the information in the config file path. This issue is solved by
requiring a [=well-known file=] to be on the root of the [=IDP=]. The config file itself can be anywhere, but
it will not be used if the user agent does not find it in the [=well-known file=]. This allows the [=IDP=]
to keep their actual config files on an arbitary path while allowing the user agent to prevent config file
path manipulation to fingerprint (for instance, by including the RP in the path). See
[[#manifest-fingerprinting]].

<xmp class="idl">
dictionary IdentityProviderWellKnown {
  required sequence<USVString> provider_urls;
};

dictionary IdentityProviderIcon {
  required USVString url;
  unsigned long size;
};

dictionary IdentityProviderBranding {
  USVString background_color;
  USVString color;
  sequence<IdentityProviderIcon> icons;
  USVString name;
};

dictionary IdentityProviderAPIConfig {
  required USVString accounts_endpoint;
  required USVString client_metadata_endpoint;
  required USVString id_assertion_endpoint;
  required USVString login_url;
  USVString disconnect_endpoint;
  IdentityProviderBranding branding;
};
</xmp>

<!-- ============================================================ -->
### Fetch the accounts ### {#fetch-accounts}
<!-- ============================================================ -->

The <a>fetch the accounts</a> algorithm fetches the [=accounts endpoint=] to determine the
list of [=IDP=] accounts that the user is signed in to, so that the user agent can later show the
FedCM UI to the user.

<div algorithm>
To <dfn>fetch the accounts</dfn> given an {{IdentityProviderAPIConfig}} |config|, an
{{IdentityProviderRequestOptions}} |provider|, and |globalObject|, run the following steps. This
returns an {{IdentityProviderAccountList}}.
    1. Let |accountsUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|["{{IdentityProviderAPIConfig/accounts_endpoint}}"], and |globalObject|.
    1. If |accountsUrl| is failure, return an empty list.
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |accountsUrl|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/json`
        :  [=request/referrer policy=]
        :: "no-referrer"
        :  [=request/credentials mode=]
        :: "include"
        :  [=request/mode=]
        :: "no-cors"

        Issue: The credentialed fetch in this algorithm can lead to a timing attack that leaks the
        user's identities before the user grants permission. This is an active area of investigation
        that is being explored [here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1089040953).

        Issue: The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
        with [=request/mode=] set to "user-agent-no-cors". See the relevant
        [pull request](https://github.com/whatwg/fetch/pull/1533) for details.

    1. Let |accountsList| be null.
    1. [=Fetch request=] with |request| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderAccountList}}, and
            store the result in |accountsList|.
        1. If one of the previous two steps threw an exception, set |accountsList| to failure.

        Issue: the accounts list returned here should be validated for repeated ids, as described
        [here](https://github.com/fedidcg/FedCM/issues/336).

    1. Wait for |accountsList| to be set.
    1. Return |accountsList|.
</div>

<xmp class="idl">
dictionary IdentityProviderAccount {
  required USVString id;
  required USVString name;
  required USVString email;
  USVString given_name;
  USVString picture;
  sequence<USVString> approved_clients;
  sequence<DOMString> login_hints;
  sequence<DOMString> domain_hints;
};
dictionary IdentityProviderAccountList {
  sequence<IdentityProviderAccount> accounts;
};
</xmp>

<div algorithm>
To <dfn>fetch the account picture</dfn> given an {{IdentityProviderAccount}} |account| and a
|globalObject|, run the following steps:
    1. Let |pictureUrl| be the result of running [=parse url=] with
        |account|["{{IdentityProviderAccount/picture}}"] and |globalObject|.
    1. If |pictureUrl| is failure, abort these steps. The user agent may use a placeholder image.
    1. Let |pictureRequest| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |pictureUrl|
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "image"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/referrer policy=]
        :: "no-referrer"
        :  [=request/credentials mode=]
        :: "omit"
        :  [=request/mode=]
        :: "no-cors"

        Issue: The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
        with [=request/mode=] set to "user-agent-no-cors". See the relevant
        [pull request](https://github.com/whatwg/fetch/pull/1533) for details.

    1. [=Fetch request=] with |pictureRequest| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
        set to the following steps given a <var ignore=''>response</var> and a |responseBody|:
        1. If |responseBody| is null or failure, the user agent may choose an arbitrary placeholder image
            and associate it with the |account|.
        1. Otherwise, decode |responseBody| into an image, and associate it with |account| if successful. This
            allows the user agent to use the decoded image in a dialog displaying |account|.
</div>

<!-- ============================================================ -->
### Fetch an identity assertion ### {#fetch-identity-assertion}
<!-- ============================================================ -->

The <a>fetch an identity assertion</a> algorithm is invoked after the user has granted permission to
use FedCM with a specific [=IDP=] account. It fetches the [=identity assertion endpoint=] to obtain
the token that will be provided to the [=RP=].

<div algorithm>
To <dfn>fetch an identity assertion</dfn> given a {{USVString}}
    |accountId|, a boolean |disclosureTextShown|, a boolean |isAutoSelected|, an
    {{IdentityProviderRequestOptions}} |provider|, an {{IdentityProviderAPIConfig}} |config|,
    and |globalObject|, run the following steps. This returns an {{IdentityCredential}} or failure.
    1. Let |tokenUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|["{{IdentityProviderAPIConfig/id_assertion_endpoint}}"], and |globalObject|.
    1. If |tokenUrl| is failure, return failure.
    1. Let |requestBody| be the result of running [=urlencoded serializer=] with a list containing:
        1. ("client_id", |provider|'s {{IdentityProviderConfig/clientId}})
        1. ("nonce", |provider|'s {{IdentityProviderRequestOptions/nonce}})
        1. ("account_id",  |accountId|)
        1. ("disclosure_text_shown", |disclosureTextShown|)
        1. ("is_auto_selected", |isAutoSelected|)
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |tokenUrl|
        :  [=request/method=]
        :: "POST"
        :  [=request/body=]
        :: the [=UTF-8 encode=] of |requestBody|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: |globalObject|'s [=associated document=]'s [=Document/origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/x-www-form-urlencoded`
        :  [=request/credentials mode=]
        :: "include"
        :  [=request/mode=]
        :: "cors"

    1. Let |credential| be null.
    1. [=Fetch request=] with |request| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderToken}}, |token|.
        1. If one of the previous two steps threw an exception, set |credential| to failure
            and return.
        1. Let |credential| be a new {{IdentityCredential}} given |globalObject|'s
            <a for="global object">realm</a>.
        1. Set |credential|'s {{IdentityCredential/token}} to |token|.
        1. Set |credential|'s {{IdentityCredential/isAutoSelected}} to
            |isAutoSelected|.
    1. Wait for |credential| to be set.
    1. Return |credential|.
</div>

<xmp class="idl">
dictionary IdentityProviderToken {
  required USVString token;
};
</xmp>

<!-- ============================================================ -->
### Request permission to sign-up ### {#request-permission-signup}
<!-- ============================================================ -->

<div algorithm>
To <dfn>select an account</dfn> given an |accountsList|, run the following steps. This returns an
{{IdentityProviderAccount}} or failure.
    1. Assert |accountsList|'s [=list/size=] is greater than 1.
    1. Display an account chooser displaying the options from |accountsList|.
    1. Let |account| be the {{IdentityProviderAccount}} of the account that the user
        manually selects from the accounts chooser, or failure if no account is selected.
    1. Return |account|.
</div>

The <a>request permission to sign-up</a> algorithm fetches the [=client metadata endpoint=] of the [=RP=],
waits for the user to grant permission to use the given account, and returns whether the user
granted permission or not.

<div algorithm>
To <dfn>request permission to sign-up</dfn> the user with a given an {{IdentityProviderAccount}} |account|,
an {{IdentityProviderAPIConfig}} |config|, an {{IdentityProviderRequestOptions}} |provider|, and a
|globalObject|, run the following steps. This returns a boolean.
    1. Assert: These steps are running [=in parallel=].
    1. Let |metadata| be the result of running [=fetch the client metadata=] with |config|,
        |provider|, and |globalObject|.
    1. Prompt the user to gather explicit intent to create an account. The user agent MAY use the
        {{IdentityProviderBranding}} to inform the style choices of its UI. Additionally:
        1. If |metadata| is not failure, |metadata|["{{IdentityProviderClientMetadata/privacy_policy_url}}"]
            is defined and the |provider|'s {{IdentityProviderConfig/clientId}} is not in the list of
            |account|["{{IdentityProviderAccount/approved_clients}}"], then the user agent MUST display
            the |metadata|["{{IdentityProviderClientMetadata/privacy_policy_url}}"] link.
        1. If |metadata| is not failure, |metadata|["{{IdentityProviderClientMetadata/terms_of_service_url}}"]
            is defined, and the |provider|'s {{IdentityProviderConfig/clientId}} is not in the list of
            |account|["{{IdentityProviderAccount/approved_clients}}"], then the user agent MUST display
            the |metadata|["{{IdentityProviderClientMetadata/terms_of_service_url}}"] link.
        1. The user agent MAY use the {{IdentityCredentialRequestOptions/context}} to customize the
            dialog shown.
    1. If the user does not grant permission, return false.
    1. [=Create a connection between the RP and the IdP account=] with |provider|, |account|, and
        |globalObject|.
    1. Return true.
</div>

<div algorithm>
To <dfn noexport>fetch the client metadata</dfn> given an {{IdentityProviderAPIConfig}} |config| and
an {{IdentityProviderRequestOptions}} |provider|, run the following steps. This returns an
{{IdentityProviderClientMetadata}} or failure.
    1. Let |clientMetadataUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|["{{IdentityProviderAPIConfig/client_metadata_endpoint}}"], and |globalObject|.
    1. If |clientMetadataUrl| is failure, return failure.
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |clientMetadataUrl|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: |globalObject|'s [=associated document=]'s [=Document/origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/json`
        :  [=request/credentials mode=]
        :: "omit"
        :  [=request/mode=]
        :: "no-cors"

        Issue: The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
        with [=request/mode=] set to "user-agent-no-cors". See the relevant
        [pull request](https://github.com/whatwg/fetch/pull/1533) for details.

    1. Let |metadata| be null.
    1. [=Fetch request=] with |request| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderClientMetadata}},
            and store the result in |metadata|.
        1. If one of the previous two steps threw an exception, set |metadata| to failure.
    1. Wait until |metadata| is set.
    1. Return |metadata|.
</div>

<xmp class="idl">
dictionary IdentityProviderClientMetadata {
  USVString privacy_policy_url;
  USVString terms_of_service_url;
};
</xmp>

<!-- ============================================================ -->
### Helper algorithms ### {#helper-algorithms}
<!-- ============================================================ -->

The following helper algorithms are used during the FedCM flow.

<div algorithm>
To <dfn>parse url</dfn> given a {{USVString}} |stringUrl|, a |globalObject|, and an optional
|baseUrl| (default null), run the following steps. This returns a [=/URL=] or failure.
    1. Let |configUrl| be null.
    1. [=Queue a global task=] on the [=DOM manipulation task source=] given |globalObject| to set
        |configUrl| to the result of running [=url parser=] with |stringUrl| and |baseUrl|.

        Note: a task is queued since the [=url parser=] needs to be run within a task, not
        [=in parallel=].

    1. Wait for |configUrl| to be set.
    1. Return |configUrl|.
</div>

<div algorithm>
To <dfn>fetch request</dfn> given a [=/request=] |request|, |globalObject|, and an algorithm
|processResponseConsumeBody|, run the following steps:
  1. [=Queue a global task=] on the [=network task source=] given |globalObject| to:
      1. [=Fetch=] |request| with <a spec=fetch>processResponseConsumeBody</a> set to
          |processResponseConsumeBody|.

  Note: a task is queued since the [=fetch=] needs to be run within a task, not [=in parallel=].
</div>

<div algorithm>
When <dfn>computing the manifest URL</dfn> given an {{IdentityProviderRequestOptions}} |provider|, a
[=string=] |manifestString|, and |globalObject|, perform the following steps. This returns a
<a spec=url for=/>URL</a> or failure.
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. Let |manifestUrl| be the result of running [=parse url=] given |manifestString| (the relative
        URL), |globalObject|, and |configUrl| (the base URL).
    1. Wait until |manifestUrl| is set.

        Note: This means that passing the manifest string as either an absolute or relative URL is
        allowed.

    1. If |manifestUrl| is failure, return failure.
    1. If |manifestUrl| is not [=same origin=] with |configUrl|, return failure.
    1. If |manifestUrl| is not a [=potentially trustworthy URL=], return failure.
    1. Return |manifestUrl|.
</div>

<div algorithm>
To <dfn>extract the JSON fetch response</dfn> given a <a spec=fetch for=/>response</a> |response|
and a |responseBody|, run the following steps. This returns an [=ordered map=].
    1. Assert: These steps are running on the [=networking task source=].
    1. If |response| is a [=network error=] or its [=response/status=] is not an [=ok status=],
        throw a new "{{NetworkError}}" {{DOMException}}.
    1. Let |mimeType| be the result of <a>extracting a MIME TYPE</a> from |response|'s
        <a for=response>header list</a>.
    1. If |mimeType| is failure or is not a [=JSON MIME Type=], throw a new "{{NetworkError}}"
        {{DOMException}}.
    1. Let |json| be the result of [=parse JSON bytes to a JavaScript value=] passing |responseBody|.
    1. If |json| is a parsing exception, throw a new "{{NetworkError}}" {{DOMException}}.
    1. Return |json|.
</div>

<div algorithm>
To <dfn>show an IDP login dialog</dfn> given an {{IdentityProviderAPIConfig}} |config|, an
{{IdentityProviderConfig}} |provider|, and a |globalObject|, run the following steps. This returns
success or failure.
    1. Assert: these steps are running [=in parallel=].
    1. Let |loginUrl| be null.
    1. [=Queue a global task=] on the [=DOM manipulation task source=] given |globalObject| to set
        |loginUrl| to the result of running [=url parser=] with
        |config|.{{IdentityProviderAPIConfig/login_url}}.
    1. Wait until |loginUrl| is not null.
    1. Assert: |loginUrl| is not failure (the [=user agent=] has previously checked that
        |config|.{{IdentityProviderAPIConfig/login_url}} is a valid URL).
    1. Let |queryList| be a new [=list=].
    1. If |provider|'s {{IdentityProviderRequestOptions/loginHint}} is not empty, [=list/append=]
        ("login_hint", {{IdentityProviderRequestOptions/loginHint}}) to |queryList|.
    1. If |provider|'s {{IdentityProviderRequestOptions/domainHint}} is not empty, [=list/append=]
        ("domain_hint", {{IdentityProviderRequestOptions/domainHint}}) to |queryList|.
    1. If |queryList| is not [=list/empty=]:
        1. Let |queryParameters| be the result of the [=urlencoded serializer=] with |queryList|.
        1. If |loginUrl|'s [=url/query=] is not null or empty, prepend "&" to |queryParameters|.
        1. Append |queryParameters| to |loginUrl|'s [=url/query=].
    1. [=Create a fresh top-level traversable=] with |loginUrl|.
    1. The user agent MAY [=set up browsing context features=] or otherwise
        affect the presentation of this traversable in an implementation-defined
        way.
    1. Wait for one of the following conditions:
        * The user closes the browsing context: return failure.
        * {{IdentityProvider}}.{{IdentityProvider/close}} is called in the
            context of this new traversable:
            1. Close the traversable.
            1. Let |loginStatus| be the result of [=get the login status=]
                with the [=/origin=] of the {{IdentityProviderAPIConfig/login_url}}.

                Note: The IDP login flow may set this value to logged-in using
                    either the [login-status.html#login-status-javascript](JavaScript) or
                    [login-status.html#login-status-http](HTTP header) API during the login
                    flow. It is also possible that this change happened in
                    a different browsing context.
            1. If |loginStatus| is [=logged-in=], return success.
            1. Otherwise, return failure.
</div>

<!-- ============================================================ -->
## The IdentityProvider Interface ## {#browser-api-identity-provider-interface}
<!-- ============================================================ -->

This specification introduces the {{IdentityUserInfo}} dictionary as well as the
{{IdentityProvider}} interface:

<pre class="idl">
  dictionary IdentityUserInfo {
    USVString email;
    USVString name;
    USVString givenName;
    USVString picture;
  };

  [Exposed=Window, SecureContext] interface IdentityProvider {
      static undefined close();
      static Promise&lt;sequence&lt;IdentityUserInfo&gt;&gt; getUserInfo(IdentityProviderConfig config);
  };
</pre>

Issue: [Decide](https://github.com/fedidcg/FedCM/issues/476) whether {{IdentityProvider}} is the
correct location for the {{IdentityProvider/getUserInfo()}} method.

A {{IdentityProvider/close}} function is provided to signal to the browser that
the login flow is finished. The reason for this function in addition to the
header is that even when the user is already logged in, the login flow may not
be finished yet; for example, an [=IDP=] may want to prompt the user to verify
their phone number. To allow for such flows, the [=IDP=] must call
{{IdentityProvider/close}} when the flow is fully done.

See the [=show an IDP login dialog=] algorithm for more details.

An {{IdentityUserInfo}} represents user account information from a user. This information is exposed
to the [=IDP=] once the user has already used the FedCM API to login in the [=RP=]. That is, it is
exposed when there exists an account |account| such that the [=connected accounts set=] [=list/contains=]
the triple ([=RP=], [=IDP=], |account|). The information matches what is received from the
<a>accounts endpoint</a>. The [=IDP=] can obtain this information by invoking the
{{IdentityProvider/getUserInfo()}} static method from an iframe matching the [=/origin=] of its
{{IdentityProviderConfig/configURL}}.

<div class="example">
```js
const userInfo = await IdentityProvider.getUserInfo({
    configUrl: "https://idp.example/fedcm.json",
    clientId: "client1234"
});

if (userInfo.length > 0) {
  // It's up to the IDP regarding how to display the returned accounts.
  const name = userInfo[0].name;
  const givenName = userInfo[0].givenName;
  const displayName = givenName ? givenName : name;
  const picture = userInfo[0].picture;
  const email = userInfo[0].email;
}
```
</div>

<div algorithm="getUserInfo">
When invoking the {{IdentityProvider/getUserInfo()}} method given an {{IdentityProviderConfig}}
|provider|, perform the following steps:

    1. Let |globalObject| be the [=current global object=].
    1. Let |document| be |globalObject|'s [=associated Document=].
    1. If |document| is not [=allowed to use=] the [=identity-credentials-get=]
        [=policy-controlled feature=], throw a "{{NotAllowedError}}" {{DOMException}}.
    1. If there does not exist an account |account| such that [=connected accounts set=]
        [=list/contains=] the result of [=compute the connected account key=] given |account|,
        |provider|, and |globalObject|, then [=reject=] |promise| with a "{{NetworkError}}"
        {{DOMException}}. This check can be performed by iterating over the
        [=connected accounts set=] or by keeping a separate data structure to make this lookup fast.
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. If |configUrl| is failure, throw an "{{InvalidStateError}}" {{DOMException}}.
    1. If |document|'s [=Document/origin=] is not [=same origin=] as |configUrl|'s [=url/origin=],
        throw an "{{InvalidStateError}}" {{DOMException}}.
    1. Run a [[!CSP]] check with a [[CSP#directive-connect-src|connect-src]] directive on the URL
        passed as |configUrl|. If it fails, throw a new "{{NetworkError}}" {{DOMException}}.
    1. If |globalObject|'s [=Window/navigable=] is a [=/top-level traversable=], throw a new
        "{{NetworkError}}" {{DOMException}}.
    1. If the user has disabled the FedCM API on the |globalObject|'s [=Window/navigable=]'s
        [=navigable/top-level traversable=], throw a new "{{NetworkError}}" {{DOMException}}.
    1. Let |promise| be a new {{Promise}}.
    1. Perform the following steps [=in parallel=]:
        1. Let |config| be the result of running [=fetch the config file=] with |provider| and
            |globalObject|.
        1. If |config| is failure, [=reject=] |promise| with a new "{{NetworkError}}"
            {{DOMException}}.
        1. Let |accountsList| be the result of [=fetch the accounts=] with |config|, |provider|,
            and |globalObject|.
        1. Let |isEligibleForAutoReauthentication| be a new [=list=] of the same length as |accountsList|,
            with all values initially set to false.
        1. For each |i| from 0 to the length of |accountsList| minus 1:
            1. Let |account| be |accountsList|[|i|].
            1. If |account|["{{IdentityProviderAccount/approved_clients}}"] is not empty and it does not
                [=list/contain=] |provider|'s {{IdentityProviderConfig/clientId}}, continue.

                Note: this allows the [=IDP=] to override whether an account is a returning account.
                This could be useful for instance in cases where the user has disconnected the
                account out of band.

            1. [=Compute the connection status=] of |provider|, |account|, and |globalObject|. If the
                result is [=compute the connection status/connected=], set
                |isEligibleForAutoReauthentication|[|i|] to true.
        1. If |isEligibleForAutoReauthentication| does not [=list/contain=] true, [=reject=] |promise| with
            a new "{{NetworkError}}" {{DOMException}}.
        1. Let |userInfoList| be a new [=list=].
        1. Let |notReturningUserInfos| be a new [=list=].
        1. For each |i| from 0 to the length of |accountsList| minus 1:
            1. Let |account| be |accountsList|[|i|].
            1. Let |userInfo| be an {{IdentityUserInfo}} with the following values:

                :  {{IdentityUserInfo/email}}
                :: |account|["{{IdentityProviderAccount/email}}"]   
                :  {{IdentityUserInfo/name}}
                :: |account|["{{IdentityProviderAccount/name}}"]   
                :  {{IdentityUserInfo/givenName}}
                :: |account|["{{IdentityProviderAccount/given_name}}"]   
                :  {{IdentityUserInfo/picture}}
                :: |account|["{{IdentityProviderAccount/picture}}"]
            1. If |isEligibleForAutoReauthentication|[|i|], [=list/append=] |userInfo| to |userInfoList|.
            1. Otherwise, [=list/append=] |userInfo| to |notReturningUserInfos|.
        1. [=list/Extend=] |userInfo| with |notReturningUserInfos|.
        1. [=Resolve=] a new {{Promise}} with |userInfoList|.
</div>

<!-- ============================================================ -->
# Identity Provider HTTP API # {#idp-api}
<!-- ============================================================ -->

<em>This section is non-normative.</em>

The [=IDP=] exposes a series of HTTP endpoints:

1. [[#idp-api-well-known]] that points to a Manifest
1. A [[#idp-api-config-file]] in an agreed upon location that points to
1. An [[#idp-api-accounts-endpoint]] endpoint
1. A [[#idp-api-client-id-metadata-endpoint]] endpoint
1. An [[#idp-api-id-assertion-endpoint]] endpoint
1. An [[#idp-api-disconnect-endpoint]] endpoint if it supports {{IdentityCredential/disconnect}}.

The FedCM API introduces the ability for a site to ask the browser to execute a few different
network requests. It is important for the browser
to execute these in such a way that it does not allow the user to be tracked (by an attacker
impersonating an [=IDP=]) on to the site using FedCM. The following table has information about the
network requests performed:

<table>
  <tr><td>Endpoint</td><td>cookies</td><td>client_id</td><td>origin</td></tr>
  <tr><td>manifests</td><td>no</td><td>no</td><td>no</td></tr>
  <tr><td>accounts_endpoint</td><td>yes</td><td>no</td><td>no</td></tr>
  <tr><td>client_metadata_endpoint</td><td>no</td><td>yes</td><td>yes</td></tr>
  <tr><td>id_assertion_endpoint</td><td>yes</td><td>yes</td><td>yes</td></tr>
  <tr><td>disconnect_endpoint</td><td>yes</td><td>yes</td><td>yes</td></tr>
</table>

<!-- ============================================================ -->
## The Well-Known File ## {#idp-api-well-known}
<!-- ============================================================ -->

NOTE: The browser uses the [=well-known file=] to prevent [[#manifest-fingerprinting]].

The [=IDP=] exposes a <dfn>well-known file</dfn> in a pre-defined location, specifically at the "web-identity" file at the [=IDPs=]'s path ".well-known".

The [=well-known file=] is fetched in the [=fetch the config file=] algorithm:

(a) **without** cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`, and
(c) **without** revealing the [=RP=] in the <a http-header>Origin</a> or
    [[RFC9110#field.referer|Referer]] headers.

For example:

<div class=example>
```http
GET /.well-known/web-identity HTTP/1.1
Host: idp.example
Accept: application/json
Sec-Fetch-Dest: webidentity
```
</div>

The file is parsed expecting a {{IdentityProviderWellKnown}} JSON object.

The {{IdentityProviderWellKnown}} JSON object has the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderWellKnown">
    :   <dfn>provider_urls</dfn> (required)
    ::  A list of URLs that points to valid [[#idp-api-config-file]]s.
</dl>

<!-- ============================================================ -->
## The config file ## {#idp-api-config-file}
<!-- ============================================================ -->

The <dfn>config file</dfn> serves as a discovery device to other endpoints provided by the
[=IDP=].

The [=config file=] is fetched in the [=fetch the config file=] algorithm:

(a) **without** cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(c) **without** revealing the [=RP=] in the <a http-header>Origin</a> or
    [[RFC9110#field.referer|Referer]] headers, and
(d) **without** following [[RFC9110#field.location|HTTP redirects]].

For example:

<div class=example>
```http
GET /config.json HTTP/1.1
Host: idp.example
Accept: application/json
Sec-Fetch-Dest: webidentity
```
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderAPIConfig}} without an exception.

The {{IdentityProviderAPIConfig}} object's members have the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderAPIConfig">
    :   <dfn>accounts_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-accounts-endpoint]] API.
    :   <dfn>client_metadata_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-client-id-metadata-endpoint]] API.
    :   <dfn>id_assertion_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-id-assertion-endpoint]] API.
    :   <dfn>disconnect_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-disconnect-endpoint]]
        API.
    :   <dfn>branding</dfn>
    ::  A set of {{IdentityProviderBranding}} options.
</dl>

The {{IdentityProviderBranding}} enables an [=IDP=] to express their branding
preferences, which may be used by [=user agents=] to customize the permission prompt.

Note: The branding preferences are deliberately designed to be high level
/ abstract (rather than opinionated about a specific UI structure), to
enable different [=user agents=] to offer different UI experiences and
for them to evolve independently over time.

Its members have the following semantics:
<dl dfn-type="dict-member" dfn-for="IdentityProviderBranding">
    :   <dfn>background_color</dfn>
    ::  Background [=color=] for [=IDP=]-branded widgets such as buttons.
    :   <dfn>color</dfn>
    ::  [=color=] for text on [=IDP=] branded widgets.
    :   <dfn>icons</dfn>
    ::  A list of {{IdentityProviderIcon}} objects.
    :   <dfn>name</dfn>
    ::  A user-recognizable name for the [=IDP=].
</dl>

Note: The branding preferences are deliberately designed to be high level
/ abstract (rather than opinionated about a specific UI structure), to
enable different [=user agents=] to offer different UI experiences and
for them to evolve independently over time.


The {{IdentityProviderIcon}} has members with the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderIcon">
    :   <dfn>url</dfn>
    ::  The url pointing to the icon image, which must be square and single resolution
        (not a multi-resolution .ico). The icon needs to comply with the
        [maskable](https://www.w3.org/TR/appmanifest/#icon-masks) specification.
    :   <dfn>size</dfn>
    ::  The width/height of the square icon. The size may be omitted if the icon is in a vector
        graphic format (like SVG).
</dl>

Note: the [=user agent=] reserves a square size for the icons provided by the developer. If the
developer provides an icon that is not square, the [=user agent=] may choose to not display it at
all, trim the icon and show a square portion of it, or even transform it into a square icon and show
that.

The <dfn>color</dfn> is a subset of CSS <<color>> syntax, namely <<hex-color>>s, ''hsl()''s, ''rgb()''s and <<named-color>>.

For example:

<div class=example>
```json
{
  "accounts_endpoint": "/accounts",
  "client_metadata_endpoint": "/metadata",
  "id_assertion_endpoint": "/assertion",
  "disconnect_endpoint": "/disconnect",
  "branding": {
    "background_color": "green",
    "color": "#FFEEAA",
    "icons": [{
      "url": "https://idp.example/icon.ico",
      "size": 25
    }],
    "name": "IDP Example"
  }
}
```
</div>

<!-- ============================================================ -->
## Accounts endpoint ## {#idp-api-accounts-endpoint}
<!-- ============================================================ -->

The <dfn>accounts endpoint</dfn> provides the list of accounts the user has at the [=IDP=].

The [=accounts endpoint=] is fetched in the [=fetch the accounts=] algorithm:

(a) **with** [=IDP=] cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(c) **without** revealing the [=RP=] in the <a http-header>Origin</a> or
    [[RFC9110#field.referer|Referer]] headers, and
(d) **without** following [[RFC9110#field.location|HTTP redirects]].

For example:

<div class=example>
```http
GET /accounts_list HTTP/1.1
Host: idp.example
Accept: application/json
Cookie: 0x23223
Sec-Fetch-Dest: webidentity
```
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderAccountList}} without an exception.

Every {{IdentityProviderAccount}} is expected to have members with the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderAccount">
    :   <dfn>id</dfn>
    ::  The account unique identifier.
    :   <dfn>name</dfn>
    ::  The user's full name.
    :   <dfn>email</dfn>
    ::  The user's email address.
    :   <dfn>given_name</dfn>
    ::  The user's given name.
    :   <dfn>picture</dfn>
    ::  URL for the account's picture.
    :   <dfn>approved_clients</dfn>
    ::  A list of [=RP=]s (that gets matched against the requesting {{IdentityProviderConfig/clientId}}) this account is already registered with.
        Used in the [=request permission to sign-up=] to allow the [=IDP=] to control whether to show
        the Privacy Policy and the Terms of Service.
    :   <dfn>login_hints</dfn>
    ::  A list of strings which correspond to all of the login hints which match with this account.
        An [=RP=] can use the {{IdentityProviderRequestOptions/loginHint}} to request that only an account
        matching a given value is shown to the user.
    :   <dfn>domain_hints</dfn>
    ::  A list of strings which correspond to all of the domain hints which match with this account.
        An [=RP=] can use the {{IdentityProviderRequestOptions/domainHint}} to request that only an account
        matching a given value or containing some domain hint is shown to the user.
</dl>

For example:

<div class=example>
```json
{
 "accounts": [{
   "id": "1234",
   "given_name": "John",
   "name": "John Doe",
   "email": "john_doe@idp.example",
   "picture": "https://idp.example/profile/123",
   "approved_clients": ["123", "456", "789"],
   "login_hints": ["john_doe"],
   "domain_hints": ["idp.example"],
  }, {
   "id": "5678",
   "given_name": "Johnny",
   "name": "Johnny",
   "email": "johnny@idp.example",
   "picture": "https://idp.example/profile/456",
   "approved_clients": ["abc", "def", "ghi"],
   "login_hints": ["email=johhny@idp.example", "id=5678"],
   "domain_hints": ["idp.example"],
  }]
}
```
</div>

Issue: [Clarify](https://github.com/fedidcg/FedCM/issues/218) the IDP API response when the user is not signed in.

<!-- ============================================================ -->
## Client Metadata ## {#idp-api-client-id-metadata-endpoint}
<!-- ============================================================ -->

The <dfn>client metadata endpoint</dfn> provides metadata about [=RP=]s.

The [=client metadata endpoint=] is fetched in the [=fetch the client metadata=] algorithm:

(a) **without** cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(c) **with** the [=RP=]'s origin in the <a http-header>Origin</a> header, and
(d) **without** following [[RFC9110#field.location|HTTP redirects]].

The user agent also passes the **client_id**.

For example:

<div class=example>
```http
GET /client_medata?client_id=1234 HTTP/1.1
Host: idp.example
Origin: https://rp.example/
Accept: application/json
Sec-Fetch-Dest: webidentity
```
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderClientMetadata}} without an exception.

The {{IdentityProviderClientMetadata}} object's members have the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderClientMetadata">
    :   <dfn>privacy_policy_url</dfn>
    ::  A link to the [=RP=]'s Privacy Policy.
    :   <dfn>terms_of_service_url</dfn>
    ::  A link to the [=RP=]'s Terms of Service.
</dl>

For example:

<div class=example>
```json
{
  "privacy_policy_url": "https://rp.example/clientmetadata/privacy_policy.html",
  "terms_of_service_url": "https://rp.example/clientmetadata/terms_of_service.html"
}
```
</div>

<!-- ============================================================ -->
## Identity assertion endpoint ## {#idp-api-id-assertion-endpoint}
<!-- ============================================================ -->

The <dfn>identity assertion endpoint</dfn> is responsible for minting a new token that contains signed assertions about the user.

The [=identity assertion endpoint=] is fetched in the [=fetch an identity assertion=] algorithm:

(a) as a **POST** request,
(b) **with** [=IDP=] cookies,
(c) **with** the [=RP=]'s origin in the <a http-header>Origin</a> header, and
(d) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(e) **without** following [[RFC9110#field.location|HTTP redirects]].

It will also contain the following parameters in the request body `application/x-www-form-urlencoded`:

<dl dfn-type="argument" dfn-for="id_assertion_endpoint_request">
    :   <dfn>client_id</dfn>
    ::  The [=RP=]'s unique identifier from the [=IDP=]
    :   <dfn>nonce</dfn>
    ::  The request nonce
    :   <dfn>account_id</dfn>
    ::  The account identifier that was selected.
    :   <dfn>disclosure_text_shown</dfn>
    ::  Whether the user agent has explicitly shown to the user what specific information the
        [=IDP=] intends to share with the [=RP=] (e.g. "idp.example will share your name, email...
        with rp.example"), used by the [=request permission to sign-up=] algorithm for new users. It
        is used as an assurance by the user agent to the [=IDP=] that it has indeed shown the terms
        of service and privacy policy to the user in the cases where it is required to do so.
</dl>

For example:

<div class=example>
```http
POST /fedcm_assertion_endpoint HTTP/1.1
Host: idp.example
Origin: https://rp.example/
Content-Type: application/x-www-form-urlencoded
Cookie: 0x23223
Sec-Fetch-Dest: webidentity
account_id=123&client_id=client1234&nonce=Ct60bD&disclosure_text_shown=true
```
</div>

<div class=idp-normative-text>
An [=IDP=] MUST check the <a http-header>Origin</a> header to ensure that a malicious [=RP=] does
not receive an ID token corresponding to another [=RP=]. In other words, the [=IDP=] MUST check that
the <a http-header>Origin</a> header value is represented by the
{{IdentityProviderConfig/clientId}}. As the {{IdentityProviderConfig/clientId}} are
[=IDP=]-specific, the [=user agent=] cannot perform this check.
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderToken}} without an exception.

Every {{IdentityProviderToken}} is expected to have members with the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderToken">
    :   <dfn>token</dfn>
    ::  The resulting token.
</dl>

The content of the {{IdentityProviderToken/token}} is opaque to the user agent and can contain
anything that the [=IDP=] would like to pass to the
[=RP=] to facilitate the login. For this reason the [=RP=]
is expected to be the party responsible for validating the {{IdentityProviderToken/token}} passed
along from the [=IDP=] using the appropriate token validation
algorithms defined. One example of how this might be done is defined
in [[OIDC-Connect-Core#IDTokenValidation]].

NOTE: For [=IDPs=], it is worth considering how
[portable](https://github.com/fedidcg/FedCM/issues/314) accounts are.
Portability is left entirely up to [=IDPs=], who can choose
between a variety of different mechanisms to accomplish it
(e.g. [OIDC's Account Porting](https://openid.net/specs/openid-connect-account-porting-1_0.html)).

For example:

<div class=example>
```json
{
  "token" : "eyJC...J9.eyJzdWTE2...MjM5MDIyfQ.SflV_adQssw....5c"
}
```
</div>

<!-- ============================================================ -->
## Disconnect endpoint ## {#idp-api-disconnect-endpoint}
<!-- ============================================================ -->

The <dfn>disconnect endpoint</dfn> is responsible for disconnecting a previously made federated
login connection between an [=RP=] and an [=IDP=] account, and returning the account's
{{IdentityProviderAccount/id}} so that the [=user agent=] can remove it from the
[=connected accounts set=].

The [=disconnect endpoint=] is fetched when invoking the {{IdentityCredential/disconnect}}
method:

(a) as a **POST** request,
(b) **with** [=IDP=] cookies,
(c) **with** the [=RP=]'s origin in the <a http-header>Origin</a> header,
(d) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(e) **without** following [[RFC9110#field.location|HTTP redirects]], and
(f) in "cors" [=request/mode=].

It will also contain the following in the request body `application/x-www-form-urlencoded`:

<dl dfn-type="argument" dfn-for="disconnect_endpoint_request">
    :   <dfn>client_id</dfn>
    ::  The [=RP=]'s unique identifier from the [=IDP=]
    :   <dfn>account_hint</dfn>
    ::  An account hint for the [=IDP=] account being disconnected from the [=RP=].
</dl>

For example:

<div class=example>
```http
POST /fedcm_disconnect_endpoint HTTP/1.1
Host: idp.example
Origin: https://rp.example/
Content-Type: application/x-www-form-urlencoded
Cookie: 0x23223
Sec-Fetch-Dest: webidentity
client_id=client1234&account_hint=hint12
```
</div>

If the disconnection is unsuccessful, the [=IDP=] may respond with an error. If it is successful,
the response body must be a JSON object that can be [=converted to an IDL value|converted=] to an
{{DisconnectedAccount}} without an exception.

<dl dfn-type="dict-member" dfn-for="DisconnectedAccount">
    :   <dfn>account_id</dfn>
    ::  The {{IdentityProviderAccount/id}} of the account that was successfully disconnected.
</dl>

The [=IDP=] must return the {{DisconnectedAccount/account_id}} since it may be different from the
{{disconnect_endpoint_request/account_hint}}, and the ID is the one which allows the [=user agent=]
to disconnect the account from the [=connected accounts set=]. If the [=IDP=] returns an error or
the [=user agent=] does not find the account with the ID provided by the [=IDP=], then all accounts
associated with the relevant ([=RP=], [=IDP=]) are removed from the [=connected accounts set=].

<!-- ============================================================ -->
# Permissions Policy Integration # {#permissions-policy-integration}
<!-- ============================================================ -->

FedCM defines a [=policy-controlled feature=] identified by the string <code>"<dfn export>identity-credentials-get</dfn>"</code>.
Its [=default allowlist=] is `"self"`.

A {{Document}}’s [=Document/permissions policy=] determines whether any content
in that document is allowed to obtain a credential object using the [[#browser-api|Browser API]].
Attempting to invoke <code><a idl for="CredentialsContainer" lt="get()">navigator.credentials.get({identity:..., ...})</a></code>
in documents that are not [=allowed to use=] the [=identity-credentials-get=] feature will result
in [=a promise rejected with=] a "{{NotAllowedError}}" {{DOMException}}.

This restriction can be controlled using the mechanisms described in [[PERMISSIONS-POLICY]].

Note: Algorithms specified in [[!CREDENTIAL-MANAGEMENT-1]] perform the actual
permissions policy evaluation. This is because such policy evaluation needs to
occur when there is access to the [=current settings object=]. The [=internal method=]s
modified by this specification do not have such access since they are invoked [=in parallel=]
by {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a> abstract operation.

<!-- ============================================================ -->
# User Agent Automation # {#automation}
<!-- ============================================================ -->

For the purposes of user agent automation and website testing, this document
defines the below [[WebDriver2]] [=extension commands=] to interact with any
active FedCM dialogs.

## Extension capability ## {#webdriver-capability}

In order to advertise the availability of the [=extension commands=] defined below, a new [=extension capability=] is defined.

<figure id="table-fedcmWebdriverCapability" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>Capability</th>
                <th>Key</th>
                <th>Value Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Federated Credential Management Support</td>
                <td>`"fedcm:accounts"`</td>
                <td>boolean</td>
                <td>Indicates whether the [=endpoint node=] supports all Federated Credential Management commands.</td>
            </tr>
        </tbody>
    </table>
</figure>

When [=validating capabilities=], the extension-specific substeps to validate `"fedcm:accounts"` with `value` are the following:

    1. If `value` is not a [=boolean=] return a [=error|WebDriver Error=] with [=error code=] [=invalid argument=].
    2. Otherwise, let `deserialized` be set to `value`.

When [=matching capabilities=], the extension-specific steps to match `"fedcm:accounts"` with `value` are the following:

    1. If `value` is [TRUE] and the [=endpoint node=] does not support any of the Federated Credential Management commands,
        the match is unsuccessful.
    2. Otherwise, the match is successful.

## Cancel dialog ## {#webdriver-canceldialog}

<figure id="table-webdriver-canceldialog" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/fedcm/canceldialog`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If no FedCM dialog is currently open, return a [=error|WebDriver error=] with
    [=error code=] [=no such alert=].

1. Close the dialog and continue the [=create an IdentityCredential=] algorithm
    as if the user had canceled the dialog without choosing an account.

1. Return [=success=] with data `null`.

## Select account ## {#webdriver-selectaccount}

<figure id="table-webdriver-selectaccount" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/fedcm/selectaccount`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If |parameters| is not a JSON [[ECMASCRIPT#sec-json-object|Object]], return a
    [=error|WebDriver error=] with [=error code=] [=invalid argument=].

1. If no FedCM dialog is currently open, return a [=error|WebDriver error=] with
    [=error code=] [=no such alert=].

1. Let |accountIndex| be the result of [=getting a property=] named `"accountIndex"`
    from |parameters|.

1. If |accountIndex| is {{undefined}} or is less than 0 or greater than or
    equal to the number of accounts that the user can choose from in the
    current flow, return a [=error|WebDriver error=] with [=error code=]
    [=invalid argument=].

1. Close the dialog and continue the [=create an IdentityCredential=] algorithm
    as if the user had selected the account indicated by |accountIndex| and
    [=request permission to sign-up|granted permission to sign-up=], if applicable.

1. Return [=success=] with data `null`.

## Click dialog button ## {#webdriver-clickdialogbutton}

<figure id="table-webdriver-clickdialogbutton" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/fedcm/clickdialogbutton`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If |parameters| is not a JSON [[ECMASCRIPT#sec-json-object|Object]], return a
    [=error|WebDriver error=] with [=error code=] [=invalid argument=].

1. Let |dialogButton| be the result of [=getting a property=] named
    `"dialogButton"` from |parameters|.

1. If |dialogButton| is not a string that is "`ConfirmIdpLoginContinue`", return
    a [=error|WebDriver error=] with [=error code=] [=invalid argument=].

1. If no FedCM dialog is currently open or the dialog is not a [=confirm IDP
    login dialog=], return a [=error|WebDriver error=] with [=error code=] [=no
    such alert=].

1. Act as if the user had clicked the "continue" button in the [=confirm IDP
    login dialog=] and initiate the login flow.

1. Return [=success=] with data `null`.

## Account list ## {#webdriver-accountlist}

<figure id="table-webdriver-accountlist" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>GET</td>
                <td>`/session/{session id}/fedcm/accountlist`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If no FedCM dialog is currently open, return a [=error|WebDriver error=] with
    [=error code=] [=no such alert=].

1. Let |accounts| be the list of accounts that the user can or could choose
    from in the current flow.

1. Let |list| be an empty list.

1. For each |account| in |accounts|:
    1. Let |accountState| be the result of running the [=compute the connection status=]
        algorithm given |account| and the {{IdentityProviderRequestOptions}} of the IDP
        |account| belongs to
    1. [=list/Append=] a [=dictionary=] to |list| with the following properties:
        1. `accountId` set to the account's {{IdentityProviderAccount/id}}
        1. `email` set to the account's {{IdentityProviderAccount/email}}
        1. `name` set to the account's {{IdentityProviderAccount/name}}
        1. `givenName` set to the account's {{IdentityProviderAccount/given_name}},
            if present
        1. `pictureUrl` set to the account's {{IdentityProviderAccount/picture}},
            if present
        1. `idpConfigUrl` set to the {{IdentityProviderConfig/configURL}} of the
            IDP this account belongs to
        1. `loginState` to `"SignUp"` if |accountState| is
            [=compute the connection status/disconnected=] and `"SignIn"` otherwise
        1. `termsOfServiceUrl` to the {{IdentityProviderClientMetadata/terms_of_service_url}}
            if one was provided and the `loginState` is `"SignUp"`, otherwise {{undefined}}
        1. `privacyPolicyUrl` to the {{IdentityProviderClientMetadata/privacy_policy_url}}
            if one was provided and the `loginState` is `"SignUp"`, otherwise {{undefined}}

1. Return [=success=] with data |list|.

## Get title ## {#webdriver-gettitle}

<figure id="table-webdriver-gettitle" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>GET</td>
                <td>`/session/{session id}/fedcm/gettitle`</td>
            </tr>
        </tbody>
    </table>
</figure>

Note: This command lets automation verify that the
  [context api](#dom-identitycredentialrequestoptions-context)
     was applied properly

The [=remote end steps=] are:

1. If no FedCM dialog is currently open, return a [=error|WebDriver error=] with
    [=error code=] [=no such alert=].

1. Let |data| be a dictionary with an object with properties as follows:
    1. `title` set to the title of the open dialog
    1. `subtitle` set to the subtitle of the open dialog, if there is one

1. Return [=success=] with data |data|.

## Get dialog type ## {#webdriver-getdialogtype}

<figure id="table-webdriver-getdialogtype" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>GET</td>
                <td>`/session/{session id}/fedcm/getdialogtype`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If no FedCM dialog is currently open, return a [=error|WebDriver error=] with
    [=error code=] [=no such alert=].

1. Let |type| be a string that is "`AutoReauthn`" if the user is being [=auto-reauthenticated=],
    or "`AccountChooser`" if the dialog is an account chooser, or "`ConfirmIdpLogin`" if the
    dialog is a [=confirm IDP login dialog=].

1. Return [=success=] with data |type|.

## Set delay enabled ## {#webdriver-setdelayenabled}

<figure id="table-webdriver-setdelayenabled" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/fedcm/`<dfn>`setdelayenabled`</dfn></td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If |parameters| is not a JSON [[ECMASCRIPT#sec-json-object|Object]], return a
     [=error|WebDriver error=] with [=error code=] [=invalid argument=].

1. Let |enabled| be the result of [=getting a property=] named `"enabled"` from
    |parameters|.

1. If |enabled| is {{undefined}} or is not a boolean, return a [=error|WebDriver error=]
    with [=error code=] [=invalid argument=].

1. If |enabled| is false, disables the [=promise rejection delay=]; otherwise,
    re-enables it.

1. Return [=success=] with data `null`.

## Reset cooldown ## {#webdriver-resetcooldown}

<figure id="table-webdriver-resetcooldown" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/fedcm/resetcooldown`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If the user agent uses a cooldown delay, which disables the API for an
    amount of time after the user dismissed the dialog, then this command
    resets that cooldown such that the next FedCM call can succeed again.

1. Return [=success=] with data `null`.

<!-- ============================================================ -->
# Security # {#security}
<!-- ============================================================ -->

This section provides a few of the security considerations for the FedCM API. Note that there is a
separate section for [[#privacy]] considerations.

<!-- ============================================================ -->
## Content Security Policy ## {#content-security-policy}
<!-- ============================================================ -->

The first fetches triggered by the FedCM API are the manifest list, which is public, and the
[=config file=]. Imagine a malicious script included by (and running as) the [=RP=] attempting to
execute the FedCM API calls to a malicious [=IDP=], one which is not trusted by the [=RP=]. If the
call is successful, this would introduce browser UI on the [=RP=] with sign in options into a
malicious [=IDP=]. This malicious[=IDP=] could then attempt to trick the user. The protection
against this attack is the [[!CSP]] check, which would fail because the origin of the manifest of
the malicious [=IDP=] would not be an origin included in the allowlist specified by the [[!CSP]] of
the [=RP=], hence preventing the undesired FedCM UI from being shown. Since any subsequent fetches
are same origin with respect to the [=config file=] or at least dependent on the contents of the
[=config file=], they do not require additional checks.

The non-same-origin fetches include, for example, the brand icon. The user agent does not perform a
[[!CSP]] check on these because they are directly specified from the manifest. In addition, the
rendering of this image is performed by the user agent, and as such this image cannot affect the
[=RP=] site nor can they be inspected by the [=RP=] in any way.

<!-- ============================================================ -->
## Sec-Fetch-Dest Header ## {#sec-fetch-dest-header}
<!-- ============================================================ -->

The FedCM API introduces several non-static endpoints on the [=IDP=], so these need to be protected
from XSS attacks. In order to do so, the FedCM API introduces a new value for the
<a http-header>Sec-Fetch-Dest</a> header, a [=forbidden request-header=]. The requests initiated by the FedCM API
have a `webidentity` value for this header. The value cannot be set by random websites, so the
[=IDP=] can be confident that the request was originated by the FedCM browser rather than sent by a
websites trying to run an XSS attack. An [=IDP=] needs to check for this header's value in the
credentialed requests it receives, which ensures that the request was initiated by the user agent,
based on the FedCM API. A malicious actor cannot spam FedCM API calls, so this is sufficient
protection for the new [=IDP=] endpoints.

<!-- ============================================================ -->
## CORS Header ## {#sec-cors-header}
<!-- ============================================================ -->

The FedCM API allows the response from the [=identity assertion endpoint=] to be shared to the
[=RP=]. Because of this, we impose the requirement that the [=IDP=] explicitly consents to this
sharing taking place by using the "cors" [=request/mode=] when fetching this endpoint. This also
helps with servers that may accidentally ignore the <a http-header>Sec-Fetch-Dest</a>: they cannot
ignore CORS, as without it the fetch will fail.

<!-- ============================================================ -->
## Browser Surface Impersonation ## {#browser-surface-impersonation}
<!-- ============================================================ -->

The FedCM API introduces new (trusted) user agent UI, and the user agent may choose to show the UI
entirely on top of the page's contents, if anything because the page was the one responsible for
this UI. This introduces a potential concern of a malicious site to try to replicate the FedCM UI,
gain the user's trust that the user is interacting with a trusted browser surface, and gather
information from the user that they would only give to the browser rather than the site (e.g.
usernames/passwords of **another** site). This would be hard to achieve because the FedCM UI uses
metadata about the user accounts of the [=IDP=], which the malicious website doesn't have access to.
If this is a malicious site, it would not know the user accounts unless the user is already
compromised. However, the site could have some guess of the user identity, so the browser is
encouraged to provide UI that is hard to replicate and that clearly presents the domains of the
parties involved in the website's FedCM call. Overall, an attacker trying to impersonate the browser
using exclusively UI that is accessible to the content area (e.g. iframes) to attempt to retrieve
sensitive information from the user would be noticeably different from the FedCM UI. Finally,
because the FedCM UI can only be queried from the top-level frame (or potentially from an iframe
with explicit permission from the top-level frame), the priviledged UI surface is only shown when
the top-level frame wants it so. A sneaky iframe cannot force the FedCM UI to occlude important
content from the main page.

<!-- ============================================================ -->
# Privacy # {#privacy}
<!-- ============================================================ -->

This section is intended to provide a comprehensive overview of the privacy risks associated with
federated identity on the web for the purpose of measuring the privacy risks and benefits of
proposed browser intermediation designs.

<!-- ============================================================ -->
## Principals ## {#privacy-principals}
<!-- ============================================================ -->

This section describes the four principals that would participate in an invocation of the API and
expectations around their behavior.

1. The [=user agent=] implements [[#browser-api]] and controls the execution contexts for the [=RP=]
    and [=IDP=] content. The [=user agent=] is assumed to be trusted by the user, and transitively
    trusted by the [=RP=] and [=IDP=].
1. [=RP=]s are websites that invoke the FedCM API for the purpose of
    authenticating a user to their account or for requesting information about that user. Since any
    site can invoke the API, [=RP=]s cannot necessarily be trusted to limit the user information it
    collects or use that information in an acceptable way.
1. [=IDP=]s are third-party websites that are the target of a FedCM call to
    attempt to fetch a token. Usually,the [=IDP=] has a higher level of trust than the
    [=RP=] since it already has the user’s personal information, but it is possible that the [=IDP=]
    might use the user’s information in non-approved ways. In addition, it is possible that the
    [=IDP=] specified in the API call may not be an [=IDP=] the user knows about. In this case, it
    likely does not have personal user information in advance.
1. A <dfn>tracker</dfn> is a third-party website that is not an [=IDP=] but could abuse the FedCM API
    exclusively for the purpose of tracking a user as they visit various websites. A [=tracker=] may
    be injected by the [=RP=] with or without their knowledge (e.g. injected into one of the various
    script tags that the [=RP=] embeds that is loaded dynamically), but they usually do not modify
    the UI of the website, so that it is harder to detect the tracking. A [=tracker=] that
    successfully adds tracking scripts for users in various websites may then use this information
    for various purposes, such as selling the information about the user. It should not be possible
    for [=trackers=] to use the FedCM API to track users across the web.

Based on the above, the privacy discussion makes the following assumptions:

1. It is not acceptable for an [=RP=], [=IDP=], or [=tracker=] to learn that a specific user visited a
    specific site, without any permission granted by the user. That is, the [=user agent=] needs to hide the
    knowledge that a specific user identity visited a specific site from the [=RP=], [=IDP=], and
    [=trackers=]. It may share this knowledge with the [=RP=] and [=IDP=] once the user grants permission. In
    particular, the [=RP=] should not know the user identity and the [=IDP=] should not know the
    site that the user has visited before the FedCM flow gathers the user's permission to do so.
1. It is the [=user agent=]'s responsibility to determine when the user has granted permission for the
    [=IDP=] to communicate with the [=RP=] in order to provide identification for the user.
1. Once the [=user agent=] has determined that the user has granted permission to provide their
    account information to the [=RP=], it is ok for the [=IDP=] and for the [=RP=] to learn
    information about that specific user's account, as required to provide identification. The [=RP=]
    should not learn about about any other user accounts.

<!-- ============================================================ -->
## Network requests ## {#network-requests}
<!-- ============================================================ -->

This specification ensures that the FedCM fetches are all same-origin with respect to the provider specified
by the [=RP=]. The reason for this is because fetches with cookies would use the cookies from the
origin specified, so allowing arbitrary origins would introduce confusion and potential privacy
issues with regards to which cookies are shared and with whom within the FedCM flow. The easiest way
to ensure that all of these fetches remain same-origin is by disabling redirects and checking the
origin of the fetched URLs.

* The [=config file=] fetch can't be used to track users because it is performed without cookies, {{id_assertion_endpoint_request/client_id}},
    or referrer. Thus, anyone could perform this fetch, and the information contained therein
    is considered public.

* The [=accounts endpoint=] fetch can't be used to track users because it is performed with cookies from the
    [=IDP=] but, importantly, without the {{id_assertion_endpoint_request/client_id}} or referrer. This in theory is a new power
    that the [=RP=] gains that it would not have otherwise. Preventing too many of these fetches may
    be important, but [=IDP=]s are already expected to protect against DoS attacks. In addition, the
    user agent should only allow one FedCM flow per page at any given moment, immediately rejecting
    any attempts to start another one. Since a FedCM flow can only be terminated when the user
    interacts or after a long timer, the number of fetches performed is not a concern. The [=IDP=]
    does learn a lot about the user from this fetch, but this is discussed in detail below.

* The [=client metadata endpoint=] fetch can't be used to track users too because it is performed without cookies
    from the [=IDP=], albeit with a {{id_assertion_endpoint_request/client_id}} and a referrer. This allows the [=IDP=] to
    communicate the relevant Privacy Policy and Terms of Service to the user agent, in case
    they need to be displayed. Again, besides possible timing attacks described here, the [=RP=]
    gains nothing from this fetch, and the [=RP=] could already perform this fetch if it wanted to
    since it involves no cookies from the [=IDP=].

* By design, the token fetch exposes the user at the website to the [=IDP=]: it is
    peformed with cookies, {{id_assertion_endpoint_request/client_id}}, and referrer. Because of that, it is gated on the user
    interacting with the user agent UI, and enables the [=IDP=] to communicate to the [=RP=] the
    information required to perform a federated signin/signup. It is not possible for the [=RP=] or
    the [=IDP=] to force the token fetch to happen without user permission, as the user agent cannot be
    spoofed or otherwise tricked.
    
* The [=disconnect endpoint=] may only be fetched after the user has successfully gone through the
    FedCM flow at least once in the [=RP=]. It sends a credentialed request to the [=IDP=], so it
    is important that the [=user agent=] does not allow unlimited requests of such type, even after
    the user has used FedCM once. For this reason, any time that disconnection sends a credentialed
    request, at least one account is removed from the [=connected accounts set=], thus ensuring that
    this endpoint does not introduce a way for the [=RP=] to send requests to the [=IDP=] containing
    the [=IDP=] cookies forever.

<!-- ============================================================ -->
## Attack Scenarios ## {#attack-scenarios}
<!-- ============================================================ -->

This section describes the scenarios in which various agents might attempt to gain user information.
It considers the possibilities when:

  * The [=RP=] is collecting information,
  * The [=IDP=] is collecting information, or
  * Both the [=RP=] and the [=IDP=] are colluding.

For the purposes of this section, a principal is considered to be participating in the collection of
information if it directly or indirectly performs actions with the aim of realizing one of the above
threats.

Note: An example of indirect collusion would be an [=RP=] importing a script supplied by an [=IDP=]
where the [=IDP=] intends to track users.

For the purpose of discussion, this document assumes that third-party cookies are **disabled** by
default and are no longer effective for use in tracking mechanisms, and also some form of
mitigations are implemented against ‘bounce tracking’ using link decoration or postMessage. Most of
these scenarios consider how user tracking might happen **without** them. See also [[RFC7258]].

<!-- ============================================================ -->
### Manifest Fingerprinting ### {#manifest-fingerprinting}
<!-- ============================================================ -->

Suppose that the FedCM API did not have a two-tier manifest (see the [=create an IdentityCredential=]
algorithm), and instead directly had a single manifest. This would introduce the following
fingerprinting attack:

<div class=example>
```js
// The following will fetch the manifest JSON file, which will know the origin of the RP :(
const cred = await navigator.credentials.get({
  identity: {
    providers: [{
      configURL: \`https://idp.example/${window.location.href}\`
    }]
  }
});
```
</div>

NOTE: You can read more about the attack described
[here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1067029200).

Here, the [=RP=] includes identifies itself when fetching the manifest from the [=IDP=]. This
coupled with the credentialed fetches that the FedCM API performs would enable the [=IDP=] to easily
track the website that the user is visiting, without requiring any permission from the user. Our
mitigation to this problem is to use the [[#idp-api-well-known]] file. The existence of a file at
the root of the [=IDP=]'s domain is enforced to ensure that the file name does not introduce
fingerprints about the [=RP=] being visited.

The whole manifest could be in this location, but instead it only points to the real
manifest from there. This allows the flexibility in the future to allow a small constant
number of manifests, should an [=IDP=] require this in the future, instead of just a single one. It
also helps the [=IDP=]'s implementation because they any changes to the manifest are more likely to
be performed on a file located anywhere, as opposed to the root of the domain, which may have more
constraints in terms of ease of update.

<!-- ============================================================ -->
### Timing Attacks ### {#timing-attacks}
<!-- ============================================================ -->

In the timing attack, the [=RP=] and [=IDP=] collude to allow the [=IDP=] to compute the ([=RP=]'s
origin, [=IDP=]'s user identity) pair without the user's permission. This attack is not deterministic:
there is room for statistical error because it requires stitching together two separate pieces of
information to track the user. However, it is important to mitigate this attack and ensure that
it's economically impractical to perform. In this attack, it is assumed that network requests do not
have large fingerprinting vectors (e.g. IP addresses). These vary by [=user agent=] and are hard to
eliminate entirely, but in general [=user agents=] are expected to address these over time. These
bits of information tied to the network requests make the timing attack easier, making it more
important to address.

Note: this attack is described and discussed
[here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1089040953).

The attack is as follows:

1. The [=RP=] logs the time at which it invokes the API, time A and sends it to the [=IDP=] to
    learn itself by marking the time in which it receives the fetch for the [=RP=]'s client
    metadata. Time A is tied to the site.
1. A credentialed request is sent to the [=IDP=] that does not explicitly identify the [=RP=], but
    it is sent around a time that is close enough to the request above. The [=IDP=] notes the time
    in which this request has arrived, time B. Time B is tied to the user identity.
1. The [=IDP=] correlates time A and time B to find the (site, user identity) pair with high
    probability. Note that fingerprinting can make the correlation more accurate.

Note that this kind of correlation is already possible without FedCM by using simple cross-origin
top-level navigations, but using FedCM for this purpose would worsen the problem if it improved
timing resolution or if it was less visible to users (e.g. the [=IDP=] could return empty accounts
to the [=user agent=] to deliberately make no browser UI to be triggered, and hence make this attack
invisible to the user).

The [=user agent=] should mitigate this attack to protect users, in an interoperable way.

<!-- ============================================================ -->
### IDP Intrusion ### {#idp-intrusion}
<!-- ============================================================ -->

   > From [[PRIVACY-THREAT-MODEL#hl-intrusion]]
   >
   > Privacy harms don't always come from a site learning things.

   > From [[RFC6973#section-5.1.3|RFC6973: Intrusion]]
   >
   > Intrusion consists of invasive acts that disturb or interrupt one's life or activities.
   > Intrusion can thwart individuals' desires to be left alone, sap their time or attention, or
   > interrupt their activities.

In the context of federation, intrusion happens when an [=RP=] and an [=IDP=] are colluding to
invasively and aggressively recommend the user to login disproportionally to the their intent. Much
like unsolicited notifications, an [=RP=] can collude with an [=IDP=] to aggressively log users in.

The [=user agent=] can mitigate this by mediating the user controls and offering them proportionally
to the intent of the user or the privacy risks involved. For example, a [=user agent=] can choose to
show a loud / disruptive modal mediated dialog when it has enough confidence of the user's intent or
show a quiet / conservative UI hint when it doesn't.

A [=user agent=] could also choose to control disruption of the user's experience based on the risks
involved. For example, when a directed identifier is being exchanged it can be more confident of
the unintended consequeces and offer a more aggressive user experience, whereas when global
identifiers are exchanged a more conservative user experience.

<div class="image">
  <pre class=include-raw>
  path: img/mock45.svg
  </pre>
</div>

<!-- ============================================================ -->
### Cross-Site Correlation ### {#attack-scenarios-by-rp-cross-site-correlation}
<!-- ============================================================ -->

This attack happens when multiple [=RP=]s collude to use their user's data to correlate them and
build a richer profile. When a user willingly provides their full name, email address, phone number,
etc, to multiple relying parties, those relying parties can collaborate to build a profile of that
user and their activity across collaborating sites. Sometimes this is referred to as joining
since it amounts to a join of user records between the account databases of multiple RPs. This
correlation and profile-building is outside the user’s control and entirely out of the [=user
agent=]’s or [=IDP=]’s view.

<div class="image">
   <pre class=include-raw>
   path: img/mock3.svg
   </pre>
</div>

<div class="example">
    1. User signs into RP1 (which sells jewelry) with an IDP, providing to RP1
        their email address user@email.example
    1. User signs into RP2 (which sells houses) with an IDP, providing to RP2
        their email address user@email.example
    1. User browses the collection of wedding rings in RP1.
    1. Out of band, RP1 tells RP2 that user@email.example is shopping for wedding rings
    1. User browses the housing inventory in RP2.
    1. RP2 uses the fact that the user is shopping for wedding rings in RP1 to
        advertise and filters their housing inventory.
    1. User is surprised that RP2 knows that they are shopping for wedding rings.
</div>

The problem of [=RP=]s joining user data via back-channels is inherent to the proliferation of
identifying user data. This can be solved by issuing directed identifiers that provide an
effective handle to a user's identity with a given [=IDP=] that is unique and therefore cannot be
correlated with other [=RP=]s. In the past, there have been schemes to accomplish this using one-way
hashes of, for example, the user’s name, the [=IDP=], and the [=RP=]. These identifiers would be
unique, and hence it would not be possible to correlate these with other [=RP=]s.

<div class="image">
  <pre class=include-raw>
  path: img/mock37.svg
  </pre>
</div>

<!-- ============================================================ -->
### Unauthorized Data Usage ### {#unauthorized-data-usage}
<!-- ============================================================ -->

Another attack is when the [=RP=] or [=IDP=] uses user information for purposes not authorized by
the user. When the user agrees to allow the [=IDP=] to provide information to the [=RP=], the
permission is specific to certain purposes, such as sign-in and personalization. For instance, the
[=RP=] might use that data for other purposes that the user would not expect and did not authorize,
such as selling email addresses to a spam list. Spamming risk can exist even when using
directed identifiers.

<!-- ============================================================ -->
### RP Fingerprinting ### {#rp-fingerprinting}
<!-- ============================================================ -->

This attack happens when the [=RP=] employs client state-based tracking to identify user. Any
API that exposes any kind of client state to the web risk becoming a vector for fingerprinting. The
purpose of this API is for the user to provide identification to the [=RP=]. And the user should be
able to rescind the access to that identification, for instance by logging out. However, a tracking
[=RP=] could keep state to detect the user that was previously logged in:

<div class="image">
<pre class=include-raw>
path: img/mock5.svg
</pre>
</div>

<!-- ============================================================ -->
### Secondary Use ### {#secondary-use}
<!-- ============================================================ -->

Secondary use is the use of collected information about an individual without the individual's
perimssion for a purpose different from that for which the information was collected. This attack
happens when [=IDP=]s misuse the information collected to enable sign-in for other purposes.

Existing federation protocols require that the [=IDP=] know which service is requesting a token
in order to allow identity federation. Identity providers can use this fact to build profiles of
users across sites where the user has decided to use federation with the same account. This profile
could be used, for example, to serve targeted advertisements to those users browsing on sites that
the IDP controls.

This risk can exist even in the case where the [=IDP=] does not having pre-existing user account
information (for instance, if it is not a _bona fide_ IDP), because FedCM requests sent to the
[=IDP=] are credentialed. This is more likely to occur if the [=RP=] is colluding with the
[=IDP=] to enable tracking via [[#timing-attacks]].

<div class="image">
    <pre class=include-raw>
    path: img/mock23.svg
    </pre>
</div>

<div class='example'>
    1. User signs into RP1 (which sells jewelry) with an [=IDP=].
    1. User signs into RP2 (which sells houses) with the same [=IDP=].
    1. User navigates to the [=IDP=].
    1. Because the [=IDP=] knows that the user has an account with RP1 and RP2, the
        [=IDP=] can show ads about vacations for honeymoons.
    1. The user is surprised that their [=IDP=] is aware of their plans to get
        married.
</div>

Preventing tracking of users by the [=IDP=] is difficult: the [=RP=] has to be coded into the
identity token for security reasons, such as token reuse and fraud and abuse prevention. There have
been cryptographic schemes developed to blind the [=IDP=] to the [=RP=] while still
preventing token reuse(see Mozilla’s [personas](https://wiki.mozilla.org/Identity/Persona_AAR)).
These schemes have not been adopted by this specification.

<div class="image">
  <pre class=include-raw>
  path: img/mock34.svg
  </pre>
</div>

<!-- ====================================================================== -->
# Extensibility # {#extensibility}
<!-- ====================================================================== -->

Note: go over the extensibility mechanisms.

<!-- ====================================================================== -->
# Acknowledgements # {#acknowledgements}
<!-- ====================================================================== -->

Note: write down the Acknowledgements section.

<pre class="biblio">
{
  "CM": {
    "href": "https://w3c.github.io/webappsec-credential-management/",
    "title": "Credential Management"
  },
  "OIDC-Connect-Core": {
    "href": "https://openid.net/specs/openid-connect-core-1_0.html",
    "title": "OIDC Connect Core"
  },
  "PERMISSIONS-POLICY": {
    "href": "https://w3c.github.io/webappsec-permissions-policy",
    "title": "Permissions Policy"
  },
  "PRIVACY-MODEL": {
    "href": "https://github.com/michaelkleber/privacy-model",
    "title": "Privacy Model"
  },
  "PRIVACY-THREAT-MODEL": {
    "href": "https://w3cping.github.io/privacy-threat-model/",
    "title": "Target Privacy Threat Model"
  },
  "RFC7258": {
    "href": "https://datatracker.ietf.org/doc/html/rfc7258",
    "title": "Pervasive Monitoring Is an Attack"
  }
}
</pre>

<!-- ====================================================================== -->
# FPWD Issues # {#openissues}
<!-- ====================================================================== -->
Note: The WG has labeled the following issues as critical open issues that must be formally addressed before publication of a Candidate Recommendation.

<ul id="issueList">
    <li>Issue 240: <a href="https://github.com/w3c-fedid/FedCM/issues/240">Users can't use IdPs outside of the ones enumerated by RPs</a></li>
    <li>Issue 317: <a href="https://github.com/w3c-fedid/FedCM/issues/317">concerns about email in Accounts List</a></li>
    <li>Issue 319: <a href="https://github.com/w3c-fedid/FedCM/issues/319">Allow multiple IDPs to be used</a></li>
    <li>Issue 320: <a href="https://github.com/w3c-fedid/FedCM/issues/320">Why Sec-FedCM-CSRF and not Sec-Fetch-Mode</a></li>
    <li>Issue 352: <a href="https://github.com/w3c-fedid/FedCM/issues/352">Share performance measurement with IDP</a></li>
    <li>Issue 407: <a href="https://github.com/w3c-fedid/FedCM/issues/407">[Context API] - Authz / relation to ability to specificy scope</a></li>
    <li>Issue 428: <a href="https://github.com/w3c-fedid/FedCM/issues/428">Enforce CORS on the Identity Assertions endpoint</a></li>
    <li>Issue 441: <a href="https://github.com/w3c-fedid/FedCM/issues/441">The IDP has to support additional infrastructure to support FedCM</a></li>
    <li>Issue 442: <a href="https://github.com/w3c-fedid/FedCM/issues/442">A not-yet logged in IDP has no route to success with this flow</a></li>
    <li>Issue 467: <a href="https://github.com/w3c-fedid/FedCM/issues/467">Use cases for Cross-Site Cookie Access through Storage Access API after FedCM grant?</a></li>
    <li>Issue 488: <a href="https://github.com/w3c-fedid/FedCM/issues/488">Users may be confused after showing intent to sign in but the sign-in is failed</a></li>
    <li>Issue 511: <a href="https://github.com/w3c-fedid/FedCM/issues/511">Allow signing in to additional account(s)</a></li>
    <li>Issue 517: <a href="https://github.com/w3c-fedid/FedCM/issues/517">Allow user agents to use "Connected Accounts Set" with flexibility</a></li>
    <li>Issue 537: <a href="https://github.com/w3c-fedid/FedCM/issues/537">Allow setting IDP login status from same-site subresources</a></li>
    <li>Issue 552: <a href="https://github.com/w3c-fedid/FedCM/issues/552">Allow IDPs to use multiple config files within an eTLD+1</a></li>
    <li>Issue 553: <a href="https://github.com/w3c-fedid/FedCM/issues/553">Allowing IDPs to expose different account lists in different contexts</a></li>
    <li>Issue 555: <a href="https://github.com/w3c-fedid/FedCM/issues/555">Allow IdPs to continue and finish the request in a popup window</a></li>
    <li>Issue 556: <a href="https://github.com/w3c-fedid/FedCM/issues/556">Passing arbitrary parameters to the ID assertion endpoint</a></li>
    <li>Issue 559: <a href="https://github.com/w3c-fedid/FedCM/issues/559">Allow RPs to selectively request attributes of the user's profile</a></li>
    <li>Issue 578: <a href="https://github.com/w3c-fedid/FedCM/issues/578">Allow IdPs to return JSON objects rather than Strings back to RPs</a></li>
    <li>Issue 585: <a href="https://github.com/w3c-fedid/FedCM/issues/585">Allow IdP registration and RPs to match on a "type"</a></li>
    <li>Issue 587: <a href="https://github.com/w3c-fedid/FedCM/issues/587">Why must SameSite=none?</a></li>
    <li>Issue 599: <a href="https://github.com/w3c-fedid/FedCM/issues/599">OAuth profile for FedCM</a></li>
    <li>Issue 609: <a href="https://github.com/w3c-fedid/FedCM/issues/609">Spec says we send SameSite=Strict cookies</a></li>
    <li>Issue 616: <a href="https://github.com/w3c-fedid/FedCM/issues/616">Once `params` are merged into the spec, deprecate the `nonce` parameter</a></li>
    <li>Issue 618: <a href="https://github.com/w3c-fedid/FedCM/issues/618">Support chained authentication flows before reducing heuristics and classifications/lists in navigational tracking mitigations</a></li>
    <li>Issue 620: <a href="https://github.com/w3c-fedid/FedCM/issues/620">Make it easier to deploy this at the eTLD+1 for registered IdPs</a></li>
    <li>Issue 625: <a href="https://github.com/w3c-fedid/FedCM/issues/625">Returning accounts go first in getUserInfo</a></li>
    <li>Issue 626: <a href="https://github.com/w3c-fedid/FedCM/issues/626">PP/TOS requirements are different from auto reauthentication</a></li>
    <li>Issue 627: <a href="https://github.com/w3c-fedid/FedCM/issues/627">Add webdriver command to open PP/TOS</a></li>
</ul>
</body>
</html>

