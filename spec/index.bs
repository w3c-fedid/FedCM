<pre class='metadata'>
Title: Federated Credential Management API
Shortname: FedCM
Level: 1
Status: CG-DRAFT
Group: WICG
ED: http://wicg.github.io/FedCM
Repository: WICG/FedCM
Editor: Sam Goto, Google Inc. https://google.com, goto@google.com
Markup Shorthands: markdown yes, css no, biblio yes
Default Biblio Display: inline
Text Macro: FALSE <code>false</code>
Text Macro: TRUE <code>true</code>
Text Macro: RP Relying Party
Text Macro: IDP Identity Provider
Abstract: This specification defines a set of [=high-level API=]s that enables users to continue to use [=Identity Provider=]s to authenticate to [=Relying Party=]s without incurring into [[UNSANCTIONED-TRACKING]]. It accomplishes that by exposing the explicit user controls needed to manage the lifecycle of their federated accounts.
Test Suite: https://github.com/web-platform-tests/wpt/blob/master/credential-management/webid.https.html
</pre>

<pre class=anchors>
spec: ecma262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: time values; url: sec-time-values-and-time-range
        text: promise; url: sec-promise-objects
        text: internal method; url: sec-ordinary-object-internal-methods-and-internal-slots

spec: credential-management-1; urlPrefix: https://w3c.github.io/webappsec-credential-management/
    type: dictionary
        text: CredentialRequestOptions; url: dictdef-credentialrequestoptions
    for: Credential
        type: method
            text: [[CollectFromCredentialStore]](origin, options, sameOriginWithAncestors)
            text: [[Create]](origin, options, sameOriginWithAncestors)
            text: [[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)
            text: [[Store]](credential, sameOriginWithAncestors)
    type: dfn
        text: signal
        text: same-origin with its ancestors; url: same-origin-with-its-ancestors

spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/origin.html
    type: dfn
        text: origin; for: html-origin-def; url: concept-origin
</pre>

<pre class=link-defaults>
spec:infra; type:dfn; text:list
spec:infra; type:dfn; text:user agent
spec:html; type:dfn; for:environment settings object; text:global object
spec:html; type:dfn; for:html-origin-def; text:origin
spec:webidl; type:dfn; text:resolve
</pre>

<style>
dl.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
dl.domintro dt a {
    color: inherit; border-bottom-style: none;
}
dl.domintro dt code {
    font-size: inherit;
}
div.image {
    background-color: white;
}
</style>

<!-- ============================================================ -->
# Introduction # {#introduction}
<!-- ============================================================ -->

*This section is non-normative.*

Over the last decade, identity federation has unquestionably played a central role in raising the bar for authentication on the web, in terms of ease-of-use (e.g. passwordless single sign-on), security (e.g. improved resistance to phishing and credential stuffing attacks) and trustworthiness compared to its preceding pattern: per-site usernames and passwords.

The standards that define how identity federation works today on the Web were built independently of the Web Platform (namely, [[SAML]], [[OpenID]] and [[OAuth]]), and their designers had to (rightfully so) work around its limitations rather than extend them.

Because of that, existing user authentication flows were designed on top of general-purpose web platform capabilities such as top-level navigations/redirects with parameters, window popups, iframes and cookies.

However, because these general purpose primitives can be used for an open ended number of use cases (again, notably, by design), browsers have to apply policies that capture the lowest common denominator of abuse, at best applying cumbersome permissions (e.g. popup blockers) and at worst entirely blocking them (e.g. blocking third party cookies).

Over the years, as these [=low-level API=]s get abused, browsers intervene and federation adjusts itself. For example, popup blockers became common and federation had to adjust itself to work in a world where popups blockers were widely deployed.

The challenge is that some of these low level primitives are getting increasingly abused to allow users on the web to be tracked. So, as a result, browsers are applying stricter and stricter policies around them.

This specification defines a set of [=high-level API=]s that serve as a foundation where identity federation on Web can thrive without incurring into [[UNSANCTIONED-TRACKING]].

<!-- ============================================================ -->
# Use Cases # {#use-cases}
<!-- ============================================================ -->

The below use case scenarios illustrate some basic supported flows. Additional scenarios, including sample code, are given later in the [[Identity-Use-Cases-in-Browser-Catalog]].

<!-- ============================================================ -->
## Sign-up ## {#use-cases-sign-up}
<!-- ============================================================ -->

A Sign-up occurs when the user is registering a new account at the [=Relying Party=] using their [=Identity Provider=].

<div class="example">
* A user navigates to a [=Relying Party=] in a browser and decides to create an account.
* The [=Relying Party=] supports multiple [=Identity Provider=] as an authentication mechanism.
* A user selects their favorite [=Identity Provider=] to sign-up with.
* The [=Identity Provider=] prompts, "Do you want to create an account with the [=Relying Party=]?"
* The user agrees.
* The [=Relying Party=] shows the message "Registration complete."
* An [=account=] in created in the [=Relying Party=] and a [=session=] initialized.

</div>

<!-- ============================================================ -->
## Sign-in ## {#use-cases-sign-in}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to create an account by going through their [[#use-cases-sign-up]] flow, there are two ways a user logs into their [=account=] once their [=session=] expires:

<!-- ============================================================ -->
### Auto Sign-in ### {#use-cases-auto-sign-in}
<!-- ============================================================ -->

Auto Sign-in occurs when the [=Identity Provider=] has already gathered enough permission from the user to share their identity that it doesn't block on gathering further permission and automatically signs the user in.

<div class="example">
* Using another device (e.g. their laptop):
    * The user goes to the [=Relying Party=].
    * The user selects their favorite [=Identity Provider=] to sign-in.
    * The [=Identity Provider=] remembers and proves that the user already has an [=account=] with the [=Relying Party=].
    * The [=Relying Party=] creates a new [=session=] for the user's existing [=account=].

</div>

<!-- ============================================================ -->
### Explicit Sign-in ### {#use-cases-explicit-sign-in}
<!-- ============================================================ -->

An explicit sign-in occurs when the [=Identity Provider=] believes it is necessary to gather an explicit permission from the user to sign into a [=Relying Party=], typically after the user goes through a [[#use-cases-sign-out]] flow.

<div class="example">
* The user decides to [[#use-cases-sign-out]] of the [=Relying Party=]

A few months later:

* The user navigates to the [=Relying Party=]
* The user selects their favorite [=Identity Provider=] to sign-in again.
* The [=Identity Provider=] knows that:
    * the user already has an account with the [=Relying Party=].
    * the user has logged out of the [=Relying Party=].
* The [=Identity Provider=] prompts, "Do you want to sign-in with the [=Relying Party=]?"
* The user agrees.
* The [=Relying Party=] creates a new [=session=] for the user's existing [=account=].

</div>

<!-- ============================================================ -->
## Sign-out ## {#use-cases-sign-out}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to create an [=account=] by going through their [[#use-cases-sign-up]] flow, there are two ways a user can clear their [=session=]s:

<!-- ============================================================ -->
### RP Sign-out ### {#use-cases-rp-sign-out}
<!-- ============================================================ -->

<div class="example">
* On a shared computer:
    * The user decides to close their session and logs out of the [=Relying Party=].
    * The user is now logged out of the [=Relying Party=].
    * Upon return to the [=Relying Party=], the user expects to go through an [[#use-cases-explicit-sign-in]].

</div>

<!-- ============================================================ -->
### IDP Sign-out ### {#use-cases-idp-sign-out}
<!-- ============================================================ -->

<div class="example">
* On a shared computer:
    * The user decides to close their [=session=] and logs out of the [=Relying Party=].
    * The [=Relying Party=] lets the [=Identity Provider=] know that the user wants to logout.
    * The [=Identity Provider=] logs the user out of all of the [=Relying Party=]s and itself.
    * Upon return to the [=Relying Party=], the goes through an [[#use-cases-explicit-sign-in]].

</div>

<!-- ============================================================ -->
## Revocation ## {#use-cases-revocation}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to create an account by going through their [[#use-cases-sign-up]] flow, there are two ways a user can cancel their account:

<!-- ============================================================ -->
### IDP Revocation ### {#use-cases-idp-revocation}
<!-- ============================================================ -->

<div class="example">
* On the [=Identity Provider=]:
    * The user decides to cancel their account.
    * The user goes to their [=Identity Provider=] and revokes access to the [=Relying Party=].
    * Upon return to the [=Relying Party=], the user expects to go through a [[#use-cases-sign-up]].

</div>

<!-- ============================================================ -->
### RP Revocation ### {#use-cases-rp-revocation}
<!-- ============================================================ -->

<div class="example">
* On the [=Relying Party=]:
    * The user decides to cancel their account.
    * The user navigates to the [=Relying Party=] and cancels their account, also letting the [=Identity Provider=] know.
    * Upon return to the [=Relying Party=], the user expects to go through a [[#use-cases-sign-up]].

</div>

<!-- ============================================================ -->
## Access ## {#use-cases-access}
<!-- ============================================================ -->

<div class="example">
* A user navigates to a [=Relying Party=] in a browser and decides to create an [=account=].
* The [=Relying Party=] supports multiple [=Identity Provider=] which provide access to the user's Calendar.
* A user selects their favorite [=Identity Provider=] to sign-up with.
* The [=Identity Provider=] prompts, "Do you want to give access to your Calendar to the [=Relying Party=]?"
* The user agrees.
* The [=Relying Party=] shows message, "Registration complete.", creates a [=session=] for the user and
* Shows the user their calendar entries provided by the [=Identity Provider=].

</div>

<!-- ============================================================ -->
# Examples # {#examples}
<!-- ============================================================ -->

This specification extends the {{FederatedCredential}} type and internal algorithms to allow the exchange
of identity between [=IDP=]s and [=RP=]s. When it succeeds, it returns to the [=RP=] a signed [=id token=]
which the [=RP=] can use to authenticate the user.

<div class=example>
```html
<html>
  <head>
    <title>Welcome to my WebSite!</title>
  </head>
  <body>
    <button onclick="login('https://foo.example', '123')">Sign-in with Foo</button>
    <button onclick="logout()">logout</button>

    Welcome <span id="name"></span>!!

    <button onclick="revoke">delete account</button>

    <script>

    var user;

    const identityProvider = {
      url: provider,
      // the pre-registered client id
      clientId: clientId,
      nonce: "456"
    };

    async function login(provider, clientId) {
      const {idToken} = await navigator.credentials.get({
        // controls whether auto sign-in is enabled or not
        mediation: "optional",
        // controls abortions of the account chooser
        signal: signal

        // controls which identity providers to use
        federated: {
          // controls whether the account chooser is modal or not
          providers: [identityProvider],
        }
      });

      // ... do stuff ...
      // ... send to server ...
      // ... validate ...
      // ... update local storage ...

      user = parse(idToken);
      document.getElementById("name").innerText = user.name;
    }

    async function logout() {
      await navigator.credentials.preventSilentAccess();
    }

    async function revoke() {
      await FederatedCredential.revoke(user.id, identityProvider);
    }
    </script>
  </body>

</html>
```
</div>

<!-- ============================================================ -->
# Terminology # {#terminology}
<!-- ============================================================ -->

[[HTML]] defines an [=origin=] as the tuple of a scheme, hostname, and port that
provides the main security boundary on the web.

A <dfn>site</dfn> is a set of [=origins=] that are all [=same site=] with each
other. Note that there are problems ([[PSL-PROBLEMS]]) with using [=registrable
domains=] as a logical boundary.

A <dfn>party</dfn> is defined by [[tracking-dnt]] as "a natural person, a legal
entity, or a set of legal entities that share common owner(s), common
controller(s), and a group identity that is easily discoverable by a user."

The <dfn>first party</dfn> for a user action is the [=party=] that controls the
[=origin=] of the [=top-level browsing context=] under which the action
happened. Intuitively, this is the owner of the domain in the browser's URL bar.
This differs from <a
href="https://wiki.mozilla.org/Security/Anti_tracking_policy#Tracking_Definition">Mozilla's
definition</a> in that Mozilla defines other parties as first parties if the
user can easily discover which party it is and intends to interact with that
party, for example to allow sign-in widgets to be first-party.

A <dfn>third party</dfn> for a user action is any party that isn't the [=first
party=] or the user (the second party).

A <dfn>user</dfn> is a human or program that controls a user agent.

A <dfn>user identifier</dfn> is a pair of a [=site=] and a (potentially-large) integer
allocated by that site that is used to identify a [=user=] on that site. A
single user will generally have many user IDs that refer to them, and a single
site may or may not know that multiple user identifiers refer to the same user.

A <dfn>global identifier</dfn> is a string that identifies a particular [=user=]
independent of which site they're visiting (e.g. email addresses and phone numbers).
Users generally have relatively few global identifiers and can usually list and
recognize them. A goal of anti-tracking policy is to prevent [=user identifiers=] from
becoming [=global identifiers=].

A <dfn>directed identifier</dfn> is a [=user identifier=] that that is unique for each
site they're visiting. A goal of anti-tracking policy is to promote [=user identifiers=]
to become [=directed identifiers=].

: <dfn>Relying Party</dfn>
: <dfn>RP</dfn>
: <dfn noexport>Website</dfn>
:: TODO(goto): find existing definitions.

: <dfn>Identity Provider</dfn>
: <dfn>IDP</dfn>
:: TODO(goto): find existing definition.

: <dfn>session</dfn>
:: TODO(goto): find existing definition.

: <dfn>account</dfn>
:: TODO(goto): find existing definition.

: <dfn>id token</dfn>
:: TODO(goto): find existing definition.

: <df>unsanctioned tracking</dfn>
:: [[UNSANCTIONED-TRACKING]]

: <dfn>high-level API</dfn>
:: A use case specific API, as opposed to a [=low-level API=]. See also [high level vs low level](https://w3ctag.github.io/design-principles/#high-level-low-level).

: <dfn>low-level API</dfn>
:: A general purpose API, as opposed to a [=high-level API=]. See also [high level vs low level](https://w3ctag.github.io/design-principles/#high-level-low-level)

: <dfn>registered</dfn>
:: TODO(goto): find existing definition.

: <dfn>unregistered</dfn>
:: TODO(goto): find existing definition.

: <dfn>logged in</dfn>
:: TODO(goto): find existing definition.

: <dfn>logged out</dfn>
:: TODO(goto): find existing definition.

: <dfn>out-of-band</dfn>
:: Outside of the user agent's context.

: <dfn>joining</dfn>
::

<!-- ============================================================ -->
# High Level Design # {#high-level-design}
<!-- ============================================================ -->

At a high level, the Identity Federation Management API works by the intermediation of cooperating [=IDP=]s and [=RP=]s.

The [[#idp-api]] and the [[#rp-api]] defines a set of HTTP APIs that cooperating [=IDP=]s and [=IDP=]s exposes as well as the entry points in the [[#browser-api]] that they can use.

<div class='image'>
<pre class=include-raw>
path: img/mock43.svg
</pre>
</div>

The user agent intermediates in such a matter that makes it impractical for the API to be used for tracking purposes, while preserving the functionality of identity federation.

This document defines the APIs in the following order:

1. The [[#idp-api]]
1. The [[#rp-api]]
1. The [[#browser-api]]

<!-- ============================================================ -->
# The Identity Provider API # {#idp-api}
<!-- ============================================================ -->

The [=IDP=] proactively and cooperatively exposes itself as a comformant agent by exposing a series of HTTP endpoints:

1. A [[#idp-api-manifest]] endpoint in a well-known location that points to
1. An [[#idp-api-accounts-endpoint]] endpoint
1. A [[#idp-api-client-id-metadata-endpoint]] endpoint
1. An [[#idp-api-idtoken-endpoint]] endpoint
1. A [[#idp-api-revocation-endpoint]] endpoint

<!-- ============================================================ -->
## Manifest ## {#idp-api-manifest}
<!-- ============================================================ -->

The well-known discovery endpoint is an endpoint located at the [=IDP=]'s
`.well-known/fedcm` and serves as a discovery device to other endpoints provided by the [=IDP=].

The well-known discovery endpoint is fetched (a) **without** cookies and (b) **with** a special [[#Sec-FedCM-CSRF]] header.

For example:

<div class=example>
```http
GET /.well-known/fedcm HTTP/1.1
Host: idp.example
Accept: application/json
Sec-FedCM-CSRF: random_value
```
</div>

The file is parsed expecting the following properties:

<dl dfn-type="argument" dfn-for="WellKnown">
    :   <dfn>accounts_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-accounts-endpoint]] API.
    :   <dfn>client_id_metadata_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-client-id-metadata-endpoint]] API.
    :   <dfn>idtoken_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-idtoken-endpoint]] API.
    :   <dfn>revocation_endpoint</dfn>
    :: A URL that points to an HTTP API that complies with the [[#idp-api-revocation-endpoint]] API.
</dl>

For example:

<div class=example>
```json
{
  "accounts_endpoint": "/accounts.php",
  "client_id_metadata_endpoint": "/metadata.php",
  "idtoken_endpoint": "/idtokens.php",
  "revocation_endpoint": "/revocation.php"
}
```
</div>

<!-- ============================================================ -->
## Accounts List ## {#idp-api-accounts-endpoint}
<!-- ============================================================ -->

The accounts list endpoint provides the list of accounts the user has at the [=IDP=].

The accounts list endpoint is fetched (a) **with** any cookies and (b) **with** a special [[#Sec-FedCM-CSRF]] header.

For example:

<div class=example>
```http
GET /accounts_list.php HTTP/1.1
Host: idp.example
Accept: application/json
Cookie: 0x23223
Sec-FedCM-CSRF: random_value
```
</div>

The response is expected to have the following properties:

<dl dfn-type="argument" dfn-for="accounts_endpoint_response">
    :   <dfn>accounts</dfn> (required)
    ::  A list of [=Account JSON=].
</dl>

Every <dfn>Account JSON</dfn> is expected to have the following properties:

<dl dfn-type="argument" dfn-for="accounts_endpoint_response_accounts">
    :   <dfn>account_id</dfn> (required)
    ::  An account identifier.
    :   <dfn>name</dfn> (required)
    ::  The user's full name.
    :   <dfn>given_name</dfn> (required)
    ::  The user's given name.
    :   <dfn>email</dfn> (optional)
    ::  The user's email address.
    :   <dfn>picture</dfn> (optional)
    :: The user's profile picture.
</dl>

For example:

<div class=example>
```json
{
 "accounts": [{
   "account_id": "1234",
   "given_name": "John",
   "name": "John Doe",
   "email": "john_doe@idp.example",
   "picture": "https://idp.example/profile/123",
  }, {
   "account_id": "5678",
   "given_name": "Johnny",
   "name": "Johnny",
   "email": "johnny@idp.example",
   "picture": "https://idp.example/profile/456"
  }]
}
```
</div>

<!-- ============================================================ -->
## Client Metadata ## {#idp-api-client-id-metadata-endpoint}
<!-- ============================================================ -->

The client metadata endpoint provides metadata about [=RP=]s.

The client medata endpoint is fetched (a) **without** cookies and (b) **with** a special [[#Sec-FedCM-CSRF]] header.

The user agent also passes the **client_id**.

For example:

<div class=example>
```http
GET /client_medata.php?client_id=1234 HTTP/1.1
Host: idp.example
Accept: application/json
Sec-FedCM-CSRF: random_value
```
</div>

The file is parsed expecting the following properties:

<dl dfn-type="argument" dfn-for="client_id_metadata_endpont_response">
    :   <dfn>privacy_policy_url</dfn>
    ::  A link to the [=RP=]'s privacy policy.
    :   <dfn>terms_of_service_url</dfn>
    ::  A link to the [=RP=]'s terms of service.
</dl>

For example:

<div class=example>
```json
{
  "privacy_policy_url": "/privacy.html",
  "terms_of_service_url": "/terms.html",
}
```
</div>

<!-- ============================================================ -->
## ID Token ## {#idp-api-idtoken-endpoint}
<!-- ============================================================ -->

The ID Token endpoint is responsible for [=minting=] a new [=id token=] for the user.

The ID Token endpoint is fetched (a) as a **POST** request, (b)  **with** cookies and (c) **with** a special [[#Sec-FedCM-CSRF]] header.

It will also contain the following parameters passed as a JSON object:

<dl dfn-type="argument" dfn-for="idtoken_endpoint_request">
    :   <dfn>account_id</dfn>
    :: The account identifier that was selected.
    :   <dfn>request</dfn>
    :: The [=RP request=]
</dl>

The <dfn>RP request</dfn> has the following properties:

<dl dfn-type="argument" dfn-for="idtoken_endpoint_request_request">
    :   <dfn>client_id</dfn>
    :: The [=RP=]'s client it
    :   <dfn>nonce</dfn>
    :: A random number of the choice of the [=RP=]
</dl>

For example:

<div class=example>
```http
POST /fedcm_token_endpoint HTTP/1.1
Host: idp.example
Referer: rp.example
Content-Type: application/json
Cookie: 0x23223
Sec-FedCM-CSRF: random_value
{
  "account_id": "123",
  "request": {
    "client_id": "client1234",
    "nonce": "Ct60bD"
  }
}
```
</div>

The response is parsed as a JSON file expecting the following properties:

<dl dfn-type="argument" dfn-for="idtoken_endpoint_response">
    :   <dfn>id_token</dfn>
    ::  The resulting [=id token=].
</dl>

For example:

<div class=example>
```json
{
  "id_token" : "eyJC...J9.eyJzdWTE2...MjM5MDIyfQ.SflV_adQssw....5c"
}
```
</div>

<!-- ============================================================ -->
## Revocation ## {#idp-api-revocation-endpoint}
<!-- ============================================================ -->


The revocation endpoint is responsible for revoking all [=id token=]s for the
specified client ID for the user.

The revocation endpoint is fetched (a) as a **POST** request, (b)  **with**
cookies, (c) **with** a special [[#Sec-FedCM-CSRF]] header, and (d) **with**
a Referer header indicating the [=RP=] URL.

It will also contain the following parameters passed as a JSON object:

<dl dfn-type="argument" dfn-for="revocation_endpoint_request">
    :   <dfn>account_id</dfn>
    :: The account identifier for the user (e.g. email).
    :   <dfn>request</dfn>
    :: The [=revocation request=]
</dl>

The <dfn>revocation request</dfn> has the following properties:

<dl dfn-type="argument" dfn-for="revocation_endpoint_request_request">
    :   <dfn>client_id</dfn>
    :: The [=RP=]'s client id
</dl>

For example:

<div class=example>
```http
POST /fedcm_revocation_endpoint HTTP/1.1
Host: idp.example
Referer: rp.example
Content-Type: application/json
Cookie: 0x23223
Sec-FedCM-CSRF: random_value
{
  "account_id": "123",
  "request": {
    "client_id": "client1234"
  }
}
```
</div>

If successful, the response is an empty response with an HTTP 204 code,
otherwise an HTTP error code.

<!-- ============================================================ -->
## <code><dfn data-export="">`Sec-FedCM-CSRF`</dfn></code> ## {#Sec-FedCM-CSRF}
<!-- ============================================================ -->

<!-- ============================================================ -->
# The Relying Party API # {#rp-api}
<!-- ============================================================ -->

[=RP=]'s expose a [[#rp-api-logout-endpoint]] to facilitate with [[#use-cases-idp-sign-out]].

<!-- ============================================================ -->
## Logout ## {#rp-api-logout-endpoint}
<!-- ============================================================ -->

When [=IDP=]s call the [[#browser-api-idp-sign-out]] API, every [=RP=] gets a
chance to log the user out (e.g. clear cookies, clear local storage)
via the logout endpoint.

The logout endpoint is an endpoint that is registered with the [=IDP=]
[=out-of-band=].

The logout endpoint is called (a) with a **GET** and (b) with the [=RP=]'s cookies.

Note: the logout API introduces a credentialed request from the [=IDP=] to
the [=RP=]s, so it exposes a potential tracking surface area. It is a fairly
limited and controlled tracking area because the logout API is only available
when accounts **and** sessions are already established between the [=IDP=] and
the [=RP=].

<!-- ============================================================ -->
# The Browser API # {#browser-api}
<!-- ============================================================ -->

The Browser API exposes APIs to [=RP=]s and [=IDP=]s to call and intermediates the exchange of the user's identity.

For [=RP=]s, it allows them to:

1. The [[#browser-api-sign-in]] allows [=RP=]'s users to [[#use-cases-sign-up]] and [[#use-cases-sign-up]]
1. The [[#browser-api-revocation]] allows [=RP=]'s users to go through [[#use-cases-rp-revocation]] of their accounts
1. The [[#browser-api-rp-sign-out]] API allows [=RP=]s to [[#use-cases-rp-sign-out]] of their accounts.

For [=IDP=]s, it allows them to:

1. The [[#browser-api-idp-sign-out]] API allows [=IDP=]s to [[#use-cases-idp-sign-out]] of their accounts.

The Browser API manages the lifecycle of the user's accounts and sessions with an internal [[#browser-api-state-machine]].

<!-- ============================================================ -->
## The State Machine ## {#browser-api-state-machine}
<!-- ============================================================ -->

Internally, the account management and session management APIs allows the user to explicitly move through the different stages of their accounts. At each stage, the state machine manages the [=RP=]'s and the [=IDP=]'s access to the appropriate browser capabilities.

<div class='image'>
<pre class=include-raw>
path: img/mock42.svg
</pre>
</div>

<dl dfn-type="argument" dfn-for="StateMachine">
    :   <dfn>Account State</dfn>
    ::  Keeps track of whether the user has an account or not. Can be [=registered=] or (by default) [=unregistered=].
    :   <dfn>Session State</dfn>
    ::  Keeps track of whether the user has an open or closed session. Can be [=logged in=] or (by default) [=logged out=].
</dl>

<!-- ============================================================ -->
## The Sign-in API ## {#browser-api-sign-in}
<!-- ============================================================ -->

<!-- ============================================================ -->
### RP Sign-in API ### {#browser-api-rp-sign-in}
<!-- ============================================================ -->

The Sign-up and Sign-in APIs are APIs used by the [=Relying Party=]s to ask the browser to intermediate the relationship with the [=Identity Provider=] and the provisioning of an [=id token=].

The [=Relying Party=] makes no delineation between Sign-up and Sign-in, but rather call the same API indistinguishably. The most important parameter to the API call is the set of [=Identity Provider=]s that the [=Relying Party=] supports and has pre-registered with (i.e. it has a `clientId`).

Additionally, the [=Relying Party=] can control a variety of UX knobs. For example, whether to allow an [[#use-cases-auto-sign-in]] flow and an AbortSignal in case it needs to abort the flow.

If all goes well, the [=Relying Party=] receives back an [=id token=] in the form of a signed [[JWT]] which it can use to authenticate the user.

<div class=example>
```js
async function login(signal) {
  const {idToken} = await navigator.credentials.get({
    // controls whether auto sign-in is enabled or not
    mediation: "optional",
    // controls abortions of the account chooser
    signal: signal

    // controls which identity providers to use
    federated: {
      // controls whether the account chooser is modal or not
      providers: [{
        url: "https://idp.example",
        // the pre-registered client id
        clientId: "123",
        nonce: "456"
      }],
    }
  });

  return idToken;
}
```
</div>

To accomplish that, this specification does three things:

1. It extends {{FederatedCredential}} with more fields.
1. It redefines {{FederatedCredential}}'s <code><dfn for="FederatedCredential" method>\[[DiscoverFromExternalSource]]()</dfn></code>.
1. It extends {{FederatedCredentialRequestOptions}} with more options.

First, this specification extends the {{FederatedCredential}} type adding two more fields:

<xmp class=idl>
enum FederatedCredentialApprovedBy {
  "auto",
  "user"
};

[Exposed=Window, SecureContext]
partial interface FederatedCredential {
  readonly attribute USVString idToken;
  readonly attribute FederatedCredentialApprovedBy approvedBy;
};
</xmp>

<dl dfn-type="attribute" dfn-for="FederatedCredential">
    :   {{idToken}}
    ::  The [=id token=].

    :   {{approvedBy}}
    ::  When used in conjunction with {{CredentialRequestOptions/mediation}}, it indicates whether the credential was provided via a [[#use-cases-auto-sign-in]] or an [[#use-cases-explicit-sign-in]].
</dl>

Second, it extends the {{FederatedCredentialRequestOptions}} by adding a list of {{FederatedIdentityProvider}}s:

<xmp class=idl>
partial dictionary FederatedCredentialRequestOptions {
  sequence<(DOMString or FederatedIdentityProvider)> providers;
};

dictionary FederatedIdentityProvider {
  required USVString url;
  USVString clientId;
  USVString nonce;
};
</xmp>

And finally, this specification overrides the {{FederatedCredential}}'s <code><dfn for="FederatedCredential" method>\[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</dfn></code> Method.

This algorithm runs in parallel inside the [[CM#algorithm-request]] to request credentials and returns a set of {{FederatedCredential}} objects from a remote [=Identity Provider=].

This [=internal method=] accepts three arguments:

<dl dfn-type="argument" dfn-for="FederatedCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">

    :   <dfn>origin</dfn>
    ::  This argument is the [=relevant settings object=]'s [=environment settings object/origin=], as determined by the
        calling {{CredentialsContainer/get()}} implementation, i.e., {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a> abstract operation.

    :   <dfn>options</dfn>
    ::  This argument is a {{CredentialRequestOptions}} object whose
        <code>|options|.{{CredentialRequestOptions/federated}}</code> member contains a {{FederatedCredentialRequestOptions}}
        object specifying the exchange options.

    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the caller's [=environment settings object=] is
        [=same-origin with its ancestors=]. It is [FALSE] if caller is cross-origin.
</dl>

When this method is invoked, the user agent MUST execute the following algorithm:

    1.  If <var ignore>sameOriginWithAncestors</var> is `false`, return a "{{NotAllowedError}}" {{DOMException}}.

        Note: This restriction aims to address the concern raised in [[Security-Origin-Confusion]].

    1.  Assert: |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"] [=map/exists=].

    1.  Assert: |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"] [=list/size=] is 1.

        Note: At some point we would like to support choosing accounts from multiple [=Identity Provider=]s.

    1. Let |provider| be |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"][0].

    1. Assert: |provider|["{{FederatedIdentityProvider/url}}"] [=map/exists=].

    1. Assert: |provider|["{{FederatedIdentityProvider/clientId}}"] [=map/exists=].

    1. Assert: |provider|["{{FederatedIdentityProvider/nonce}}"] [=map/exists=].

    1. Let |wellknown| be the result of running the [=fetch the well-known=] algorithm with the |provider|.

    1. Let |accounts list| be the result of running the [=fetch the accounts list=] algorithm.

    1. Let |account| be the result of running the [=select an account=] from the |accounts list| algorithm.

    1. If the {{StateMachine/Account State}} is [=unregistered=]

        1. Return the result of running the [=sign-up=] algorithm.

    1.  If the {{StateMachine/Session State}} is  [=logged out=] then

        1. Return the result of running the [=explicit sign-in=] algorithm.

    1. Return the result of running the [=auto sign-in=] algorithm.


To <dfn>sign-up</dfn> the user run this algorithm:

    1. Gather explicit intent to create an account

    1. Gather explicit agreement with the [=Privacy Policy=]

    1. Gather explicit agreement with the [=Terms of Service=]

    1. Set the account's {{StateMachine/Account State}} from [=unregistered=] to [=registered=].

    1. Set the account's {{StateMachine/Session State}} from [=logged out=] to [=logged in=].

    1. Return the result of [=minting=] a new [=id token=].

To <dfn>select an account</dfn> from the accounts list run this algorithm:

    1. If |accounts list|'s [=list/size=] is 1

        1. Let |account| be |accounts list|[0]

        1. Return |account|

    1. Display an account chooser

    1. Let |account| be an account that the user manually selects from the accounts chooser

    1. Return |account|

To <dfn>sign-in</dfn> the user run this algorithm:

    1. Assert that the {{StateMachine/Account State}} is [=registered=]

    1. Set the account's {{StateMachine/Session State}} from [=logged out=] to [=logged in=].

    1. Return the result of [=minting=] a new [=id token=].


To <dfn>auto sign-in</dfn> the user run this algorithm:

    1. Return the result of running the [=sign-in=] algorithm.


To <dfn>explicit sign-in</dfn> the user run this algorithm:

    1. Gather explicit confirmation that the user wants to sign-in to [=Relying Party=] with their [=Identity Provider=]'s |account|

    1. Return the result of running the [=sign-in=] algorithm.

To <dfn>fetch the well-known</dfn> configuration file, run this algorithm:

1. Let the |wellknown url| be the relative url ".well-known/fedcm" of |provider|["{{FederatedIdentityProvider/url}}"]

1. Return the result of fetching the |wellknown url| with the [[#Sec-FedCM-CSRF|Sec-FedCM-CSRF]] header but without the [=Identity Provider=]'s cookies.

To <dfn>fetch the accounts list</dfn> run this algorithm:

1. Let the |accounts_endpoint| url be the relative url |wellknown|["{{WellKnown/accounts_endpoint}}"] of |provider|["{{FederatedIdentityProvider/url}}"]

1. Let the |accounts list| be the result of fetching the |accounts_endpoint| with the [=Identity Provider=]'s cookies.

1. Return the |accounts list|

To <dfn noexport>fetch the client id metadata</dfn> run this algorithm:

1. Let the |client_id_metadata_endpoint| url be the relative url |wellknown|["{{WellKnown/client_id_metadata_endpoint}}"] of |provider|["{{FederatedIdentityProvider/url}}"]
1. Let the |policies| be the result of fetching the |client_id_metadata_endpoint| with the [[#Sec-FedCM-CSRF|Sec-FedCM-CSRF]] header but without the [=Identity Provider=]'s cookies.
1. Return |policies|

The <dfn>Privacy Policy</dfn> are the policies described at {{client_id_metadata_endpont_response/privacy_policy_url}}.

The <dfn>Terms of Service</dfn> are the policies described at {{client_id_metadata_endpont_response/terms_of_service_url}}.

To <dfn>mint</dfn> a new id token, run the following algorithm:

1. Let |token| be the result of making a POST request to the |wellknown|["{{WellKnown/idtoken_endpoint}}"] with:
    * Let the {{idtoken_endpoint_request/account_id}} be |account|["{{accounts_endpoint_response_accounts/account_id}}"].
    * Let the {{idtoken_endpoint_request/request}} be a new object with
          * Let {{idtoken_endpoint_request_request/client_id}} be |provider|["{{FederatedIdentityProvider/clientId}}"].
          * Let the {{idtoken_endpoint_request_request/nonce}} be |provider|["{{FederatedIdentityProvider/nonce}}"].
1. Return a new {{FederatedCredential}} as:
    * {{FederatedCredential/id}} with |account|["{{accounts_endpoint_response_accounts/account_id}}"]
    * {{FederatedCredential/idToken}} with |token|
    * {{FederatedCredential/provider}} with |provider|["{{FederatedIdentityProvider/url}}"]

<!-- ============================================================ -->
### IDP Sign-in API ### {#browser-api-idp-sign-in}
<!-- ============================================================ -->

The IDP Sign-in API allows an [=IDP=] to sign the user into a [=RP=] by
storing a {{FederatedCredential}} that can later be retrieved by a [=RP=].

Its effect is equivalent to the [[#browser-api-rp-sign-in]] in its effect, except that
it is designed to be called while the user is at the [=IDP=] rather than
at the [=RP=].

<div class=example>
```js
async function login({id, name, iconURL}) {
  const credential = new FederatedCredential({
    id: id,
    provider: 'https://idp.example',
    name: name,
    iconURL: iconUrl,
    client_id: "1234",
  });

  return await navigator.credentials.store(credential);
}
```
</div>

<!-- ============================================================ -->
## The Revocation API ## {#browser-api-revocation}
<!-- ============================================================ -->

Whenever the user decides to delete their account on the [=Relying Party=]
the [=Relying Party=] can call an API to let the [=Identity Provider=] and
the browser know.

Upon return to the [=Relying Party=], the user goes through a [[#use-cases-sign-up]] flow
instead of a [[#use-cases-sign-in]] flow.

<div class=example>
```js
async function revoke(accountId, identityProvider) {
  return await FederatedCredential.revoke(accountId, identityProvider);
}
```
</div>

This specification extends the {{FederatedCredential}} interface with an extra static method:

<xmp class=idl>
[Exposed=Window, SecureContext]
partial interface FederatedCredential {
  static Promise<undefined> revoke(USVString accountId, FederatedIdentityProvider provider);
};
</xmp>

Note: go over the revocation API.

<!-- ============================================================ -->
## The Sign-out API ## {#browser-api-sign-out}
<!-- ============================================================ -->

<!-- ============================================================ -->
### RP Sign-out ### {#browser-api-rp-sign-out}
<!-- ============================================================ -->

When a user wants to log out of their session in the [=Relying Party=],
the [=Relying Party=] can let the browser know that it wants the [[#use-cases-auto-sign-in]]
flow to be disabled, so that the user doesn't get into an infinite loop.

It does so by calling the `preventSilentAccess()` API, which clear the
user's current account session and takes them to an [[#use-cases-explicit-sign-in]] flow
whenever the user wants to log back in.

<div class=example>
```js
function logout() {
  navigator.credentials.preventSilentAccess();
}
```
</div>

Note: go over the RP sign-out API.

<!-- ============================================================ -->
### IDP Sign-out ### {#browser-api-idp-sign-out}
<!-- ============================================================ -->

In enterprise scenarios, it is common for the user to want to clear all of
their existing sessions in all of the [=Relying Party=]s they are logged into.

It does so by being navigated to their [=Identity Provider=] who initiates
what's called a [[Front-Channel-Logout]].

The browser exposes an API that takes the list of [=Relying Party=]s that the
[=Identity Provider=] wants to initiate the logout which are loaded in parallel
with cookies.

Each [=Relying Party=] endpoint is responsible for clearing its local state
(e.g. clearing cookies).

After the completion of this API, the user's session is cleared and will go
through an [[#use-cases-explicit-sign-in]] upon return.

<div class='image'>
<pre class=include-raw>
path: img/mock31.svg
</pre>
</div>

<div class=example>
```js
async function logout() {
  await FederatedCredential.logout([{
      endpoint: "https://rp1.example",
      accountId: "123",
    }, {
      endpoint: "https://rpN.example",
      accountId: "456",
    }]);
}
```
</div>

[=IDP=]s can call <code><a idl for="FederatedCredential" lt="logout()">FederatedCredential.logout(...)</a></code> to log the user out of the [=RP=]s they are signed into.

<xmp class=idl>
dictionary FederatedCredentialLogoutRequest {
    required USVString endpoint;
    required USVString accountId;
};

[Exposed=Window, SecureContext]
partial interface FederatedCredential {
  static Promise<undefined> logout(optional sequence<FederatedCredentialLogoutRequest> logout_requests = []);
};
</xmp>

Note: go over how this is implemented.

<!-- ============================================================ -->
## Backwards Compatibility ## {#browser-api-backwards-compatibility}
<!-- ============================================================ -->

Note: go over how we are planning to deal with backwards compatibility.

<!-- ============================================================ -->
# Security # {#security}
<!-- ============================================================ -->

Note: go over security.

<!-- ============================================================ -->
# Privacy # {#privacy}
<!-- ============================================================ -->

<!-- ============================================================ -->
## Privacy Threat Model ## {#privacy-threat-model}
<!-- ============================================================ -->

This section is intended to provide a comprehensive overview of the privacy risks associated with federated identity on the web for the purpose of measuring the privacy risks and benefits of proposed browser intermediation designs.

See also:

    * [[PRINCIPLES]]
    * [[ETHICS]]
    * [[SELF-REVIEW#threats]]
    * [[PRIVACY-CONSIDERATIONS#privacy-threats]]
    * [[RFC6973#section-5]]
    * [A Potential Privacy Model for the Web](https://github.com/michaelkleber/privacy-model)
    * [Editor’s Draft for a Web Privacy Threat Model](https://w3cping.github.io/privacy-threat-model/)
    * [Security and Privacy Considerations for SAML V2.0](https://docs.oasis-open.org/security/saml/v2.0/saml-sec-consider-2.0-os.pdf)

<!-- ============================================================ -->
### Principals ### {#privacy-threat-model-principals}
<!-- ============================================================ -->

This section describes the three principals that would participate in an invocation of the API and expectations around their behavior.

1. The [=User Agent=] implements [[#browser-api]] and controls the execution contexts for the [=RP=] and [=IDP=] content. The user agent is assumed to be trusted by the user, and transitively trusted by the RP and IDP.
1. [=Relying Party=]s ([=RP=]s) are [=first party=] websites that invoke the FedCM API for the purpose of authenticating a user to their account or for requesting information about that user. A well-behaving RP would only invoke the API following a clear user signal -- typically, clicking a sign-in button. Since any site can invoke the API, RPs cannot necessarily be trusted to limit the user information it collects or use that information in an acceptable way.
1. [=Identity Provider=]s ([=IDP=]s) are [=third party=] websites that are the target of a FedCM call to attempt to fetch an ID token. Usually the IDP has a higher level of trust than the RP since it already has the user’s personal information, but it is possible that the IDP might use the user’s information in non-approved ways. It is possible that the IDP specified in the API call may not be an IDP the user knows about, or may not be a bona fide IDP at all, in which case it likely does not have personal user information in advance, but also might be less accountable for its behavior.

<!-- ============================================================ -->
### High-level threats ### {#privacy-threat-model-high-level-threats}
<!-- ============================================================ -->

[[RFC6973]] describes the following high-level privacy threats, which the TAG
has adopted into [[security-privacy-questionnaire#threats]]:

: <dfn noexport>Surveillance</dfn>
:: Surveillance is the observation or monitoring of an individual’s
    communications or activities.

: <dfn noexport>Stored Data Compromise</dfn>
:: End systems that do not take adequate measures to secure stored data from
    unauthorized or inappropriate access.

: <dfn noexport>Intrusion</dfn>
:: Intrusion consists of invasive acts that disturb or interrupt one’s life or
    activities.

: <dfn noexport>Misattribution</dfn>
:: Misattribution occurs when data or communications related to one individual
    are attributed to another.

: <dfn noexport>Correlation</dfn>
:: Correlation is the combination of various pieces of information related to an
    individual or that obtain that characteristic when combined.

: <dfn noexport>Identification</dfn>
:: Identification is the linking of information to a particular individual to
    infer an individual’s identity or to allow the inference of an individual’s
        identity.

: <dfn noexport>Secondary Use</dfn>
:: Secondary use is the use of collected information about an individual without
    the individual’s consent for a purpose different from that for which the
        information was collected.

: <dfn noexport>Disclosure</dfn>
:: Disclosure is the revelation of information about an individual that affects
    the way others judge the individual.

: <dfn noexport>Exclusion</dfn>
:: Exclusion is the failure to allow individuals to know about the data that
    others have about them and to participate in its handling and use.

These threats combine into the particular concrete threats we want web
specifications to defend against, described in subsections here:

<!-- ============================================================ -->
### Attack Scenarios ### {#attack-scenarios}
<!-- ============================================================ -->

This section describes the scenarios in which various agents might attempt to gain user information. It considers the possibilities when:

    * [[#attack-scenarios-by-rp|The RP is collecting information]],
    * [[#attack-scenarios-by-idp|The IDP is collecting information]], or
    * [[#attack-scenarios-by-idp-by-collusion|Both the RP and the IDP are colluding]].

For the purposes of this section, a principal is considered to be participating in the collection of information if it directly or indirectly performs actions with the aim of realizing one of the above threats.

Note: An example of indirect collusion would be an RP importing a script supplied by an IDP where the IDP intends to track users.

For the purpose of discussion this document assumes that third-party cookies are **disabled** by default and are no longer effective for use in tracking mechanisms, and also some form of mitigations are implemented against ‘bounce tracking’ using link decoration or postMessage. Most of these scenarios consider how user tracking might happen **without** them.

See also:

    1. [[RFC7258]]

<!-- ============================================================ -->
#### By the RP #### {#attack-scenarios-by-rp}
<!-- ============================================================ -->

<!-- ============================================================ -->
##### Cross-Site Correlation ##### {#attack-scenarios-by-rp-cross-site-correlation}
<!-- ============================================================ -->

Related to:

    * [[PRIVACY-THREAT-MODEL#hl-recognition-cross-site]]
    * [[PRIVACY-CONSIDERATIONS#privacy-threats| Privacy Considerations for Web Protocols: Correlation]]
    * [[RFC6973#section-5.2.1|RFC6973: Correlation]]

Correlation is the combination of various pieces of information related to an individual or that obtain that characteristic when combined.

This attack happens when multiple [=RP=]s collude to use their user's data to correlate them and build a richer profile.

When a user willingly provides their full name, email address, phone number, etc,
to multiple relying parties, those relying parties can collaborate to build a
profile of that user and their activity across collaborating sites.

Sometimes this is referred to as [=joining=] since it amounts to a join of user records between the account databases of multiple RPs.

This correlation and profile-building is outside the user’s control and entirely out of the [=User Agent=]’s or [=IDP=]’s view.

<div class="image">
   <pre class=include-raw>
   path: img/mock3.svg
   </pre>
</div>

<div class="example">
    1. User signs into RP1 (which sells jewelry) with an IDP, providing to RP1 their email address user@email.example
    1. User signs into RP2 (which sells houses) with an IDP, providing to RP2 their email address user@email.example
    1. User browses the collection of wedding rings in RP1.
    1. Out of band, RP1 tells RP2 that user@email.example is shopping for wedding rings
    1. User browses the housing inventory in RP2.
    1. RP2 uses the fact that the user is shopping for wedding rings in RP1 to advertise and filters their housing inventory.
    1. User is surprised that RP2 knows that they are shopping for wedding rings.
</div>

A generalization of [[#attack-scenarios-by-rp-cross-site-correlation]] is:

(<dfn noexport>RP Secondary Use</dfn>) Relying Party uses user information for purposes not authorized by the user:

When the user agrees to allow the IDP to provide information to the RP,
the consent is specific to certain purposes, such as sign-in and personalization.
The RP might use that data for other purposes that the user would not expect and
did not authorize, such as selling email addresses to a spam list.

Spamming risk can exist even when using [=directed identifiers=].

<!-- ============================================================ -->
##### Same-Site Identification ##### {#attack-scenarios-by-rp-same-site-identification}
<!-- ============================================================ -->

Identification is the linking of information to a particular individual
to infer an individual’s identity or to allow the inference of an
individual’s identity.

This attack happens when the Relying Party employs client state-based
tracking to identify user.

Any API that exposes any kind of client state to the web risk becoming a
vector for fingerprinting or ‘supercookies’.

This risk would be increased by any proposal for browser mediation that
adds directly (or indirectly) detectable client state.

<div class="image">
<pre class=include-raw>
path: img/mock5.svg
</pre>
</div>

<div class='example'>
For example, an RP can use the browser state of the FedCM to add bits of entropy and fingerprint the user.
</div>

See also:

   1. [[FINGERPRINTING-GUIDANCE]]

<!-- ============================================================ -->
##### Data Compromise ##### {#attack-scenarios-by-rp-data-compromise}
<!-- ============================================================ -->

This attack scenario happens when the [=RP=] takes advantage of
inadequate measures (by the [=IDP=] or the UA) to secure stored data to
obtain personal user information without their consent.

This can happen if user consent mechanisms are missing, inadequate,
or susceptible to bypass.

<div class="example">
An RP can use clickjacking to trick the user into signing-into their site.
</div>

<div class="example">
An RP can impersonate another RP to phish the user into signing-into their site.
</div>

See also:

    1. [[PRIVACY-THREAT-MODEL#stored-data-compromise]]
    1. [[RFC6973#section-5.1.2]]

<!-- ============================================================ -->
#### By the IDP #### {#attack-scenarios-by-idp}
<!-- ============================================================ -->

<!-- ============================================================ -->
##### Secondary Use ##### {#attack-scenarios-by-idp-secondary-use}
<!-- ============================================================ -->

Related to:

    * [[SELF-REVIEW#third-party-tracking]]

Secondary use is the use of collected information about an individual
without the individual's consent for a purpose different from that
for which the information was collected.

This attack happens when Identity Providers misuses the the information
collected to enable sign-in for other purposes.

Existing federation protocols require that the IDP know which service is
requesting an ID token in order to allow identity federation (e.g. the IDP must know the OAuth `client_id`).

Identity providers can use this fact to build profiles of users across sites where the user
has decided to use federation with the same account. This profile could be used, for example,
to serve targeted advertisements to those users browsing on sites that the IDP controls.

This risk can exist even in the case where the IDP does not having pre-existing user
account information (for instance, if it is not a _bona fide_ IDP), because FedCM
requests sent to the IDP are credentialed. This is more likely to occur if the RP is
colluding with the IDP to enable tracking; expanded variants are described in [[#attack-scenarios-by-idp-timing-attacks]].

<div class="image">
    <pre class=include-raw>
    path: img/mock23.svg
    </pre>
</div>

<div class='example'>
    1. User signs into RP1 (which sells jewelry) with an IDP.
    1. User signs into RP2 (which sells houses) with the same IDP.
    1. User navigates to the IDP.
    1. Because the IDP knows that the user has an account with RP1 and RP2, the IDP can show ads about vacations for honeymoons.
    1. The user is surprised that their IDP is aware of their plans to get married.
</div>

<!-- ============================================================ -->
##### Impersonation ##### {#attack-scenarios-by-idp-impersonation}
<!-- ============================================================ -->

Since IDPs have unconstrained ability to issue ID tokens, they are capable
of logging in to users’ federated accounts without user knowledge or action,
impersonating the user and potentially gaining full access to the user's account on the RP.

<div class="example">
    1. User signs into RP1 (which is a online dating site) with an IDP.
    1. An evil employee at IDP is an ex-spouse of the user.
    1. The evil employee impersonates themselves as the User and gains access to RP1
    1. The evil employee looks at the user's dating history.
    1. The user is surprised by their ex-spouse's knowledge of their recent dating affairs.
</div>

<!-- ============================================================ -->
#### By Collusion #### {#attack-scenarios-by-idp-by-collusion}
<!-- ============================================================ -->

<!-- ============================================================ -->
##### Intrusion ##### {#attack-scenarios-by-idp-intrusion}
<!-- ============================================================ -->

   > From [[PRIVACY-THREAT-MODEL#hl-intrusion]]
   >
   > Privacy harms don't always come from a site learning things.

   > From [[RFC6973#section-5.1.3|RFC6973: Intrusion]]
   >
   > Intrusion consists of invasive acts that disturb or interrupt one's
   > life or activities.  Intrusion can thwart individuals' desires to be
   > left alone, sap their time or attention, or interrupt their
   > activities.

In the context of federation, intrusion happens when an RP and an IDP
are colluding to invasively and aggressively recommend the user to
login disproportionally to the their intent.

Much like unsolicited notifications, an [=RP=] can collude with an [=IDP=]
to aggressively log users in.

See also:

    1. [[DESIGN-PRINCIPLES#safe-to-browse]]

<!-- ============================================================ -->
##### Back channel ##### {#attack-scenarios-by-idp-back-channel}
<!-- ============================================================ -->

This attack scenario happens when IDP exceed the user’s information sharing permission.

Existing federated identity protocols are clear on what information an RP
is requesting, which the IDP can provide. While the browser can inspect
the request and response and consider whether user permission has been
granted for that transfer, it is difficult to know that there is no
additional information embedded in the response. An example could be if
the IDP encodes an identifier that could be used to load user-targeted
advertisements on RP pages, which could be of value where the IDP has much
more profiling information about the user.

Another example is if identifying information is shared out-of-band,
invisible to the browser, in which case it could contain anything.

<div class="example">
    1. User signs into RP1 (which sells jewelry) with an IDP, providing to RP1 their [=directed identifier=] email address SHA256(user + RP1)@email.example
    1. User signs into RP2 (which sells houses) with an IDP, providing to RP2 their [=directed identifier=] email address SHA256(user + RP2)@email.example
    1. User browses the collection of wedding rings in RP1.
    1. Out of band, RP1 colludes with the IDP and exchanges SHA256(user + RP1)@email.example to user@email.example.
    1. RP1 tells RP2 that user@email.example is shopping for wedding rings
    1. User browses the housing inventory in RP2.
    1. Out of band, RP2 colludes with the IDP and exchanges SHA256(user + RP2)@email.example to user@email.example.
    1. RP2 uses the fact that the user is shopping for wedding rings in RP1 to advertise and filters their housing inventory.
    1. User is surprised that RP2 knows that they are shopping for wedding rings.
</div>

<!-- ============================================================ -->
##### Timing Attacks ##### {#attack-scenarios-by-idp-timing-attacks}
<!-- ============================================================ -->

The potential for IDPs profiling users based on their visits to RPs [[#attack-scenarios-by-idp-secondary-use]] can
be partially mitigated by hiding the RP from the IDP until after the user has
consented to that tracking risk.

However, there is residual risk in cases where the RP and IDP are colluding.

If a credentialed request is sent to the IDP that does not explicitly identify
the RP, either of the following would still allow tracking by the IDP (again,
possibly not a _bona fide_ IDP that has existing knowledge of the user):

    * The RP controlling any field in the request that can be used to convey identifying
          data in the request that the IDP could correlate to other requests from other RPs;

* The RP being able to provide fine-resolution timing information about
    the request to the IDP out of band.

The timing information can enable tracking in the following way:

    1. The RP logs the time at which it invoked the API, and
    1. The IDP logs the time at which it received a credentialed FedCM request from the user, and later
    1. They attempt to link the invocation and the request together using that information.

Notably, this is possible without FedCM using simple cross-origin top-level navigations,
but using FedCM for this purpose would worsen the problem if it improved timing resolution
or was less visible to users.

See also:

    1. [[DESIGN-PRINCIPLES#safe-to-browse]]

## Mitigation Strategies ## {#mitigation-strategies}

In this section we'll go over some strategies used in this specification to mitigate the [privacy threats](#privacy-threat-model).

### Minimal Disclosure ### {#mitigation-minimal-disclosure}

There is a series of privacy threats that can be mitigated by disclosing the least amount of identifying information and limiting its use as much as possible. Two notable strategies are described in the sections below.

#### Directed Identifiers #### {#mitigation-directed-identifiers}

Mitigates:

    * [[#attack-scenarios-by-rp-cross-site-correlation]]

Note: directed, sharding, partitioning

The problem of RPs joining user data via back-channels is inherent
to the proliferation of identifying user data. This can be solved
by issuing [=directed identifiers=] that provide an effective handle
to a user's identity with a given IDP that is unique and therefore
cannot be correlated with other RPs.

In the past, there have been schemes to accomplish this using one-way
hashes of, for example, the user’s name, the IDP and the RP.

<div class="image">
  <pre class=include-raw>
  path: img/mock37.svg
  </pre>
</div>

Note: this mitigation is not robust against [[#attack-scenarios-by-idp-back-channel]],
or the [[#attack-scenarios-by-idp-secondary-use]]. Also, collaborating RPs might be able
to defeat this mitigation by sharing the same CLIENT_ID, although
possibly this could be detected and presumably would violate RP
agreements with IDPs with [[#mitigation-pre-registration]].

#### Self Presentation #### {#mitigation-self-presentation}

Mitigates:

    * [[#attack-scenarios-by-idp-secondary-use]] and
    * [[#attack-scenarios-by-idp-timing-attacks]]

Note: unbundling issuing from presentation

Preventing tracking of users by the IDP is difficult because the RP has to be coded into the identity token for security reasons, to prevent reuse of the token. There have been cryptographic schemes developed to blind the IDP to the RP while still preventing token reuse in that way (see Mozilla’s [personas](https://wiki.mozilla.org/Identity/Persona_AAR)) but there are other valid uses that the IDP has for knowing the RP, such as fraud and abuse prevention.

<div class="image">
  <pre class=include-raw>
  path: img/mock34.svg
  </pre>
</div>

### Mediation ### {#mitigation-mediation}

Mitigates:

    * [[#attack-scenarios-by-rp-cross-site-correlation]],
    * [[#attack-scenarios-by-rp-data-compromise]],
    * [[#attack-scenarios-by-idp-timing-attacks]]
    * [[#attack-scenarios-by-idp-intrusion]]

IDPs, whom the user has entrusted with their personal data, are currently responsible for ensuring that the user consents to their information being shared. With browser mediation in place, the user agent might have to assume responsibility for ensuring the user understands what is being shared and that it is intentional. This is certainly the case if the browser is able to entirely intermediate the identity flow without showing any IDP web content, but also might be desirable if there are concerns that the IDP is not collecting consent in an adequate manner.

Additionally, a consent prompt preceding the sharing of the RP’s request to the IDP can mitigate risks around IDP tracking of user visits to RPs.

<div class="image">
  <pre class=include-raw>
  path: img/mock46.svg
  </pre>
</div>

See also:

  1. [[DESIGN-PRINCIPLES#consent]]
  1. [[SELF-REVIEW#user-mediation]]
  1. [[RFC6973#page-23]]
  1. [[ETHICS|Ethical Principles]]: [[ETHICS#verify|The web must make it possible for people to verify the information they see]]
  1. [[ETHICS|Ethical Principles]]: [[ETHICS#control|The web must enhance individuals' control and power]]
  1. [[LEAST-POWER]]

#### Verification #### {#mitigation-verification}

Mitigates:

    * [[#attack-scenarios-by-rp-cross-site-correlation]],

The [=User Agent=] can mitigate [[#attack-scenarios-by-rp-cross-site-correlation]] by inspecting the contents
of the data exchange, and providing the necessary user controls.

For example, it can inspect the email address that is being exchanged and verify
whether it is a [=directed identifier=] or not (and warn the user proportionally).

#### Activation #### {#activation}

The [=User Agent=] can mitigate [[#attack-scenarios-by-idp-intrusion]] by mediating the user controls
and offering them proportionally to the intent of the user or the privacy risks involved.

For example, a [=User Agent=] can choose to show a loud / disruptive modal mediated dialog
when it has enough confidence of the user's intent or show a quiet / conservative UI hint
when it doesn't.

A [=User Agent=] could also choose to control disruption of the user's experience based
on the risks involved.

For example, when a [=directed identifier=] is being exchanged it can be more confident
of the unintended consequeces and offer a more aggressive user experience, whereas when
global identifiers are exchanged a more conservative user experience.

<div class="image">
  <pre class=include-raw>
  path: img/mock45.svg
  </pre>
</div>

See also:

    * [Requiring user gesture to call WebAuthn API](https://github.com/w3c/webauthn/issues/1293)
    * [Require user gesture to request notification permissions](https://github.com/wicg/interventions/issues/49)
    * [WHATWG User Activation](https://html.spec.whatwg.org/multipage/interaction.html#tracking-user-activation)
    * [Querying User Activation](https://github.com/dtapuska/useractivation)

### Policy ### {#mitigation-policy}

Mitigates:

    * [[#attack-scenarios-by-idp-impersonation]],
    * [[#attack-scenarios-by-idp-back-channel]]

Beyond technical constraints, the browser can recognize explicit assertions by the IDP about the privacy characteristics it provides and rely on those assertions in order to guide the user appropriately. An example is a hypothetical case in which the IDP asserts it will only issue [=directed identifiers=] and will not provide identifying information to the RPs out of view of the browser. In that case the browser may not have to warn the user about sharing personalized information.

### Denylists ### {#mitigation-denylists}

Mitigates:

    * Potentially all threats, but is subject to the likelihood of bad behavior being detected, which for some might be difficult.

Any RPs or IDPs observed to be using this API to compromise user privacy in a deceptive or abusive manner could be explicitly blocked from using it, or potentially added to the SafeBrowsing blocklist so that they cannot be loaded at all.

### Pre-registration ### {#mitigation-pre-registration}

Mitigates:

    * [[#attack-scenarios-by-rp-data-compromise]],
    * [[#attack-scenarios-by-rp-cross-site-correlation]]

Currently, IDPs require that an RP pre-registers and agrees to specific terms before the IDP will issue an ID token to them.
This conflicts with [the previous mitigation](#mitigation-self-presentation), but can provide a measure of RP accountability.

### 2FA ### {#mitigation-2fa}

Mitigates:

    * [[#attack-scenarios-by-idp-impersonation]],

<!-- ====================================================================== -->
# Extensibility # {#extensibility}
<!-- ====================================================================== -->

Note: go over the extensibility mechanisms.

<!-- ====================================================================== -->
# Acknowledgements # {#acknowledgements}
<!-- ====================================================================== -->

Note: write down the Acknowledgements section.

<pre class="biblio">
{
  "OpenID": {
    "href": "https://openid.net/developers/specs/",
    "title": "OpenID"
  },
  "OAuth": {
    "authors": ["D. Hardt"],
    "href": "https://datatracker.ietf.org/doc/html/rfc6749",
    "title": "OAuth"
  },
  "SAML": {
    "href": "http://saml.xml.org/saml-specifications",
    "title": "SAML"
  },
  "JWT": {
    "authors": [ "M. Jones", "J. Bradley", "N. Sakimura" ],
    "href": "https://datatracker.ietf.org/doc/html/rfc7519",
    "title": "JWT"
  },
  "CM": {
    "href": "https://w3c.github.io/webappsec-credential-management/",
    "title": "Credential Management"
  },
  "Security-Origin-Confusion": {
    "href": "https://w3c.github.io/webappsec-credential-management/#security-origin-confusion",
    "title": "Security Origin Confusion"
  },
  "Front-Channel-Logout": {
    "authors": [ "M. Jones" ],
    "href": "https://openid.net/specs/openid-connect-frontchannel-1_0.html",
    "title": "Front-Channel Logout"
  },
  "PRINCIPLES": {
    "href": "https://w3ctag.github.io/design-principles",
    "title": "Web Platform Design Principles"
  },
  "ETHICS": {
   "href": "https://www.w3.org/2001/tag/doc/ethical-web-principles",
   "title": "W3C TAG Ethical Web Principles"
  },
  "PRIVACY-CONSIDERATIONS": {
    "href": "https://w3c.github.io/privacy-considerations/",
    "title": "Privacy Considerations for Web Protocols"
  },
  "RFC6973": {
    "href": "https://datatracker.ietf.org/doc/html/rfc6973",
    "title": "Privacy Considerations for Internet Protocols"
  },
  "RFC7258": {
    "href": "https://datatracker.ietf.org/doc/html/rfc7258",
    "title": "Pervasive Monitoring Is an Attack"
  },
  "SELF-REVIEW": {
    "href": "https://www.w3.org/TR/security-privacy-questionnaire/",
    "title": "Self-Review Questionnaire: Security and Privacy"
  },
  "FINGERPRINTING-GUIDANCE": {
    "href": "https://w3c.github.io/fingerprinting-guidance/",
    "title": "Mitigating Browser Fingerprinting in Web Specifications"
  },
  "PRIVACY-THREAT-MODEL": {
    "href": "https://w3cping.github.io/privacy-threat-model/",
    "title": "Target Privacy Threat Model"
  },
  "PSL-PROBLEMS": {
    "authors": ["Ryan Sleevi"],
    "href": "https://github.com/sleevi/psl-problems",
    "title": "Public Suffix List Problems"
  },
  "Identity-Use-Cases-in-Browser-Catalog": {
    "authors": [ "V. Bertocci", "G. Fletcher" ],
    "href": "https://datatracker.ietf.org/doc/html/draft-bertocci-identity-in-browser-00",
    "title": "Identity Use Cases in Browser Catalog"
  }
}
</pre>
