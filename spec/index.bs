<pre class='metadata'>
Title: Federated Credential Management API
Shortname: FedCM
Level: 1
Status: w3c/CG-DRAFT
Group: fedidcg
ED: https://fedidcg.github.io/FedCM/
Repository: fedidcg/FedCM
Editor: Sam Goto, Google Inc. https://google.com, goto@google.com

Markup Shorthands: markdown yes, biblio yes
Default Biblio Display: inline

Text Macro: FALSE <code>false</code>
Text Macro: TRUE <code>true</code>
Text Macro: RP Relying Party
Text Macro: IDP Identity Provider

Abstract: A Web Platform API that allows users to login to websites with their federated accounts in a privacy preserving manner.

Test Suite: https://github.com/web-platform-tests/wpt/blob/master/credential-management/
</pre>

<pre class=anchors>
spec: ecma262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: internal method; url: sec-ordinary-object-internal-methods-and-internal-slots

spec: credential-management-1; urlPrefix: https://w3c.github.io/webappsec-credential-management/
    type: dfn
        text: same-origin with its ancestors; url: same-origin-with-its-ancestors
</pre>

<pre class=link-defaults>
spec:infra; type:dfn; text:list
spec:infra; type:dfn; text:user agent
spec:html; type:dfn; for:environment settings object; text:global object
spec:html; type:dfn; for:html-origin-def; text:origin
spec:webidl; type:dfn; text:resolve
</pre>

<style>
dl.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
dl.domintro dt a {
    color: inherit; border-bottom-style: none;
}
dl.domintro dt code {
    font-size: inherit;
}
.idp-normative-text {
    background-color: rgba(165, 42, 42, 0.3);
    margin: 16px 0px;
    padding: 8px;
    border-left: 8px solid brown;
}
</style>

<script src="https://fedidcg.github.io/FedCM/static/underscore-min.js"></script>
<script src="https://fedidcg.github.io/FedCM/static/raphael.min.js"></script>
<script src="https://fedidcg.github.io/FedCM/static/webfont.js"></script>
<script src="https://fedidcg.github.io/FedCM/static/typogram.js"></script>

<!-- ============================================================ -->
# Introduction # {#introduction}
<!-- ============================================================ -->

*This section is non-normative.*

As the web has evolved there have been ongoing privacy-oriented changes
(e.g [Safari](https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/),
[Firefox](https://blog.mozilla.org/blog/2019/09/03/todays-firefox-blocks-third-party-tracking-cookies-and-cryptomining-by-default/),
[Chrome](https://blog.google/products/chrome/privacy-sustainability-and-the-importance-of-and/))
and changes to the underlying privacy principles (e.g. [[PRIVACY-MODEL]]).

With this evolution, fundamental assumptions of the web
platform are being redefined or removed. Access to cookies in a third-party
context are one of those assumptions. While overall good for the
web, the third-party cookie deprecation removes a fundamental building block
used by certain designs of federated identity.

The Federated Credential Management API aims to bridge the gap for the
federated identity designs which relied on third-party cookies.
The API provides the primitives needed to support federated identity when/where
it depends on third-party cookies, from sign-in to sign-out and revocation.

In order to provide the federated identity primitives without the use of
third-party cookies the API places the [=user agent=] as a mediator between
[=RPs=] and [=IDPs=]. This mediation requires user permission before allowing
the [=RPs=] and [=IDPs=] to know about their connection to the user.

<script type="text/typogram">
.---------------------------------.       .---------------------------------.
| .-----------------------------. |       | .-----------------------------. |
| | "https://rp.example"        | |       | | "https://rp.example"        | |
| '-----------------------------' |       | '-----------------------------' |
| .-----------------------------. |       | .-----------------------------. |
| |                             | |       | |                             | |
| |   Welcome to my website!    | |       | |  Welcome to my website!     | |
| |                             | |       | |                             | |
| |                             | |       | |                             | |
| +-----------------------------+ |       | +-----------------------------+ |
| |       Choose an account     | |       | |    Sign-in to rp.example    | |
| |   to sign-in to rp.example  | |       | |      with idp.example?      | |
| |                             | |       | |                             | |
| | .----.                      | |       | | .----.                      | |
| | | :) |  John Doe            | |  -->  | | | :) |  John Doe            | |
| | '----'  john@email.com      | |       | | '----'  john@email.com      | |
| | .----.                      | |       | |                             | |
| | | :] |  John Doe            | |       | | +-------------------------+ | |
| | '----'  john.doe@work.com   | |       | | |    Continue as John     | | |
| |                             | |       | | +-------------------------+ | |
| '-----------------------------' |       | '-----------------------------' |
'---------------------------------'       '---------------------------------'
</script>

The specification leans heavily on changes in the [=user agent=] and [=IDP=]
and minimally on the [=RP=]. The FedCM API provides a way to authenticate,
fetch tokens, revoke the provided tokens, and allow for front-channel logout.

<!-- ============================================================ -->
## Use Cases ## {#use-cases}
<!-- ============================================================ -->

The below use case scenarios illustrate some basic supported flows. Each
supported flow below occurs inside an iframe or in an XHR request.

<!-- ============================================================ -->
### Sign-up ### {#use-cases-sign-up}
<!-- ============================================================ -->

A Sign-up occurs when the user is registering a new account at the
[=Relying Party=] using their [=Identity Provider=].

For instance, a user navigates to a [=Relying Party=] in their browser
and creates an account. The [=Relying Party=] displays supported
[=Identity Providers=] to the user who selects their favorite. The user
is prompted "Do you want to sign up on the [=Relying Party=] with the [=Identity Provider=]?".
Upon user agreement an [=account=] is created with the [=Identity Provider=] and
the user has a [=session=] initialized on [=Relying Party=].

<!-- ============================================================ -->
### Sign-in ### {#use-cases-sign-in}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and creates an
account by going through their [[#use-cases-sign-up]] flow, the user can
sign into their [=account=] once their [=session=] expires.

A sign-in occurs when the [=Identity Provider=] believes it is
necessary to gather an explicit permission from the user to sign into a
[=Relying Party=], typically after the user goes through a
[[#use-cases-sign-out]] flow.

For example, after the user has done the [[#use-cases-sign-out]] flow of the
[=Relying Party=] they decide to log in again. The user visits the
[=Relying Party=] and selects their [=Identity Provider=] to sign-in. The
[=Identity Provider=] knows:
    * the user already has an account with the [=Relying Party=].
    * the user has logged out of the [=Relying Party=].

The user is then prompted, "Do you want to sign in on the [=Relying Party=] with the [=Identity Provider=]?"
and upon user agreement the [=Relying Party=] creates a new [=session=] with
the users existing [=account=].

<!-- ============================================================ -->
### Sign-out ### {#use-cases-sign-out}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to
create an [=account=] by going through their [[#use-cases-sign-up]] flow,
there are two ways a user can clear their [=session=]s:

<!-- ============================================================ -->
#### RP Sign-out #### {#use-cases-rp-sign-out}
<!-- ============================================================ -->

The user can log out through the [=Relying Party=] by using a provided
sign-out button or link provided by the [=Relying Party=]. This then
removes the users [=session=] and, when the user visits the [=Relying Party=]
again they will need to go through the [[#use-cases-sign-in]] flow
in order to establish a new session.

<!-- ============================================================ -->
#### IDP Sign-out #### {#use-cases-idp-sign-out}
<!-- ============================================================ -->

The user can log out through the [=Identity Provider=] by using a provided
sign-out system provided by the [=Identity Provider=]. After using the
sign-out system the [=Identity Provider=] will log the user out of all
[=Relying Parties=] the user has signed into along with logging the user
out of the [=Identity Provider=] itself. Upon returning to any associated
[=Relying Party=], the user will need to sign in with the [=Identity Provider=]
first and go through the [[#use-cases-sign-in]] flow on the [=Relying Party=].

<!-- ============================================================ -->
### Revocation ### {#use-cases-revocation}
<!-- ============================================================ -->

After a user has created an account on a [=Relying Party=] there are two
ways a user can cancel their account with the [=Relying Party=]:

<!-- ============================================================ -->
#### RP Revocation #### {#use-cases-rp-revocation}
<!-- ============================================================ -->

The user can delete their account through the [=Relying Party=] by using
the provided account revocation system. The [=Relying Party=] informs the
[=Identity Provider=] that the user has deleted (revoked) their account.
When the user returns to the [=Relying Party=] they will need to complete
the [[#use-cases-sign-up]] flow in order to access the site.

<!-- ============================================================ -->
#### IDP Revocation #### {#use-cases-idp-revocation}
<!-- ============================================================ -->

The user can delete their account with a [=Relying Party=] by revoking
[=Relying Party=] access through the [=Identity Provider=]. This can be done
by going to the [=Identity Provider=] and using their revoke access system.
Once access is revoked, when the user returns to the [=Relying Party=] they
will need to complete the [[#use-cases-sign-up]] flow in order to access the
site.

<!-- ============================================================ -->
### Access ### {#use-cases-access}
<!-- ============================================================ -->

The [=Identity Provider=] while authenticating the user may also authorize
access to users resources such as calendars, contacts, etc. The granting
of access can be done at either sign-up or post sign-up by requesting
permission from the user.

For example, a user executes the [[#use-cases-sign-up]] flow with a
[=Relying Party=]. During the flow the [=Relying Party=] has informed the
[=Identity Provider=] they need calendar access for the user. The user will
be presented with a prompt, "Do you want to give access to your Calendar
to the [=Relying Party=]?". The user grants permission to providing access and when
the flow is complete the [=Relying Party=] shows the user their calendar
entries provided by the [=Identity Provider=].

<!-- ============================================================ -->
# Examples # {#examples}
<!-- ============================================================ -->

This specification defines a new {{IdentityCredential}} type and internal
algorithms to allow the exchange of identity between [=IDP=]s and [=RP=]s.
When it succeeds, it returns to the [=RP=] a signed [=token=] which the
[=RP=] can use to authenticate the user.

<div class=example>
Example showing how a website allowing for a single logged in account
could be implemented.

```html
<html>
<head>
  <title>Welcome to my Website</title>
</head>
<body>
  <button onclick="login()">Login with idp.example</button>

  <script>
  let nonce;
  async function login() {
    // Assume we have a method returning a random number. Store the value in a variable which can
    // later be used to check against the value in the token returned.
    nonce = random();
    // Prompt the user to select an account from the IDP to use for
    // federated login within the RP. If resolved successfully, the Promise
    // returns an IdentityCredential object from which the `token` can be
    // extracted.
    return await navigator.credentials.get({
      identity: {
        providers: [{
          configURL: "https://idp.example/manifest.json",
          clientId: "123",
          nonce: nonce
        }]
      }
    });
  }
  </script>
</body>
</html>
```
</div>

<!-- ============================================================ -->
# Terminology # {#terminology}
<!-- ============================================================ -->

[[HTML]] defines an [=/origin=] as the tuple of a scheme, hostname, and port that
provides the main security boundary on the web.

: <dfn>account</dfn>
:: TODO(goto): find existing definition.

: <dfn>authentication</dfn>
:: Process used by an [=Identity Provider=] to achieve sufficient confidence in
    the binding between the user and a presented identity.

    Note that in some discussions and documentation, the term _authentication_ is
    used to refer to the [=federated sign-in=] process. However, the user does not
    authenticate to the [=RP=] during [=federated sign-in=]. The user
    authenticates to the [=IDP=], which then provides a claim to the [=RP=]
    asserting the userâ€™s identity. The user does not prove their identity to the
    [=RP=].

    See also:
    * [[OIDC-Connect-Core#Terminology]]
    * [[OIDC-Connect-Core#Authentication]]
    * [[SAML-Glossary]]

: <dfn>client id</dfn>
:: Each [=IDP=] assigns to each [=RP=] a [=client id=] to uniquely identify the [=RP=]. Note that
    this ID is dependent on both the [=IDP=] and the [=RP=], but the [=client id=] of an [=RP=] only
    needs to be unique with respect to any other [=client id=] within the same [=IDP=].

: <dfn>directed identifier</dfn>
:: A [=user identifier=] that that is unique for each [=site=] the user visits. A
    goal of anti-tracking policy is to promote [=user identifiers=] to become
    [=directed identifiers=].

: <dfn>global identifier</dfn>
:: A string that identifies a particular [=user=] independent of which site
    they're visiting (e.g. email addresses and phone numbers). Users generally
    have relatively few global identifiers and can usually list and recognize
    them. A goal of anti-tracking policy is to prevent [=user identifiers=] from
    becoming [=global identifiers=].

: <dfn>high-level API</dfn>
:: A use case specific API, as opposed to a [=low-level API=]. See also
    [high level vs low level](https://w3ctag.github.io/design-principles/#high-level-low-level).

: <dfn>token</dfn>
:: TODO(goto): find existing definition.

: <dfn>Identity Provider</dfn>
: <dfn>IDP</dfn>
:: A service that has information about the user and can grant that information
    to [=Relying Parties=].

    See also:
    * [[OIDC-Connect-Core#Terminology]]

: <dfn>Tracker</dfn>
:: A third-party origin that has injected a script within the [=RP=] and that is not an [=IDP=]. Its
    goal is to track the user's behavior and build profiles that it can then sell to the highest
    bidder.

: <dfn>joining</dfn>
:: TODO(goto): find existing definition.

: <dfn>low-level API</dfn>
:: A general purpose API, as opposed to a [=high-level API=]. See also
    [high level vs low level](https://w3ctag.github.io/design-principles/#high-level-low-level)

: <dfn>minting</dfn>
:: The act of a new token being creating

: <dfn>out-of-band</dfn>
:: Outside of the user agent's context.

: <dfn>Relying Party</dfn>
: <dfn>RP</dfn>
: <dfn noexport>Website</dfn>
:: A service that requests user information from an [=Identity Provider=] for
    [=federated sign-in=] or for other purposes.

    See also:
    * [[OIDC-Connect-Core#Terminology]]
    * [[SAML-Glossary]]

: <dfn>session</dfn>
:: TODO(goto): find existing definition.

: <dfn>Federated sign-in</dfn>
:: Process used by a [=Relying Party=] to obtain a [=user identifier=] from an
    [=Identity Provider=] to which the user performed [=authentication=].

    See also:
    * [[OIDC-Connect-Core]]

: <dfn>site</dfn>
:: A set of [=/origins=] that are all [=site/same site=] with each other. Note that
    there are problems ([[PSL-PROBLEMS]]) with using [=registrable domains=] as
    a logical boundary.

: <df>unsanctioned tracking</dfn>
:: [[UNSANCTIONED-TRACKING]]

: <dfn>user</dfn>
:: A human or program that controls a user agent.

: <dfn>user identifier</dfn>
:: A pair of a [=site=] and a (potentially-large) integer
    allocated by that site that is used to identify a [=user=] on that site. A
    single user will generally have many user IDs that refer to them, and a single
    site may or may not know that multiple user identifiers refer to the same user.

:  <dfn>Privacy Policy</dfn>
:: The policies described at {{IdentityProviderClientMetadata/privacy_policy_url}}.

:  <dfn>Terms of Service</dfn>
:: The policies described at {{IdentityProviderClientMetadata/terms_of_service_url}}.

: <dfn>registered</dfn>
:: The account is `registered` if the user agent thinks that the user has registered an account in
    the [=RP=] using the account from the [=IDP=].

: <dfn>unregistered</dfn>
:: The account is `unregistered` if it's not registered.

<!-- ============================================================ -->
# High Level Design # {#high-level-design}
<!-- ============================================================ -->

At a high level, the Federated Credential Management API works by the
intermediation of cooperating [=IDP=]s and [=RP=]s.

The [[#idp-api]] and the [[#rp-api]] defines a set of HTTP APIs that cooperating
[=IDP=]s and [=IDP=]s exposes as well as the entry points in the [[#browser-api]]
that they can use.

<script type="text/typogram">
+-----------+                  +-----------+                      +-----------+
|           |                  |           |                      |           |
|  Relying  |                  |   User    |                      | Identity  |
|   Party   |                  |   Agent   |                      | Provider  |
|           |                  |           |                      |           |
|           |                  | Federated |                      |           |
|           |   +----------->*-+ Credential|     +------------->*-+ Well-Known|
|           |   |              | Management|     |                |           |
|           |   |              |    API    |     +------------->*-+ Config    |
|           |   |              |           |     |                |           |
|           |   |              |           |     +------------->*-+ Accounts  |
|           |   |              |           |     |                |           |
|           |   |              |           |     +------------->*-+ Client    |
|           |   |              |           |     |                | Metadata  |
|           |   |              |           |     |                |           |
|           |   |              |           |     +------------->*-+ Assertion |
|           |   |              |           |     |                |           |
|           |   |              |           |     |                |           |
| +-------+ |   |              | +-------+ |     |                | +-------+ |
| | JS    +-+---+     +--------+-+ HTTP  +-+-----+       +------+-+-+   JS  | |
| +-------+ |         |        | +-------+ |             |        | +-------+ |
|           |         |        |           |             |        |           |
|           |         |        |           |             |        |           |
|           |         |        |           |             |        |           |
|    logout +-*<------+        | logoutRPs +-*<----------+        |           |
|           |                  |           |                      |           |
|           |                  |           |                      |           |
+-----------+                  +-----------+                      +-----------+
</script>

The user agent intermediates in such a matter that makes it impractical for the
API to be used for tracking purposes, while preserving the functionality of
identity federation.

<script type="text/typogram">
    Relying                         User                            Identity
    Party                           Agent                           Provider

      |                               |                                 |
      | "navigator.credentials.get({" | "(1) The RP invokes the API."   |
      | "  identity: {              " |                                 |
      | "    providers: [{          " |                                 |
      | "      configURL: ...       " |                                 |
      | "    }]                     " |                                 |
      | "  }                        " |                                 |
      | "})                         " |                                 |
      |                               |                                 |
      |------------------------------>|                                 |
      |                               |                                 |
      |                               |                                 |
      | "(2) From the configURL, the" | "GET /.well-known/web-identity" |
      | "browser makes two requests " |-------------------------------->|
      | "in parallel."                |                                 |
      |                               | "GET /config.json"              |
      |                               |-------------------------------->|
      |                               |                                 |
      | "(3) The IdP responds with a" |                                 |
      | "well-known file and a      " |                                 |
      | "config file."                |                                 |
      |                               |                                 |
      |                               |                                 |
      |                               |                                 |
      | "The well-known file        " | "Well-Known file"               |
      | "contains a list of valid   " |<--------------------------------| "{"
      | "config URLs.               " |                                 |   "provider_urls: [ ... ]"
      |                               |                                 | "}"
      |                               |                                 |
      | "The config file contains   " | "Config file"                   |
      | "information about the IdP. " |<--------------------------------| "{"
      |                               |                                 |   "id_assertion_endpoint: ...,"
      |                               |                                 |   "accounts_endpoint: ...,"
      |                               |                                 |   "client_metadata_endpoint: ...,"
      |                               |                                 |   "branding: ...,"
      |                               |                                 | "}"
      |                               |                                 |
      | "(4) The browser proceeds to" | "GET /accounts"                  |
      | "fetch the list of accounts " | "cookies"                       |
      | "that the user is logged in " |-------------------------------->|
      | "to.                        " |<--------------------------------| "{"
      |                               |                                 |   "accounts: [ ... ]"
      |                               |                                 | "}"
      |                               |                                 |
      |                               |                                 |
      | "(5) The browser then       " | "GET /client_metadata"           |
      | "fetches metadata about the " | "client_id"                     |
      | "Relying Party.             " |-------------------------------->|
      |                               |<--------------------------------| "{"
      |                               |                                 |   "terms_of_service_url: ...,"
      |                               |                                 |   "privacy_policy_url: ...,"
      |                               |                                 | "}"
      |                               |                                 |
      |                               |                                 |
      |                     +---------+ "(6) With all of this, the    " |
      |                     |         | "browser asks for the user's  " |
      |                     |         | "permission to sign-in to the " |
      |  "account chooser"  |         | "RP with the IdP's account.   " |
      |                     |         |                                 |
      |                     |         |                                 |
      |                     +-------->|                                 |
      |                               |                                 |
      |                               |                                 |
      |                               |                                 |
      | "(7) With the user's        " | "POST /assertion"                |
      | "permission, the browser    " | "client_id, cookies, account"   |
      | "fetches a token from IdP.  " |-------------------------------->|
      |                               |<--------------------------------| "{"
      |                               |                                 |   "token: ...,"
      |                               |                                 | "}"
      |                               |                                 |
      |                "{ token }"    | "(8) Which is then ultimately " |
      |<------------------------------| "used to resolve the promise. " |
      |                               |                                 |
      |                               |                                 |
     -+-                             -+-                               -+-
</script>


This document defines the APIs in the following order:

1. The [[#idp-api]]
1. The [[#rp-api]]
1. The [[#browser-api]]

<!-- ============================================================ -->
# The Identity Provider API # {#idp-api}
<!-- ============================================================ -->

<em>This section is non-normative.</em>

The [=IDP=] proactively and cooperatively exposes itself as a comformant agent
by exposing a series of HTTP endpoints:

1. A [[#idp-api-manifest]] endpoint in an agreed upon location that points to
1. An [[#idp-api-accounts-endpoint]] endpoint
1. A [[#idp-api-client-id-metadata-endpoint]] endpoint
1. An [[#idp-api-id-assertion-endpoint]] endpoint

The [=IDP=] must also host a file at the ".well-known/web-identity" path of its [=registrable domain=] that has JSON contents that are convertable to an {{IdentityProviderWellKnown}} object.

<xmp class="idl">
dictionary IdentityProviderWellKnown {
  required sequence<USVString> provider_urls;
};
</xmp>

Issue: The algorithms used for these endpoints need to [integrate](https://github.com/fedidcg/FedCM/issues/261) with [=fetch=].

<!-- ============================================================ -->
## The Well-Known File ## {#idp-api-well-known}
<!-- ============================================================ -->

NOTE: The browser uses the well-known file to prevent the following attack described [here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1067029200).

The [=IDP=] exposes a well-known file in a pre-defined location, specifically at the "web-identity" file at the [=IDPs=]'s path ".well-known".

The well-known file is fetched:

(a) **without** cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`, and
(c) **without** a [[RFC9110#field.referer|Referer]] header

For example:

<div class=example>
```http
GET /.well-known/web-identity HTTP/1.1
Host: idp.example
Accept: application/json
Sec-Fetch-Dest: webidentity
```
</div>

The file is parsed expecting a [=Well-Known=] JSON object.

The <dfn>Well-Known</dfn> JSON object has the following properties:

<dl dfn-type="argument" dfn-for="Well-Known">
    :   <dfn>provider_urls</dfn> (required)
    ::  A list of URLs that points to valid [[#idp-api-manifest]]s.
</dl>

<!-- ============================================================ -->
## Manifest ## {#idp-api-manifest}
<!-- ============================================================ -->

The config endpoint is an endpoint
which serves as a discovery device to other endpoints provided by the
[=IDP=].

The config endpoint is fetched:

(a) **without** cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(c) **without** a [[RFC9110#field.referer|Referer]] header, and
(c) **without** following [[RFC9110#field.location|HTTP redirects]].

For example:

<div class=example>
```http
GET /config.json HTTP/1.1
Host: idp.example
Accept: application/json
Sec-Fetch-Dest: webidentity
```
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderAPIConfig}} without an exception.

<xmp class=idl>
dictionary IdentityProviderIcon {
  required USVString url;
  unsigned long size;
};

dictionary IdentityProviderBranding {
  USVString background_color;
  USVString color;
  sequence<IdentityProviderIcon> icons;
};

dictionary IdentityProviderAPIConfig {
  required USVString accounts_endpoint;
  required USVString client_metadata_endpoint;
  required USVString id_assertion_endpoint;
  IdentityProviderBranding branding;
};
</xmp>

The {{IdentityProviderAPIConfig}} object's members have the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderAPIConfig">
    :   <dfn>accounts_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-accounts-endpoint]] API.
    :   <dfn>client_metadata_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-client-id-metadata-endpoint]] API.
    :   <dfn>id_assertion_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-id-assertion-endpoint]] API.
    :   <dfn>branding</dfn>
    ::  A set of {{IdentityProviderBranding}} options.
</dl>

The {{IdentityProviderBranding}} enables an [=IDP=] to express their branding
preferences, which may be used by [=user agents=] to customize the permission prompt.

Note: The branding preferences are deliberately designed to be high level
/ abstract (rather than opinionated about a specific UI structure), to
enable different [=user agents=] to offer different UI experiences and
for them to evolve independently over time.

Its members have the following semantics:
<dl dfn-type="dict-member" dfn-for="IdentityProviderBranding">
    :   <dfn>background_color</dfn>
    ::  Background [=color=] for [=IDP=]-branded widgets such as buttons.
    :   <dfn>color</dfn>
    ::  [=color=] for text on [=IDP=] branded widgets.
    :   <dfn>icons</dfn>
    ::  A list of {{IdentityProviderIcon}} objects.
</dl>

Note: The branding preferences are deliberately designed to be high level
/ abstract (rather than opinionated about a specific UI structure), to
enable different [=user agents=] to offer different UI experiences and
for them to evolve independently over time.


The {{IdentityProviderIcon}} has members with the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderIcon">
    :   <dfn>url</dfn>
    ::  The url pointing to the icon image, which must be square and single resolution
        (not a multi-resolution .ico). The icon needs to comply with the
        [maskable](https://www.w3.org/TR/appmanifest/#icon-masks) specification.
    :   <dfn>size</dfn>
    ::  The width/height of the square icon. The size may be omitted if the icon is in a vector
        graphic format (like SVG).
</dl>

Note: the [=user agent=] reserves a square size for the icons provided by the developer. If the
developer provides an icon that is not square, the [=user agent=] may choose to not display it at
all, trim the icon and show a square portion of it, or even transform it into a square icon and show
that.

The <dfn>color</dfn> is a subset of CSS <<color>> syntax, namely <<hex-color>>s, ''hsl()''s, ''rgb()''s and <<named-color>>.

For example:

<div class=example>
```json
{
  "accounts_endpoint": "/accounts",
  "client_metadata_endpoint": "/metadata",
  "id_assertion_endpoint": "/assertion",
  "branding": {
    "background_color": "green",
    "color": "0xFFEEAA",
    "icons": [{
      "url": "https://idp.example/icon.ico",
      "size": 25
    }]
  }
}
```
</div>

<!-- ============================================================ -->
## Accounts List ## {#idp-api-accounts-endpoint}
<!-- ============================================================ -->

The accounts list endpoint provides the list of accounts the user has at the [=IDP=].

The accounts list endpoint is fetched
(a) **with** [=IDP=] cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(c) **without** a [[RFC9110#field.referer|Referer]] header, and
(d) **without** following [[RFC9110#field.location|HTTP redirects]].

For example:

<div class=example>
```http
GET /accounts_list HTTP/1.1
Host: idp.example
Accept: application/json
Cookie: 0x23223
Sec-Fetch-Dest: webidentity
```
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderAccountList}} without an exception.


<xmp class="idl">
dictionary IdentityProviderAccount {
  required USVString id;
  required USVString name;
  required USVString email;
  USVString given_name;
  USVString picture;
  sequence<USVString> approved_clients;
};
dictionary IdentityProviderAccountList {
  sequence<IdentityProviderAccount> accounts;
};
</xmp>

Every {{IdentityProviderAccount}} is expected to have members with the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderAccount">
    :   <dfn>id</dfn>
    ::  The account unique identifier.
    :   <dfn>name</dfn>
    ::  The user's full name.
    :   <dfn>email</dfn>
    ::  The user's email address.
    :   <dfn>given_name</dfn>
    ::  The user's given name.
    :   <dfn>picture</dfn>
    ::  URL for the account's picture.
    :   <dfn>approved_clients</dfn>
    ::  A list of [=RP=]s (in the form of [=Client ID=]s) this account is already registered with.
        Used in the [=request permission to sign-up=] to allow the [=IDP=] to control whether to show
        the [=Privacy Policy=] and the [=Terms of Service=].
</dl>

For example:

<div class=example>
```json
{
 "accounts": [{
   "id": "1234",
   "given_name": "John",
   "name": "John Doe",
   "email": "john_doe@idp.example",
   "picture": "https://idp.example/profile/123",
   "approved_clients": ["123", "456", "789"]
  }, {
   "id": "5678",
   "given_name": "Johnny",
   "name": "Johnny",
   "email": "johnny@idp.example",
   "picture": "https://idp.example/profile/456"
   "approved_clients": ["abc", "def", "ghi"]
  }]
}
```
</div>

Issue: [Clarify](https://github.com/fedidcg/FedCM/issues/218) the IDP API response when the user is not signed in.

<!-- ============================================================ -->
## Client Metadata ## {#idp-api-client-id-metadata-endpoint}
<!-- ============================================================ -->

The client metadata endpoint provides metadata about [=RP=]s.

The client medata endpoint is fetched
(a) **without** cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(c) **with** a [[RFC9110#field.referer|Referer]] header indicating the [=RP=]'s origin
    (as if [[referrer-policy#referrer-policy-strict-origin|Referer-Policy: strict-origin]]
    was in use), and
(d) **without** following [[RFC9110#field.location|HTTP redirects]].

The user agent also passes the **client_id**.

For example:

<div class=example>
```http
GET /client_medata?client_id=1234 HTTP/1.1
Host: idp.example
Referer: https://rp.example/
Accept: application/json
Sec-Fetch-Dest: webidentity
```
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderClientMetadata}} without an exception.

<xmp class="idl">
dictionary IdentityProviderClientMetadata {
  USVString privacy_policy_url;
  USVString terms_of_service_url;
};
</xmp>

The {{IdentityProviderClientMetadata}} object's members have the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderClientMetadata">
    :   <dfn>privacy_policy_url</dfn>
    ::  A link to the [=RP=]'s [=privacy policy=].
    :   <dfn>terms_of_service_url</dfn>
    ::  A link to the [=RP=]'s [=terms of service=].
</dl>

For example:

<div class=example>
```json
{
  "privacy_policy_url": "https://rp.example/clientmetadata/privacy_policy.html",
  "terms_of_service_url": "https://rp.example/clientmetadata/terms_of_service.html"
}
```
</div>

<!-- ============================================================ -->
## Identity Assertions ## {#idp-api-id-assertion-endpoint}
<!-- ============================================================ -->

The identity assertion endpoint is responsible for [=minting=] a new [=token=] that contains signed assertions about the user.

The identity assertion endpoint is fetched

(a) as a **POST** request,
(b) **with** [=IDP=] cookies,
(c) **with** a [[RFC9110#field.referer|Referer]] header indicating the [=RP=]'s origin
    (as if [[referrer-policy#referrer-policy-strict-origin|Referer-Policy: strict-origin]]
    was in use),
(d) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(e) **without** following [[RFC9110#field.location|HTTP redirects]].

It will also contain the following parameters in the request body `application/x-www-form-urlencoded`:

<dl dfn-type="argument" dfn-for="id_assertion_endpoint_request">
    :   <dfn>client_id</dfn>
    ::  The [=RP=]'s [=client id=].
    :   <dfn>nonce</dfn>
    ::  The request nonce
    :   <dfn>account_id</dfn>
    ::  The account identifier that was selected.
    :   <dfn>disclosure_text_shown</dfn>
    ::  Whether the user agent has explicitly shown to the user what specific information the
        [=IDP=] intends to share with the [=RP=] (e.g. "idp.example will share your name, email...
        with rp.example"), used by the [=request permission to sign-up=] algorithm for new users but
        not by the [=sign-in=] algorithm for returning users.
</dl>

For example:

<div class=example>
```http
POST /fedcm_assertion_endpoint HTTP/1.1
Host: idp.example
Referer: https://rp.example/
Content-Type: application/x-www-form-urlencoded
Cookie: 0x23223
Sec-Fetch-Dest: webidentity
account_id=123&client_id=client1234&nonce=Ct60bD&disclosure_text_shown=true
```
</div>

<div class=idp-normative-text>
An [=IDP=] MUST check the referrer to ensure that a malicious [=RP=] does not receive an ID token
corresponding to another [=RP=]. In other words, the [=IDP=] MUST check that the referrer is
represented by the [=client id=]. As the [=client ids=] are [=IDP=]-specific, the [=user agent=]
cannot perform this check.
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderToken}} without an exception.

<xmp class="idl">
dictionary IdentityProviderToken {
  required USVString token;
};
</xmp>

Every {{IdentityProviderToken}} is expected to have members with the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderToken">
    :   <dfn>token</dfn>
    ::  The resulting [=token=].
</dl>

The content of the [=token=] is opaque to the user agent and can contain
anything that the [=Identity Provider=] would like to pass to the
[=Relying Party=] to facilitate the login. For this reason the [=Relying Party=]
is expected to be the party responsible for validating the [=token=] passed 
along from the [=Identity Provider=] using the appropriate token validation 
algorithms defined. One example of how this might be done is defined 
in [[OIDC-Connect-Core#IDTokenValidation]].

NOTE: For [=Identity Providers=], it is worth considering how
[portable](https://github.com/fedidcg/FedCM/issues/314) accounts are.
Portability is left entirely up to [=Identity Providers=], who can choose
between a variety of different mechanisms to accomplish it
(e.g. [OIDC's Account Porting](https://openid.net/specs/openid-connect-account-porting-1_0.html)).

For example:

<div class=example>
```json
{
  "token" : "eyJC...J9.eyJzdWTE2...MjM5MDIyfQ.SflV_adQssw....5c"
}
```
</div>

<!-- ============================================================ -->
# The Relying Party API # {#rp-api}
<!-- ============================================================ -->

[=RPs=] expose a [[#rp-api-logout-endpoint]] to facilitate with [[#use-cases-idp-sign-out]].

<!-- ============================================================ -->
## Logout ## {#rp-api-logout-endpoint}
<!-- ============================================================ -->

When [=IDP=]s call the [[#browser-api-idp-sign-out]] API, every [=RP=] gets a
chance to log the user out (e.g. clear cookies, clear local storage)
via the logout endpoint.

The logout endpoint is an endpoint that is registered with the [=IDP=]
[=out-of-band=].

The logout endpoint is called
(a) with a **GET** and
(b) with the [=RP=]'s cookies.

Note: the logout API introduces a credentialed request from the [=IDP=] to
the [=RP=]s, so it exposes a potential tracking surface area. It is a fairly
limited and controlled tracking area because the logout API is only available
when accounts **and** sessions are already established between the [=IDP=] and
the [=RP=].

<!-- ============================================================ -->
# The Browser API # {#browser-api}
<!-- ============================================================ -->

The Browser API exposes APIs to [=RP=]s and [=IDP=]s to call and intermediates
the exchange of the user's identity.

The Sign-up and Sign-in APIs are used by the [=Relying Party=]s to ask the browser
to intermediate the relationship with the [=Identity Provider=] and the
provisioning of a [=token=].

NOTE: The [=Relying Party=] makes no delineation between Sign-up and Sign-in, but
rather calls the same API indistinguishably.

If all goes well, the [=Relying Party=] receives back an {{IdentityCredential}}
which contains a [=token=] in the form of a signed [[JWT]] which it can use to
authenticate the user.

<div class=example>
```js
const credential = await navigator.credentials.get({
  identity: {
    providers: [{
      configURL: "https://idp.example/manifest.json",
      clientId: "123",
    }]
  }
});
```
</div>

To do so, this specification does three things:

First, it introduces a new {{Credential}} type, called {{IdentityCredential}}.

Second, it introduces an extension to {{CredentialRequestOptions}}.

Lastly, it overrides {{IdentityCredential}}'s implementation of
{{Credential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}.

<!-- ============================================================ -->
## The State Machine ## {#browser-api-state-machine}
<!-- ============================================================ -->

Each [=user agent=] keeps track of a global <dfn>state machine map</dfn>, an initially empty
[=map=]. The [=map/keys=] in the [=state machine map=] are triples of the form (|rp|, |idp|, |account|) where |rp| is
the [=/origin=] of the [=RP=], |idp| is the [=/origin=] of the [=IDP=], and |account| is a string representing
an account identifier. The [=map/values=] in the [=state machine map=] are <dfn>AccountState</dfn> objects which have
the following properties:

<dl dfn-type="argument" dfn-for="AccountState">
    :   <dfn>registration state</dfn>
    ::  Keeps track of whether the user agent is aware that the user has registered an account on the
        [=RP=] with the [=IDP=] or not.
         Can be [=registered=] or [=unregistered=] (by default).
    :   <dfn>allows logout</dfn>
    ::  Boolean which keeps track of whether the user agent would allow the |account| to be logged
        out via {{IdentityCredential/logoutRPs()}}. It is initialized to false by default. Note that
        this value being true does not imply that the user is logged in to the [=RP=] with the
        account, it merely implies that {{IdentityCredential/logoutRPs()}} has not yet been called
        on this account after the last successful {{IdentityCredential}} creation with this account.
</dl>

TODO: add an ASCII image to explain how the states fit into the algorithms.

<!-- ============================================================ -->
## The IdentityCredential Interface ## {#browser-api-identity-credential-interface}
<!-- ============================================================ -->

This specification introduces a new type of {{Credential}}, called an {{IdentityCredential}}:

<pre class="idl">
  [Exposed=Window, SecureContext]
  interface IdentityCredential : Credential {
    readonly attribute USVString? token;
  };
</pre>

<dl>
    :   <b>{{IdentityCredential/token}}</b>
    ::  The {{IdentityCredential/token}}'s attribute getter returns the value it is set to.
        It represents the minted [=token=] provided by the [=IDP=].
</dl>

The main entrypoint in this specification is through the entrypoints exposed
by the [[CM]] API.

<!-- ============================================================ -->
## The CredentialRequestOptions ## {#browser-api-credential-request-options}
<!-- ============================================================ -->

This specification starts by introducing an extension to the
{{CredentialRequestOptions}} object:

<pre class="idl">
  partial dictionary CredentialRequestOptions {
    IdentityCredentialRequestOptions identity;
  };
</pre>

The {{IdentityCredentialRequestOptions}} contains a list of
{{IdentityProviderConfig}}s that the [=Relying Party=] supports and has
pre-registered with (i.e. it has a `clientId`).

<xmp class=idl>
dictionary IdentityCredentialRequestOptions {
  sequence<IdentityProviderConfig> providers;
};
</xmp>

Each {{IdentityProviderConfig}} represents an [=Identity Provider=] that
the [=Relying Party=] supports (e.g. that it has a pre-registration agreement with).

<xmp class=idl>
dictionary IdentityProviderConfig {
  required USVString configURL;
  required USVString clientId;
  USVString nonce;
};
</xmp>

<dl>
    :   <b>{{IdentityProviderConfig/configURL}}</b>
    ::  The URL of the configuration file for the identity provider.
    :   <b>{{IdentityProviderConfig/clientId}}</b>
    ::  The [=client id=] provided to the [=RP=] out of band by the [=IDP=]
    :   <b>{{IdentityProviderConfig/nonce}}</b>
    ::  A random number of the choice of the [=RP=]. It is generally used to associate a client
        session with a [=token=] and to mitigate replay attacks. Therefore, this value should have
        sufficient entropy such that it would be hard to guess.
</dl>

<!-- ============================================================ -->
## The <code>\[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</code> internal method ## {#browser-api-rp-sign-in}
<!-- ============================================================ -->

The {{Credential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}
algorithm runs in parallel inside the [[CM#algorithm-request]] to request credentials and returns a
set of {{IdentityCredential}} for the requested [=Identity Provider=]s.

This [=internal method=] accepts three arguments:

<dl dfn-type="argument" dfn-for="IdentityCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">
    :   <dfn>origin</dfn>
    ::  This argument is the [=relevant settings object=]'s
         [=environment settings object/origin=], as determined by the
         calling {{CredentialsContainer/get()}} implementation, i.e.,
         {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a>
         abstract operation.
    :   <dfn>options</dfn>
    ::  This argument is a {{CredentialRequestOptions}} object whose
        {{CredentialRequestOptions/identity}} member contains an
        {{IdentityCredentialRequestOptions}} object specifying the exchange options.
    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the
         caller's [=environment settings object=] is
         [=same-origin with its ancestors=]. It is [FALSE] if caller is cross-origin.

        Note: Invocation of this [=internal method=] indicates that it was allowed by
        [=permissions policy=], which is evaluated at the [[!CREDENTIAL-MANAGEMENT-1]] level.
        See [[#permissions-policy-integration]]. As such,
            <var ignore=''>sameOriginWithAncestors</var> is unused.

</dl>

NOTE: The {{CredentialRequestOptions/mediation}} flag is currently not used.

The {{CredentialRequestOptions/signal}} is used as an abort signal for the
requests.

<div algorithm>
When the {{IdentityCredential}}'s
<dfn for="IdentityCredential" method>\[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</dfn>
algorithm is invoked, the user agent MUST execute the following steps. This returns an
{{IdentityCredential}} (or throws an error to the caller).

    1. Assert: These steps are running [=in parallel=].
    1. Assert: |options|["{{CredentialRequestOptions/identity}}"]["{{IdentityCredentialRequestOptions/providers}}"] [=map/exists=].
    1. Assert: |options|["{{CredentialRequestOptions/identity}}"]["{{IdentityCredentialRequestOptions/providers}}"] [=list/size=] is 1.

          Issue: Support choosing accounts from multiple [=Identity Provider=]s, as described [here](https://github.com/fedidcg/FedCM/issues/319).
    1. Run {{WindowOrWorkerGlobalScope/setTimeout()}} passing a [=task=] which throws a
        {{NetworkError}}, after a timeout of 60 seconds.

        Issue: Do not use {{WindowOrWorkerGlobalScope/setTimeout()}} directly, as that is not correct. See the relevant
        [issue](https://github.com/fedidcg/FedCM/issues/389).

        Note: the purpose of having a timer here is to avoid leaking the reason causing this
        method to throw an error. If there was no such timer, the developer could easily infer
        whether the user has an account with the [=IDP=] or not, or whether the user closed the UI without granting permission to share the [=IDP=] account information with the [=RP=].
    1. Let |provider| be |options|["{{CredentialRequestOptions/identity}}"]["{{IdentityCredentialRequestOptions/providers}}"][0].
    1. Let |credential| be the result of running [=create an IdentityCredential=] with |provider| and
        |globalObject|.

        Note: The |globalObject| is not currently passed onto the
        {{Credential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}
        algorithm. See <a href="https://github.com/w3c/webappsec-credential-management/issues/210">issue</a>.
    
    1. If |credential| is failure, [=queue a global task=] on the [=DOM manipulation task source=]
        to throw a new "{{NetworkError}}" {{DOMException}}.
</div>

<div algorithm>
To <dfn>create an IdentityCredential</dfn> given an {{IdentityProviderConfig}}
|provider| and a |globalObject|, run the following steps. This returns an {{IdentityCredential}} or
failure.
    1. Assert: These steps are running [=in parallel=].
    1. Let |config| be the result of running [=fetch the config file=] with |provider| and
        |globalObject|.
    1. If |config| is failure, return failure.
    1. Let |accountsList| be the result of [=fetch the accounts list=] with |config|, |provider|,
        and |globalObject|.
    1. For each |account| in |accountsList|:
        1. If |account|["{{IdentityProviderAccount/picture}}"] is present,
            [=fetch the account picture=] with |account| and |globalObject|.

        Note: The [=user agent=] may choose to show UI which does not initially require fetching the
        account pictures. In these cases, the [=user agent=] may delay these fetches until they are
        needed.
    1. If |accountsList|'s size is 1:
        1. Let |account| be |accountsList|[0].
        1. Let |accountState| be the result of running the [=compute account state=] algorithm
            given |provider|, |account|, and |globalObject|.
        1. If |accountState|'s {{AccountState/registration state}} is [=unregistered=],
            let |permission| be the result of running [=request permission to sign-up=] algorithm
            with |account|, |accountState|, |config|, |provider|, and |globalObject|.
        1. Otherwise, show a dialog to request user permission to sign in via |account|, and set the
            result in |permission|.
        1. If |permission|, [=sign-in=] with |accountState|.
    1. Otherwise:
        1. Let |account| be the result of running the [=select an account=] from the
            |accountsList|.
        1. If |account| is failure, return failure.
        1. Let |accountState| be the result of running the [=compute account state=] algorithm
            given |provider| and |account|.
        1. If |accountState|'s {{AccountState/registration state}} is [=unregistered=]:
            1. Let |permission| be the result of running the [=request permission to sign-up=]
                algorithm with |account|, |accountState|, |config|, |provider|, and |globalObject|.
            1. If |permission|, [=sign-in=] with |accountState|.
        1. Otherwise, [=sign-in=] with |accountState|.
    1. Wait until the [=user agent=]'s dialog is closed.
    1. If |accountState|'s {{AccountState/registration state}} is [=unregistered=] then return
        failure.
    1. Let |credential| be the result of running the [=fetch an identity assertion=] algorithm with
        |accountState|, |account|'s {{IdentityProviderAccount/id}}, |provider|, |config|, and
        |globalObject|.
    1. Return |credential|.
</div>

<div algorithm>
To <dfn>parse url</dfn> given a {{USVString}} |stringUrl|, a |globalObject|, and an optional
|baseUrl| (default null), run the following steps. This returns a [=/URL=] or failure.
    1. Let |configUrl| be null.
    1. [=Queue a global task=] on the [=DOM manipulation task source=] given |globalObject| to set
        |configUrl| to the result of running [=url parser=] with |stringUrl| and |baseUrl|.

        Note: We queue a task since the [=url parser=] needs to be run within a task, not
        [=in parallel=].

    1. Wait for |configUrl| to be set.
    1. Return |configUrl|.
</div>

<div algorithm>
To <dfn>fetch request</dfn> given a [=/request=] |request|, |globalObject|, and an algorithm
|processResponseConsumeBody|, run the following steps:
  1. [=Queue a global task=] on the [=network task source=] given |globalObject| to:
      1. [=Fetch=] |request| with <a spec=fetch>processResponseConsumeBody</a> set to
          |processResponseConsumeBody|.

  Note: We queue a task since the [=fetch=] needs to be run within a task, not [=in parallel=].
</div>

<div algorithm>
To <dfn>fetch the config file</dfn> given an {{IdentityProviderConfig}} |provider| and
|globalObject|, run the following steps. This returns an {{IdentityProviderAPIConfig}}.
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. If |configUrl| is failure, return failure.
    1. Run a [[!CSP]] check with a [[CSP#directive-connect-src|connect-src]] directive on the URL
        passed as |configUrl|. If it fails, return failure.
    1. If |configUrl| is not a [=potentially trustworthy URL=], return failure.
    1. Let |rootUrl| be a new [=/URL=].
    1. Set |rootUrl|'s [=url/scheme=] to |configUrl|'s [=url/scheme=].
    1. Set |rootUrl|'s [=url/host=] to |configUrl|'s [=url/host=]'s [=host/registrable domain=].
    1. Set |rootUrl|'s [=url/path=] to the <a>list</a> Â«".well-known", "web-identity"Â».
    1. If |rootUrl| is not a [=potentially trustworthy URL=], return failure.
    1. Let |wellKnownRequest| be a new [=/request=] as follows:

        :  [=request/URL=]
        :: |rootUrl|
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/json`
        :  [=request/referrer policy=]
        :: "no-referrer"
        :  [=request/credentials mode=]
        :: "omit"

        <p class=issue>The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
        with [=request/mode=] set to "unsafe-no-cors". See the relevant
        [pull request](https://github.com/whatwg/fetch/pull/1533) for details.</p>

    1. Let |config| be null.
    1. [=Fetch request=] with |wellKnownRequest|, |globalObject|, and <var ignore=>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderWellKnown}},
            |discovery|.
        1. If the [=list/size=] of |discovery|["{{IdentityProviderWellKnown/provider_urls}}"]
            is greater than 1, set |config| to failure.

            Issue: [relax](https://github.com/fedidcg/FedCM/issues/333) the size of the
            provider_urls array.

        1. If |discovery|["{{IdentityProviderWellKnown/provider_urls}}"][0]
            [=string/is=] NOT equal to |provider|'s {{IdentityProviderConfig/configURL}}, set
            |config| to failure.

    1. Let |configRequest| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |configUrl|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/json`
        :  [=request/referrer policy=]
        :: "no-referrer"
        :  [=request/credentials mode=]
        :: "omit"

    1. [=Fetch request=] with |configRequest|, |globalObject|, and <var ignore=>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderAPIConfig}} stored
            in |config|, unless |config| has been set to failure.
    1. Wait for both fetch responses to be completed.
    1. Return |config|.
</div>

NOTE: We use a two-tier file system in order to prevent the [=IDP=] to easily determine the [=RP=]
that a user is visiting by encoding the information in the config file path. We solve this issue by
requiring a well-known file to be on the root of the [=IDP=]. The config file itself can be anywhere, but
it will not be used if the user agent does not find it in the well-known file. This allows the [=IDP=]
to keep their actual config files on an arbitary path while allowing the user agent to prevent config file
path manipulation to fingerprint (for instance, by including the RP in the path). See
[[#manifest-fingerprinting]].

<div algorithm>
To <dfn>fetch the accounts list</dfn> given an {{IdentityProviderAPIConfig}} |config|, an
{{IdentityProviderConfig}} |provider|, and |globalObject|, run the following steps. This returns an
{{IdentityProviderAccountList}}.
    1. Let |accountsUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|["{{IdentityProviderAPIConfig/accounts_endpoint}}"], and |globalObject|.
    1. If |accountsUrl| is failure, return an empty list.
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |accountsUrl|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/json`
        :  [=request/referrer policy=]
        :: "no-referrer"
        :  [=request/credentials mode=]
        :: "include"

        Issue: The credentialed fetch in this algorithm can lead to a timing attack that leaks the
        user's identities before the user grants permission. This is an active area of investigation
        that is being explored [here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1089040953).

    1. Let |accountsList| be null.
    1. [=Fetch request=] with |request|, |globalObject|, and <var ignore=>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderAccountList}}, and
            store the result in |accountsList|.

        Issue: We should validate the accounts list returned here for repeated ids, as described
        [here](https://github.com/fedidcg/FedCM/issues/336).

    1. Wait for |accountsList| to be set.
    1. Return |accountsList|.
</div>

<div algorithm>
To <dfn>fetch the account picture</dfn> given an {{IdentityProviderAccount}} |account| and a
|globalObject|, run the following steps:
    1. Let |pictureRequest| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |account|["{{IdentityProviderAccount/picture}}"]
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "image"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/referrer policy=]
        :: "no-referrer"
        :  [=request/credentials mode=]
        :: "omit"

    1. [=Fetch request=] with |pictureRequest|, |globalObject|, and <var ignore=>processResponseConsumeBody</var>
        set to the following steps given a <var ignore=''>response</var> and a |responseBody|:
        1. If |responseBody| is null or failure, the user agent may choose an arbitrary placeholder image
            and associate it with the |account|.
        1. Otherwise, decode |responseBody| into an image, and associate it with |account| if successful. This
            allows the user agent to use the decoded image in a dialog displaying |account|.
</div>

<div algorithm>
To <dfn>fetch an identity assertion</dfn> given an [=AccountState=] |accountState|, a {{USVString}}
    |accountId|, an {{IdentityProviderConfig}} |provider|, an {{IdentityProviderAPIConfig}}
    |config|, and |globalObject|, run the following steps. This returns an {{IdentityCredential}}.
    1. Assert |accountState|'s {{AccountState/registration state}} is [=registered=].
    1. Assert |accountState|'s {{AccountState/allows logout}} is true.
    1. Let |idTokenUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|["{{IdentityProviderAPIConfig/id_assertion_endpoint}}"], and |globalObject|.
    1. If |idTokenUrl| is failure, return failure.
    1. Let |requestBody| be a [=string=] resulting in concatenating "client_id=",
        |provider|'s {{IdentityProviderConfig/clientId}}, "&nonce=",
        |provider|'s {{IdentityProviderConfig/nonce}}, "&account_id=", and |accountId|.
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |idTokenUrl|
        :  [=request/mode=]
        :: "POST"
        :  [=request/body=]
        :: the [=UTF-8 encode=] of |requestBody|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/x-www-form-urlencoded`
        :  [=request/referrer=]
        :: [=RP=]'s URL (TODO).
        :  [=request/credentials mode=]
        :: "include"

    1. Let |credential| be null.
    1. [=Fetch request=] with |request|, |globalObject|, and <var ignore=>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderToken}}, |token|.
        1. Let |credential| be a new {{IdentityCredential}} given |globalObject|'s
            <a for="global object">realm</a>.
        1. Set |credential|'s {{IdentityCredential/token}} to |token|.
    1. Wait for |credential| to be set.
    1. Return |credential|.
</div>

<div algorithm>
To <dfn>compute account state</dfn> given an {{IdentityProviderConfig}} |provider|, an
{{IdentityProviderAccount}} |account|, and a |globalObject|, run the following steps. This returns
an [=AccountState=].
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. Let |idpOrigin| be the [=/origin=] corresponding to |configUrl|.
    1. Let |rpOrigin| be |globalObject|'s [=associated Document=]'s [=Document/origin=].
    1. Let |accountId| be |account|'s {{IdentityProviderAccount/id}}.
    1. Let |triple| be (|rpOrigin|, |idpOrigin|, |accountId|).
    1. If [=state machine map=][|triple|] does not exist, set [=state machine map=][|triple|] to a
        new [=AccountState=].
    1. Let |accountState| be [=state machine map=][|triple|].
    1. Return |accountState|.
</div>

<div algorithm>
When <dfn>computing the manifest URL</dfn> given an {{IdentityProviderConfig}} |provider|, a
[=string=] |manifestString|, and |globalObject|, perform the following steps. This returns a
<a spec=url for=/>URL</a> or failure.
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. Let |manifestUrl| be the result of running [=parse url=] given |manifestString| and
        |globalObject|.
    1. If |manifestUrl| is failure, let |manifestUrl| be the result of running [=parse url=]
        given |manifestString| (the relative URL), |globalObject|, and |configUrl| (the base URL).
        Wait until |manifestUrl| is set again.

        Note: This means the we allow passing the manifest string as either an absolute or relative
        URL.

    1. If |manifestUrl| is failure, return failure.
    1. If |manifestUrl| is not [=same origin=] with |configUrl|, return failure.
    1. If |manifestUrl| is not a [=potentially trustworthy URL=], return failure.
    1. Return |manifestUrl|.
</div>

<div algorithm>
To <dfn>extract the JSON fetch response</dfn> given a <a spec=fetch for=/>response</a> |response|
and a |responseBody|, run the following steps. This returns an [=ordered map=].
    1. Assert: These steps are running on the [=networking task source=].
    1. If |response| is a [=network error=] or its [=response/status=] is not an [=ok status=],
        throw a new "{{NetworkError}}" {{DOMException}}.
    1. Let |json| be the result of [=parse JSON bytes to an Infra value=] passing |responseBody|.
    1. If |json| is a parsing exception, or if |json| is not an [=ordered map=], throw a new
        "{{NetworkError}}" {{DOMException}}.
    1. Return |json|.
</div>

<div algorithm>
To <dfn>request permission to sign-up</dfn> the user with a given an {{IdentityProviderAccount}} |account|, an
[=AccountState=] |accountState|, an {{IdentityProviderAPIConfig}} |config|, an {{IdentityProviderConfig}}
|provider|, and a |globalObject|, run the following steps. This returns a boolean.
    1. Assert: These steps are running [=in parallel=].
    1. Let |metadata| be the result of running [=fetch the client metadata=] with |config|,
        |provider|, and |globalObject|.
    1. If |metadata| is not null, |metadata|["{{IdentityProviderClientMetadata/privacy_policy_url}}"]
        is defined and the |provider|'s {{IdentityProviderConfig/clientId}} is not in the list of
        |account|["{{IdentityProviderAccount/approved_clients}}"], then display the
        |metadata|["{{IdentityProviderClientMetadata/privacy_policy_url}}"] link.
    1. If |metadata| is not null, |metadata|["{{IdentityProviderClientMetadata/terms_of_service_url}}"]
        is defined, and the |provider|'s {{IdentityProviderConfig/clientId}} is not in the list of
        |account|["{{IdentityProviderAccount/approved_clients}}"], then display the
        |metadata|["{{IdentityProviderClientMetadata/terms_of_service_url}}"] link.
    1. Prompt the user to gather explicit intent to create an account. The user agent MAY use the
        {{IdentityProviderBranding}} to inform the style choices of its UI.
    1. If the user does not grant permission, return false.
    1. Change |accountState|'s {{AccountState/registration state}} from [=unregistered=] to
        [=registered=].
    1. Change |accountState|'s {{AccountState/allows logout}} from false to true.
    1. Return true.
</div>

<div algorithm>
To <dfn noexport>fetch the client metadata</dfn> given an {{IdentityProviderAPIConfig}} |config| and
an {{IdentityProviderConfig}} |provider|, run the following steps. This returns an
{{IdentityProviderClientMetadata}} or null.
    1. Let |clientMetadataUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|["{{IdentityProviderAPIConfig/client_metadata_endpoint}}"], and |globalObject|.
    1. If |clientMetadataUrl| is failure, return null.
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |clientMetadataUrl|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/json`
        :  [=request/referrer=]
        :: [=RP=]'s URL (TODO).
        :  [=request/credentials mode=]
        :: "omit"

    1. Let |metadata| be null.
    1. [=Fetch request=] with |request|, |globalObject|, and <var ignore=>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderClientMetadata}},
            and store the result in |metadata|.
    1. Wait until |metadata| is set.
    1. Return |metadata|.
</div>

<div algorithm>
To <dfn>select an account</dfn> given an |accountsList|, run the following steps. This returns an
{{IdentityProviderAccount}} or failure.
    1. Assert |accountsList|'s [=list/size=] is greater than 1.
    1. Display an account chooser displaying the options from |accountsList|.
    1. Let |account| be the {{IdentityProviderAccount}} of the account that the user
        manually selects from the accounts chooser, or failure if no account is selected.
    1. Return |account|.
</div>

<div algorithm>
To <dfn>sign-in</dfn> the user with a given an [=AccountState=] |accountState|:
    1. Assert that |accountState|'s {{AccountState/registration state}} is [=registered=]
    1. Change |accountState|'s {{AccountState/allows logout}} from false to true.
</div>

<!-- ============================================================ -->
### IDP Sign-out ### {#browser-api-idp-sign-out}
<!-- ============================================================ -->

Note: The API specified in this section is not launched in any user agent,
and as such should be considered very experimental and subject to change.

In enterprise scenarios, it is common for the user to want to clear all of
their existing sessions in all of the [=Relying Party=]s they are logged into.

It does so by being navigated to their [=Identity Provider=] who initiates
what's called a [[Front-Channel-Logout]].

The browser exposes an API that takes the list of [=Relying Party=]s that the
[=Identity Provider=] wants to initiate the logout which are loaded in parallel
with cookies.

Each [=Relying Party=] endpoint is responsible for clearing its local state
(e.g. clearing cookies).

After the completion of this API, the user's session is cleared and will go
through an [[#use-cases-sign-in]] upon return.

<script type="text/typogram">
.---------------------------------.       .---------------------------------.
| .-----------------------------. |       | .-----------------------------. |
| | "https://rp.example"        | |       | | "https://idp.example"       | |
| '-----------------------------' |       | '-----------------------------' |
| .-----------------------------. |       | .-----------------------------. |
| |                             | |       | |                             | |
| |   Welcome to my website!    | |       | |  John, we are logging out   | |
| |                             | |       | |  of the relying parties.    | |
| |                             | |       | |                             | |
| +-----------------------------+ |       | |  +~~~~~~~~~~~~~~~~~~~~~~~+  | |
| |   Sign-in to rp.example     | |       | |  :"<script>"             :  | |
| |     with idp.example?       | |       | |  :" IdentityCredential. ":  | |
| |                             | |       | |  :"    logoutRPs([{     ":  | |
| | .----.                      | |       | |  :"       url: ...      ":  | |
| | | :) | "John Doe"           | |  -->  | |  :"       accountId: ...":  | |
| | '----' "john@email.com"     | |       | |  :"    }, {             ":  | |
| |                             | |       | |  :"       ...           ":  | |
| | +-------------------------+ | |       | |  :"    }]);             ":  | |
| | |     Continue as John    | | |       | |  :"<\/script>"           :  | |
| | +------------+------------+ | |       | |  +~~~~~~~~~~~+~~~~~~~~~~~+  | |
| '--------------|--------------' |       | '--------------|--------------' |
'----------------|----------------'       '----------------|----------------'
                 |                                         |
                 |                                         |
                 |        +------------------------+       |        +-------+
                 |        |                        |       |        |       |
                 +------->|     Registered RPs     |-------+------->| Queue |
                          |                        |                |       |
                          +------------------------+                +-------+


</script>

<div class=example>
```js
await IdentityCredential.logoutRPs([{
    url: "https://rp1.example",
    accountId: "123"
  }, {
    url: "https://rpN.example",
    accountId: "456"
  }]);
```
</div>

[=IDP=]s can call {{IdentityCredential/logoutRPs()}} to log the user out of the [=RP=]s they are
signed into.

<xmp class=idl>
dictionary IdentityCredentialLogoutRPsRequest {
  required USVString url;
  required USVString accountId;
};

[Exposed=Window, SecureContext]
partial interface IdentityCredential {
  static Promise<undefined> logoutRPs(sequence<IdentityCredentialLogoutRPsRequest> logoutRequests);
};
</xmp>

<div algorithm=logoutRPs>
When the {{IdentityCredential/logoutRPs()}} method is invoked given a [=list=] of
{{IdentityCredentialLogoutRPsRequest}}s |logoutRequests|, the user agent MUST execute the following
steps. This returns a {{Promise}}.
    1. Let |promise| be a new {{Promise}}.
    1. Let |globalObject| be <a>this</a>'s <a>relevant global object</a>.
    1. [=In parallel=], perform the following steps:
        1. For each |request| in |logoutRequests|:
            1. Let |rpOrigin| be [=this=]'s [=Document/origin=].
            1. Let |idpOrigin| be |request|'s {{IdentityCredentialLogoutRPsRequest/url}}'s [=/origin=].
            1. Let |account| be |request|'s {{IdentityCredentialLogoutRPsRequest/accountId}}.
            1. Let |triple| be (|rpOrigin|, |idpOrigin|, |account|).
            1. If [=state machine map=][|triple|] does not exist, continue.
            1. Let |accountState| be [=state machine map=][|triple|].
            1. If the |accountState|'s {{AccountState/registration state}} is [=unregistered=] or
                |accountState|'s {{AccountState/allows logout}} is false, continue.
            1. Let |fetchRequest| be a new <a spec=fetch for=/>request</a> as follows:

                :  [=request/url=]
                :: |request|'s {{IdentityCredentialLogoutRPsRequest/url}}
                :  [=request/mode=]
                :: "GET"
                :  [=request/redirect mode=]
                :: "error"
                :  [=request/client=]
                :: null
                :  [=request/window=]
                :: "no-window"
                :  [=request/service-workers mode=]
                :: "none"
                :  [=request/destination=]
                :: "webidentity"
                :  [=request/origin=]
                :: a unique [=opaque origin=]
                :  [=request/credentials mode=]
                :: "include"

            1. [=Queue a global task=] on the [=network task source=]  given |globalObject|
                to [=fetch=] |fetchRequest|.
            1. Set the |accountState| {{AccountState/allows logout}} to false.
        1. [=Resolve=] |promise| with [undefined].
    1. Return |promise|.
</div>


<!-- ============================================================ -->
## Backwards Compatibility ## {#browser-api-backwards-compatibility}
<!-- ============================================================ -->

Note: go over how we are planning to deal with backwards compatibility.

<!-- ============================================================ -->
# Permissions Policy Integration # {#permissions-policy-integration}
<!-- ============================================================ -->

FedCM defines a [=policy-controlled feature=] identified by the string <code>"<dfn export>identity-credentials-get</dfn>"</code>.
Its [=default allowlist=] is `"self"`.

A {{Document}}â€™s [=Document/permissions policy=] determines whether any content
in that document is allowed to obtain a credential object using the [[#browser-api|Browser API]].
Attempting to invoke <code><a idl for="CredentialsContainer" lt="get()">navigator.credentials.get({identity:..., ...})</a></code>
in documents that are not [=allowed to use=] the [=identity-credentials-get=] feature will result
in [=a promise rejected with=] a "{{NotAllowedError}}" {{DOMException}}.

This restriction can be controlled using the mechanisms described in [[PERMISSIONS-POLICY]].

Note: Algorithms specified in [[!CREDENTIAL-MANAGEMENT-1]] perform the actual
permissions policy evaluation. This is because such policy evaluation needs to
occur when there is access to the [=current settings object=]. The [=internal method=]s
modified by this specification do not have such access since they are invoked [=in parallel=]
by {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a> abstract operation.

<!-- ============================================================ -->
# Security # {#security}
<!-- ============================================================ -->

This section provides a few of the security considerations for the FedCM API. Note that there is a
separate section for [[#privacy]] considerations.

<!-- ============================================================ -->
## Content Security Policy ## {#content-security-policy}
<!-- ============================================================ -->

The first fetches triggered by the FedCM API are the manifest list, which is public, and the
config file. Imagine a malicious script included by (and running as) the [=RP=] attempting to
execute the FedCM API calls to a malicious [=IDP=], one which is not trusted by the [=RP=]. If the
call is successful, this would introduce browser UI on the [=RP=] with sign in options into a
malicious [=IDP=]. This malicious[=IDP=] could then attempt to trick the user. The protection
against this attack is the [[!CSP]] check, which would fail because the origin of the manifest of
the malicious [=IDP=] would not be an origin included in the allowlist specified by the [[!CSP]] of
the [=RP=], hence preventing the undesired FedCM UI from being shown. Since any subsequent fetches
are same origin with respect to the config file or at least dependent on the contents of the
config file, they do not require additional checks.

The non-same-origin fetches include, for example, the brand icon. The user agent does not perform a
[[!CSP]] check on these because they are directly specified from the manifest. In addition, the
rendering of this image is performed by the user agent, and as such this image cannot affect the
[=RP=] site nor can they be inspected by the [=RP=] in any way.

<!-- ============================================================ -->
## Sec-Fetch-Dest Header ## {#sec-fetch-dest-header}
<!-- ============================================================ -->

*This section is non-normative.*

The FedCM API introduces several non-static endpoints on the [=IDP=], so these need to be protected
from XSS attacks. In order to do so, the FedCM API introduces a new value for the
<a http-header>Sec-Fetch-Dest</a> header, a [=forbidden request-header=]. The requests initiated by the FedCM API
have a `webidentity` value for this header. The value cannot be set by random websites, so the
[=IDP=] can be confident that the request was originated by the FedCM browser rather than sent by a
websites trying to run an XSS attack. An [=IDP=] must to check for this header's value in the
credentialed requests it receives, which ensures that the request was initiated by the user agent,
based on the FedCM API. A malicious actor cannot spam FedCM API calls, so this is sufficient
protection for the new [=IDP=] endpoints.

<!-- ============================================================ -->
## Browser Surface Impersonation ## {#browser-surface-impersonation}
<!-- ============================================================ -->

The FedCM API introduces new (trusted) user agent UI, and the user agent may choose to show the UI
entirely on top of the page's contents, if anything because the page was the one responsible for
this UI. This introduces a potential concern of a malicious site to try to replicate the FedCM UI,
gain the user's trust that the user is interacting with a trusted browser surface, and gather
information from the user that they would only give to the browser rather than the site (e.g.
usernames/passwords of **another** site). This would be hard to achieve because the FedCM UI uses
metadata about the user accounts of the [=IDP=], which the malicious website doesn't have access to.
If this is a malicious site, it would not know the user accounts unless the user is already
compromised. However, the site could have some guess of the user identity, so the browser is
encouraged to provide UI that is hard to replicate and that clearly presents the domains of the
parties involved in the website's FedCM call. Overall, an attacker trying to impersonate the browser
using exclusively UI that is accessible to the content area (e.g. iframes) to attempt to retrieve
sensitive information from the user would be noticeably different from the FedCM UI. Finally,
because the FedCM UI can only be queried from the top-level frame (or potentially from an iframe
with explicit permission from the top-level frame), the priviledged UI surface is only shown when
the top-level frame wants it so. A sneaky iframe cannot force the FedCM UI to occlude important
content from the main page.

<!-- ============================================================ -->
# Privacy # {#privacy}
<!-- ============================================================ -->

This section is intended to provide a comprehensive overview of the privacy risks associated with
federated identity on the web for the purpose of measuring the privacy risks and benefits of
proposed browser intermediation designs.

<!-- ============================================================ -->
## Principals ## {#privacy-principals}
<!-- ============================================================ -->

This section describes the four principals that would participate in an invocation of the API and
expectations around their behavior.

1. The [=user agent=] implements [[#browser-api]] and controls the execution contexts for the [=RP=]
    and [=IDP=] content. The [=user agent=] is assumed to be trusted by the user, and transitively
    trusted by the [=RP=] and [=IDP=].
1. [=Relying Party=]s ([=RP=]s) are websites that invoke the FedCM API for the purpose of
    authenticating a user to their account or for requesting information about that user. Since any
    site can invoke the API, [=RP=]s cannot necessarily be trusted to limit the user information it
    collects or use that information in an acceptable way.
1. [=Identity Provider=]s ([=IDP=]s) are third-party websites that are the target of a FedCM call to
    attempt to fetch a [=token=]. Usually,the [=IDP=] has a higher level of trust than the
    [=RP=] since it already has the userâ€™s personal information, but it is possible that the [=IDP=]
    might use the userâ€™s information in non-approved ways. In addition, it is possible that the
    [=IDP=] specified in the API call may not be an [=IDP=] the user knows about. In this case, it
    likely does not have personal user information in advance.
1. A [=tracker=] is a third-party website that is not an [=IDP=] but could abuse the FedCM API
    exclusively for the purpose of tracking a user as they visit various websites. A [=tracker=] may
    be injected by the [=RP=] with or without their knowledge (e.g. injected into one of the various
    script tags that the [=RP=] embeds that is loaded dynamically), but they usually do not modify
    the UI of the website, so that it is harder to detect the tracking. A [=tracker=] that
    successfully adds tracking scripts for users in various websites may then use this information
    for various purposes, such as selling the information about the user. It should not be possible
    for [=trackers=] to use the FedCM API to track users across the web.

Based on the above, the privacy discussion makes the following assumptions:

1. It is not acceptable for an [=RP=], [=IDP=], or [=tracker=] to learn that a specific user visited a
    specific site, without any permission granted by the user. That is, the [=user agent=] needs to hide the
    knowledge that a specific user identity visited a specific site from the [=RP=], [=IDP=], and
    [=trackers=]. It may share this knowledge with the [=RP=] and [=IDP=] once the user grants permission. In
    particular, the [=RP=] should not know the user identity and the [=IDP=] should not know the
    site that the user has visited before the FedCM flow gathers the user's permission to do so.
1. It is the [=user agent=]'s responsibility to determine when the user has granted permission for the
    [=IDP=] to communicate with the [=RP=] in order to provide identification for the user.
1. Once the [=user agent=] has determined that the user has granted permission to provide their
    account information to the [=RP=], it is ok for the [=IDP=] and for the [=RP=] to learn
    information about that specific user's account, as required to provide identification. The [=RP=]
    should not learn about about any other user accounts.

<!-- ============================================================ -->
## Network requests ## {#network-requests}
<!-- ============================================================ -->

The FedCM API introduces the ability for a site to ask the browser to execute a few different
network requests, as shown in the [[#high-level-design]] section. It is important for the browser
to execute these in such a way that it does not allow the user to be tracked (by an attacker
impersonating an [=IDP=]) on to the site using FedCM. The following table has information about the
network requests performed:

<script type="text/typogram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Endpoint                 â”‚ cookies â”‚ client_id â”‚ referrer â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ manifests                â”‚  no     â”‚  no       â”‚  no      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ accounts_endpoint        â”‚  yes    â”‚  no       â”‚  no      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ client_metadata_endpoint â”‚  no     â”‚  yes      â”‚  yes     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id_assertion_endpoint    â”‚  yes    â”‚  yes      â”‚  yes     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</script>

For fetches that are sent with cookies, we actually consider them equivalent to first-party fetches,
and hence include first-party cookies as if the resource was loaded as a first-party, e.g.
regardless of the
[SameSite](https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#name-the-samesite-attribute-2)
value (which is used when a resource loaded as a third-party, not first-party). This makes it easy
for an [=IDP=] to adopt the FedCM API without introducing security issues on the API, since the
[=RP=] cannot inspect the results from the fetches in any way.

We want to ensure that the FedCM fetches are all same-origin with respect to the provider specified
by the [=RP=]. The reason for this is because fetches with cookies would use the cookies from the
origin specified, so allowing arbitrary origins would introduce confusion and potential privacy
issues with regards to which cookies are shared and with whom within the FedCM flow. The easiest way
to ensure that all of these fetches remain same-origin is by disabling redirects and checking the
origin of the fetched URLs.

* The manifest fetch can't be used to track users because it is performed without cookies, [=client
    id=], or referrer. Thus, anyone could perform this fetch, and the information contained therein
    is considered public.

* The accounts fetch can't be used to track users because it is performed with cookies from the
    [=IDP=] but, importantly, without the [=client id=] or referrer. This in theory is a new power
    that the [=RP=] gains that it would not have otherwise. Preventing too many of these fetches may
    be important, but [=IDP=]s are already expected to protect against DoS attacks. In addition, the
    user agent should only allow one FedCM flow per page at any given moment, immediately rejecting
    any attempts to start another one. Since a FedCM flow can only be terminated when the user
    interacts or after a long timer, the number of fetches performed is not a concern. The [=IDP=]
    does learn a lot about the user from this fetch, but this is discussed in detail below.

* The client metadata fetch can't be used to track users too because it is performed without cookies
    from the [=IDP=], albeit with a [=client id=] and a referrer. This allows the [=IDP=] to
    communicate the relevant [=Privacy Policy=] and [=Terms of Service=] to the user agent, in case
    they need to be displayed. Again, besides possible timing attacks described here, the [=RP=]
    gains nothing from this fetch, and the [=RP=] could already perform this fetch if it wanted to
    since it involves no cookies from the [=IDP=].

* By design, the token fetch exposes the user at the website to the [=IDP=]: it is
    peformed with cookies, [=client id=], and referrer. Because of that, it is gated on the user
    interacting with the user agent UI, and enables the [=IDP=] to communicate to the [=RP=] the
    information required to perform a federated signin/signup. It is not possible for the [=RP=] or
    the [=IDP=] to force the token fetch to happen without user permission, as the user agent cannot be
    spoofed or otherwise tricked.

<!-- ============================================================ -->
## Attack Scenarios ## {#attack-scenarios}
<!-- ============================================================ -->

This section describes the scenarios in which various agents might attempt to gain user information.
It considers the possibilities when:

  * The [=RP=] is collecting information,
  * The [=IDP=] is collecting information, or
  * Both the [=RP=] and the [=IDP=] are colluding.

For the purposes of this section, a principal is considered to be participating in the collection of
information if it directly or indirectly performs actions with the aim of realizing one of the above
threats.

Note: An example of indirect collusion would be an [=RP=] importing a script supplied by an [=IDP=]
where the [=IDP=] intends to track users.

For the purpose of discussion, this document assumes that third-party cookies are **disabled** by
default and are no longer effective for use in tracking mechanisms, and also some form of
mitigations are implemented against â€˜bounce trackingâ€™ using link decoration or postMessage. Most of
these scenarios consider how user tracking might happen **without** them. See also [[RFC7258]].

<!-- ============================================================ -->
### Manifest Fingerprinting ### {#manifest-fingerprinting}
<!-- ============================================================ -->

Suppose that the FedCM API did not have a two-tier manifest (see the [=create an IdentityCredential=]
algorithm), and instead directly had a single manifest. This would introduce the following
fingerprinting attack:

<div class=example>
```js
// The following will fetch the manifest JSON file, which will know the origin of the RP :(
const cred = await navigator.credentials.get({
  identity: {
    providers: [{
      configURL: \`https://idp.example/${window.location.href}\`
    }]
  }
});
```
</div>

NOTE: You can read more about the attack described
[here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1067029200).

Here, the [=RP=] includes identifies itself when fetching the manifest from the [=IDP=]. This
coupled with the credentialed fetches that the FedCM API performs would enable the [=IDP=] to easily
track the website that the user is visiting, without requiring any permission from the user. Our
mitigation to this problem is to use the [[#idp-api-well-known]] file. We enforce a specifically named
file at the root of the [=IDP=]'s domain to ensure that the file name does not introduce
fingerprints about the [=RP=] being visited.

The whole manifest could be in this location, but we instead choose to only point to the real
manifest from there. This allows us to have flexibility in the future to allow a small constant
number of manifests, should an [=IDP=] require this in the future, instead of just a single one. It
also helps the [=IDP=]'s implementation because they any changes to the manifest are more likely to
be performed on a file located anywhere, as opposed to the root of the domain, which may have more
constraints in terms of ease of update.

<!-- ============================================================ -->
### Timing Attacks ### {#timing-attacks}
<!-- ============================================================ -->

In the timing attack, the [=RP=] and [=IDP=] collude to allow the [=IDP=] to compute the ([=RP=]'s
origin, [=IDP=]'s user identity) pair without the user's permission. This attack is not deterministic:
there is room for statistical error because it requires stitching together two separate pieces of
information to track the user. However, it is important to mitigate this attack and ensure that
it's economically impractical to perform. In this attack, we assume that network requests do not
have large fingerprinting vectors (e.g. IP addresses). These vary by [=user agent=] and are hard to
eliminate entirely, but in general [=user agents=] are expected to address these over time. These
bits of information tied to the network requests make the timing attack easier, making it more
important to address.

Note: this attack is described and discussed
[here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1089040953).

The attack is as follows:

1. The [=RP=] logs the time at which it invokes the API, time A and sends it to the [=IDP=] to
    learn itself by marking the time in which it receives the fetch for the [=RP=]'s client
    metadata. Time A is tied to the site.
1. A credentialed request is sent to the [=IDP=] that does not explicitly identify the [=RP=], but
    it is sent around a time that is close enough to the request above. The [=IDP=] notes the time
    in which this request has arrived, time B. Time B is tied to the user identity.
1. The [=IDP=] correlates time A and time B to find the (site, user identity) pair with high
    probability. Note that fingerprinting can make the correlation more accurate.

Note that this kind of correlation is already possible without FedCM by using simple cross-origin
top-level navigations, but using FedCM for this purpose would worsen the problem if it improved
timing resolution or if it was less visible to users (e.g. the [=IDP=] could return empty accounts
to the [=user agent=] to deliberately make no browser UI to be triggered, and hence make this attack
invisible to the user).

The [=user agent=] should mitigate this attack to protect users, in an interoperable way.

The following are mitigations under investigation.

<!-- ============================================================ -->
#### Heuristics #### {#timing-attack-heuristics}
<!-- ============================================================ -->

One mitigation under investigation is to try to use heuristics to limit the attack surface:

* Any [=RP=]s or [=IDP=]s observed to be using this API to compromise user privacy in a deceptive or
    abusive manner could be explicitly blocked from using it or put behind an interstitial.
* The [=user agent=] could detect [=trackers=] by noting alleged [=IDP=]s that do either of the
    following:
    * Never show UI despite the FedCM API fetches being performed.
    * Provide generic user identification, such as "Anonymous", or "Guest" or "Incognito" as the
        user's name.
    * Have a suspiciously low click-through rate (e.g. most users don't recognize the value in using
        this [=IDP=]).
* The [=user agent=] could block the API or show a static interstitial after the user has already
    expressed lack of interest in the API because they did at least one of the following:
    * Repeatedly ignored the FedCM API in the past in a similar scenario.
    * Provide user settings to disable the FedCM API.
    * Pressed some [=user agent=] UI to close the FedCM API's request for permission.
* The [=user agent=] could gate the FedCM fetches on a user interaction so that the timing attack is
    only possible once the user has expressed some interest in the API. Note that this may provide a
    poor user experience for users that do want to use the API, and may also result in worse success
    metrics for the API.

<!-- ============================================================ -->
#### Push Model #### {#push-model-mitigation}
<!-- ============================================================ -->

Another potential future mitigation for timing attacks is the [=push model=]. The current API is the
<dfn>pull model</dfn>: the API pulls the user accounts from the [=IDP=] every time they are needed
by the FedCM API. In the <dfn>push model</dfn>, the [=IDP=] needs to tell the [=user agent=] that a
user has signed in whenever this happens. This way, when the FedCM API is called, the [=user agent=]
already knows the user accounts that the user can select from, and thus does not require any
credentialed fetches to the [=IDP=] in order to show the UI. It would only be when the user
grants permission that the [=IDP=] is notified, thus resolving the timing attack problem entirely.

While the [=push model=] seems like an improvement for privacy, the current API uses the
[=pull model=] for these reasons:

* It introduces a lot of complexity for the [=IDP=]s, as they now need to declare the user accounts
    and keep them updated all the time. In particular, they need to be updated when a user logs out,
    deletes their account or simply change name, etc. A user can also use browser UX to logout, e.g.
    by clearing cookies. While those are not high-frequency changes (e.g. once every other year for
    each user), keeping them in sync is non-trivial.
* It requires a lot of the [=IDP=]'s trust in [=user agent=] to protect all of their user's
    accounts. The push model requires storing all of the user accounts from all of the [=IDP=]s that
    a user is logged into, regardless of whether the user ever uses the FedCM API or not. This means
    that all users pay the cost, and only some get the reward.

<!-- ============================================================ -->
##### The IdP Sign-in Status API ##### {#the-idp-sign-in-status-api}
<!-- ============================================================ -->

Note: The API specified in this section is not launched in any user agent,
and as such should be considered very experimental and subject to change.

Issue: this is a more formal description of what is proposed [here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1233290946).

A strict subset of the [=push model=] that seems promising is to only push
the user's sign-in status in the IdP (as opposed to the entirety of the user's account data,
e.g. name, email).

Since the sign-in status is specific to a browser instance/profile, this bit can reflect reality
almost perfectly (with the exception of server-side invalidations, e.g. users changing password, and
deleting accounts on other devices).

Importantly, sign-in status seems easier to degrade gracefully when the client-side state is inconsistent with the server-side state: re-authentication UX. The user's profile information, on the other hand, has a series of legal freshness requirements that are still not quite well understood.

So, in this variation, the [=user agent=] does two things: (a) it stores the user's login status at each [=IDP=] and (b) exposes APIs that allows [=IDP=]s to change them.

This is a compelling variation because (a) it is comparably simpler to implement by [=IDPs=] and (b)
if the [=user agent=] knew whether the user is signed-in or not to the [=IDP=], it can guarantee that
a user prompt will always be displayed, which makes the timing attack much less viable to be performed
invisibly (i.e. without any explicit and observable indication to the user).

<script type="text/typogram">
.---------------------------------.    .---------------------------------.    .---------------------------------.
| .-----------------------------. |    | .-----------------------------. |    | .-----------------------------. |
| | "https://idp.example"       | |    | | "https://idp.example"       | |    | | "https://idp.example"       | |
| '-----------------------------' |    | '-----------------------------' |    | '-----------------------------' |
| .-----------------------------. |    | .-----------------------------. |    | .-----------------------------. |
| |                             | |    | |                     logout -+-+-+  | |                             | |
| |   Sign-in                   | |    | |  Welcome, Sam!      ------  | | |  | |  Bye!                       | |
| |                             | |    | |                             | | |  | |                             | |
| |   username                  | |    | |                             | | |  | |                             | |
| |  +-----------------------+  | |    | | "// calls"                  | | |  | | "// calls"                  | |
| |  | you@email.com         |  | | +--+-+>"IdentityProvider.login();" | | +--+-+>"IdentityProvider.logout();"| |
| |  +-----------------------+  | | |  | |                     :       | |    | |                     :       | |
| |   password                  | | |  | |                     :       | |    | |                     :       | |
| |  +-----------------------+  | | |  | |                     :       | |    | |                     :       | |
| |  |"**********"           |  | | |  | |                     :       | |    | |                     :       | |
| |  +-----------------------+  | | |  | |                     :       | |    | |                     :       | |
| |                             | | |  | |                     :       | |    | |                     :       | |
| |  +-----------------------+  | | |  | |                     :       | |    | |                     :       | |
| |  |       Sign-in         +--+-+-+  | |                     :       | |    | |                     :       | |
| |  +-----------------------+  | |    | |                     :       | |    | |                     :       | |
| |                             | |    | |                     :       | |    | |                     :       | |
| '-----------------------------' |    | '---------------------:-------' |    | '---------------------:-------' |
'---------------------------------'    '-----------------------:---------'    '-----------------------:---------'
                                                               :                                      :
                                                               +~~~~+    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                                                                    :    :
                                                                    v    v
                                       +-----------------------+-----------------+
                                       |  Identity Provider    | Sign-in Status  |
                                       +-----------------------+-----------------+
                                       | "..."                 | "..."           |
                                       +-----------------------+-----------------+
                                       | "https://idp.example" | Signed-in       |
                                       +-----------------------+-----------------+
                                       | "..."                 | "..."           |
                                       +-----------------------+-----------------+

</script>

Internally, each [=user agent=] keeps track of a global <dfn>Sign-in Status</dfn> map per [=IDP=],
initially an empty [=map=]. The [=map/keys=] in the [=Sign-in Status=] map is the [=/origin=] of the
[=IDP=]. The [=map/values=] in the [=Sign-in Status=] map are <b>status</b> objects which can be one
of the following values:

<dl dfn-type="argument" dfn-for="Sign-in Status">
    :   <dfn>unknown</dfn> (default)
    ::  By default, the [=user agent=] assumes that the user's signed in status is undefined.
    :   <dfn>signed-in</dfn>
    ::  The user has explicitly signed-in to the IDP.
    :   <dfn>signed-out</dfn>
    ::  The user has explicitly signed-out to the IDP.
</dl>

The [=IDPs=] are provided with an API that allows them to set their [=Sign-in Status=].

<xmp class=idl>
[Exposed=Window, SecureContext]
interface IdentityProvider {
  static undefined login();
  static undefined logout();
};
</xmp>

<div algorithm=login>
When the {{IdentityProvider/login()}} static method is invoked the user agent MUST execute the following
steps:
    1. Let |origin| be the [=current settings object=]'s [=environment settings object/origin=].
    1. Set the [=Sign-in Status=] of the |origin| to {{Sign-in Status/signed-in}}.
</div>

<div algorithm=logout>
When the {{IdentityProvider/logout()}} static method is invoked the user agent MUST execute the following
steps:
    1. Let |origin| be the [=current settings object=]'s [=environment settings object/origin=].
    1. Set the [=Sign-in Status=] of the |origin| to {{Sign-in Status/signed-out}}.
</div>

For example:

<div class="example">
A possible JS API that allows IDPs to set their Sign-in Status.
```js
IdentityProvider.login();
// ... later ...
IdentityProvider.logout();
```
</div>

For convenience and compatibility with existing deployed flows, the [=user agent=] also exposes the ability for [=IDPs=] to control their [=Sign-in Status=] via HTTP headers:

<div class="example">
A possible HTTP header API that allows IDPs to set their Sign-in Status.
```http
IdP-Sign-in-Status: action=login
// ... later ...
IdP-Sign-in-Status: action=logout
```
</div>

When site data (e.g. cookies) are cleared manually by the user, the [=user agent=] also sets the [=Sign-in Status=] to {{Sign-in Status/unknown}}.

IDPs are also offered an extension to the {{IdentityProviderAPIConfig}} object to include:

<dl dfn-type="argument" dfn-for="IdentityProviderAPIConfig">
    :   <dfn>signin_url</dfn> (optional)
    ::  A URL that allows a user to sign-in to the [=IDP=].
</dl>

The [=user agent=] uses the following [=maybe fetch the accounts list=] instead of the [=fetch the accounts list=] algorithm. It would also return early on if the user was {{Sign-in Status/signed-out}}.

<div algorithm>
To <dfn>maybe fetch the accounts list</dfn> given an {{IdentityProviderAPIConfig}} |config|, an {{IdentityProviderConfig}}
|provider|, and a |globalObject|, run the following steps. This returns a [=list=].

    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. Let |idpOrigin| be the origin corresponding to |configUrl|.
    1. Let |status| be the [=Sign-in Status=] of the |idpOrigin|.
    1. If |status| is {{Sign-in Status/unknown}}:
        1. Let |accounts| be the result of the [=fetch the accounts list=] algorithm given |config| and |provider|.
        1. Set the [=Sign-in Status=] of the |idpOrigin| to {{Sign-in Status/signed-in}} if |accounts| is non-empty, {{Sign-in Status/signed-out}} otherwise.

        NOTE: This handles the case where the [=IDP=] hasn't had the chance to call the API before the accounts list is needed. This can incur into a timing attack, but it is limited to 1 per [=IDP=] per [=user agent=], so not very practical. Albeit small, removing this attack surface is an active area of investigation.

    1. If |status| is {{Sign-in Status/signed-out}}:
        1. Return an empty list.

        NOTE: By terminating the request here before running [=fetch the accounts list=] algorithm we prevent the timing attack to be performed without any user prompt.

    1. If |status| is {{Sign-in Status/signed-in}}:
        1. Let |accounts| be the result of the [=fetch the accounts list=] algorithm given |config| and |provider|.
        1. If |accounts|'s size is 0:
            1. Set the [=Sign-in Status=] of the |idpOrigin| to {{Sign-in Status/signed-out}}.
            1. Ask the user to confirm they want to sign-in to their [=IDP=].
            1. If they decline, return an empty list.
            1. Return the result of running the [=Sign-in to the IDP=] algorithm given |config| and |provider|.

            NOTE: This can happen when the user's local client credentials are invalidated on the server (e.g. changing passwords or deleting accounts on a different device), or we get network errors (e.g. timeouts, failures, etc).

        1. Return |accounts|.
</div>

<div algorithm>
To <dfn>Sign-in to the IDP</dfn> given an {{IdentityProviderAPIConfig}} |config| and an {{IdentityProviderConfig}}
|provider|. This returns a [=list=].
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}}.
    1. Let |idpOrigin| be the origin corresponding to |configUrl|.
    1. Assert that the [=Sign-in Status=] of the |idpOrigin| is {{Sign-in Status/signed-out}}.
    1. In parallel, wait until one of the following tasks returns to continue:
        1. Open a dialog that directs the user to the |config|'s {{IdentityProviderAPIConfig/signin_url}}.
        1. Wait until the [=Sign-in Status=] of the |idpOrigin| becomes {{Sign-in Status/signed-in}}
            1. Close the dialog
            1. Return the result of the [=fetch the accounts list=] algorithm
        1. Wait until the user explicitly cancels the dialog
            1. Close the dialog
            1. Return empty list
</div>

<!-- ============================================================ -->
### IDP Intrusion ### {#idp-intrusion}
<!-- ============================================================ -->

   > From [[PRIVACY-THREAT-MODEL#hl-intrusion]]
   >
   > Privacy harms don't always come from a site learning things.

   > From [[RFC6973#section-5.1.3|RFC6973: Intrusion]]
   >
   > Intrusion consists of invasive acts that disturb or interrupt one's life or activities.
   > Intrusion can thwart individuals' desires to be left alone, sap their time or attention, or
   > interrupt their activities.

In the context of federation, intrusion happens when an [=RP=] and an [=IDP=] are colluding to
invasively and aggressively recommend the user to login disproportionally to the their intent. Much
like unsolicited notifications, an [=RP=] can collude with an [=IDP=] to aggressively log users in.

The [=user agent=] can mitigate this by mediating the user controls and offering them proportionally
to the intent of the user or the privacy risks involved. For example, a [=user agent=] can choose to
show a loud / disruptive modal mediated dialog when it has enough confidence of the user's intent or
show a quiet / conservative UI hint when it doesn't.

A [=user agent=] could also choose to control disruption of the user's experience based on the risks
involved. For example, when a [=directed identifier=] is being exchanged it can be more confident of
the unintended consequeces and offer a more aggressive user experience, whereas when global
identifiers are exchanged a more conservative user experience.

<div class="image">
  <pre class=include-raw>
  path: img/mock45.svg
  </pre>
</div>

<!-- ============================================================ -->
## Other Attack Scenarios ## {#other-attack-scenarios}
<!-- ============================================================ -->

The following are other attack scenarios considered but for which we do not **currently**  have specific
mitigations in this API, but would ideally like to see addressed in future revisions of this API. This is usually because the attacks rely on the user already granted
permission. Usually stopping such attacks would be very hard since the [=RP=] and [=IDP=] communication
has been established. In addition, such attacks would still be possible when using regular login
mechanisms. Still, they are worth mentioning as they showcase some risks users take when signing
into [=RP=]s. In some cases, future mitigations are discussed.

<!-- ============================================================ -->
### Cross-Site Correlation ### {#attack-scenarios-by-rp-cross-site-correlation}
<!-- ============================================================ -->

This attack happens when multiple [=RP=]s collude to use their user's data to correlate them and
build a richer profile. When a user willingly provides their full name, email address, phone number,
etc, to multiple relying parties, those relying parties can collaborate to build a profile of that
user and their activity across collaborating sites. Sometimes this is referred to as [=joining=]
since it amounts to a join of user records between the account databases of multiple RPs. This
correlation and profile-building is outside the userâ€™s control and entirely out of the [=user
agent=]â€™s or [=IDP=]â€™s view.

<div class="image">
   <pre class=include-raw>
   path: img/mock3.svg
   </pre>
</div>

<div class="example">
    1. User signs into RP1 (which sells jewelry) with an IDP, providing to RP1
        their email address user@email.example
    1. User signs into RP2 (which sells houses) with an IDP, providing to RP2
        their email address user@email.example
    1. User browses the collection of wedding rings in RP1.
    1. Out of band, RP1 tells RP2 that user@email.example is shopping for wedding rings
    1. User browses the housing inventory in RP2.
    1. RP2 uses the fact that the user is shopping for wedding rings in RP1 to
        advertise and filters their housing inventory.
    1. User is surprised that RP2 knows that they are shopping for wedding rings.
</div>

The problem of [=RP=]s [=joining=] user data via back-channels is inherent to the proliferation of
identifying user data. This can be solved by issuing [=directed identifiers=] that provide an
effective handle to a user's identity with a given [=IDP=] that is unique and therefore cannot be
correlated with other [=RP=]s. In the past, there have been schemes to accomplish this using one-way
hashes of, for example, the userâ€™s name, the [=IDP=], and the [=RP=]. These identifiers would be
unique, and hence it would not be possible to correlate these with other [=RP=]s.

<div class="image">
  <pre class=include-raw>
  path: img/mock37.svg
  </pre>
</div>

<!-- ============================================================ -->
### Unauthorized Data Usage ### {#unauthorized-data-usage}
<!-- ============================================================ -->

Another attack is when the [=RP=] or [=IDP=] uses user information for purposes not authorized by
the user. When the user agrees to allow the [=IDP=] to provide information to the [=RP=], the
permission is specific to certain purposes, such as sign-in and personalization. For instance, the
[=RP=] might use that data for other purposes that the user would not expect and did not authorize,
such as selling email addresses to a spam list. Spamming risk can exist even when using
[=directed identifiers=].

<!-- ============================================================ -->
### RP Fingerprinting ### {#rp-fingerprinting}
<!-- ============================================================ -->

This attack happens when the [=RP=] employs client state-based tracking to identify user. Any
API that exposes any kind of client state to the web risk becoming a vector for fingerprinting. The
purpose of this API is for the user to provide identification to the [=RP=]. And the user should be
able to rescind the access to that identification, for instance by logging out. However, a tracking
[=RP=] could keep state to detect the user that was previously logged in:

<div class="image">
<pre class=include-raw>
path: img/mock5.svg
</pre>
</div>

<!-- ============================================================ -->
### Secondary Use ### {#secondary-use}
<!-- ============================================================ -->

Secondary use is the use of collected information about an individual without the individual's
perimssion for a purpose different from that for which the information was collected. This attack
happens when [=IDP=]s misuse the the information collected to enable sign-in for other
purposes.

Existing federation protocols require that the [=IDP=] know which service is requesting a [=token=]
in order to allow identity federation. Identity providers can use this fact to build profiles of
users across sites where the user has decided to use federation with the same account. This profile
could be used, for example, to serve targeted advertisements to those users browsing on sites that
the IDP controls.

This risk can exist even in the case where the [=IDP=] does not having pre-existing user account
information (for instance, if it is not a _bona fide_ IDP), because FedCM requests sent to the
[=IDP=] are credentialed. This is more likely to occur if the [=RP=] is colluding with the
[=IDP=] to enable tracking via [[#timing-attacks]].

<div class="image">
    <pre class=include-raw>
    path: img/mock23.svg
    </pre>
</div>

<div class='example'>
    1. User signs into RP1 (which sells jewelry) with an [=IDP=].
    1. User signs into RP2 (which sells houses) with the same [=IDP=].
    1. User navigates to the [=IDP=].
    1. Because the [=IDP=] knows that the user has an account with RP1 and RP2, the
        [=IDP=] can show ads about vacations for honeymoons.
    1. The user is surprised that their [=IDP=] is aware of their plans to get
        married.
</div>

Preventing tracking of users by the [=IDP=] is difficult: the [=RP=] has to be coded into the
identity token for security reasons, such as token reuse and fraud and abuse prevention. That said,
there have been cryptographic schemes developed to blind the [=IDP=] to the [=RP=] while still
preventing token reuse(see Mozillaâ€™s [personas](https://wiki.mozilla.org/Identity/Persona_AAR)).

<div class="image">
  <pre class=include-raw>
  path: img/mock34.svg
  </pre>
</div>

<!-- ====================================================================== -->
# Extensibility # {#extensibility}
<!-- ====================================================================== -->

Note: go over the extensibility mechanisms.

<!-- ====================================================================== -->
# Acknowledgements # {#acknowledgements}
<!-- ====================================================================== -->

Note: write down the Acknowledgements section.

<pre class="biblio">
{
  "CM": {
    "href": "https://w3c.github.io/webappsec-credential-management/",
    "title": "Credential Management"
  },
  "Front-Channel-Logout": {
    "authors": [ "M. Jones" ],
    "href": "https://openid.net/specs/openid-connect-frontchannel-1_0.html",
    "title": "Front-Channel Logout"
  },
  "JWT": {
    "authors": [ "M. Jones", "J. Bradley", "N. Sakimura" ],
    "href": "https://datatracker.ietf.org/doc/html/rfc7519",
    "title": "JWT"
  },
  "OIDC-Connect-Core": {
    "href": "https://openid.net/specs/openid-connect-core-1_0.html",
    "title": "OIDC Connect Core"
  },
  "PERMISSIONS-POLICY": {
    "href": "https://w3c.github.io/webappsec-permissions-policy",
    "title": "Permissions Policy"
  },
  "PRIVACY-MODEL": {
    "href": "https://github.com/michaelkleber/privacy-model",
    "title": "Privacy Model"
  },
  "PRIVACY-THREAT-MODEL": {
    "href": "https://w3cping.github.io/privacy-threat-model/",
    "title": "Target Privacy Threat Model"
  },
  "PSL-PROBLEMS": {
    "authors": ["Ryan Sleevi"],
    "href": "https://github.com/sleevi/psl-problems",
    "title": "Public Suffix List Problems"
  },
  "RFC7258": {
    "href": "https://datatracker.ietf.org/doc/html/rfc7258",
    "title": "Pervasive Monitoring Is an Attack"
  },
  "SAML-Glossary": {
    "href": "https://docs.oasis-open.org/security/saml/v2.0/saml-glossary-2.0-os.pdf",
    "title": "SAML glossary"
  }
}
</pre>
