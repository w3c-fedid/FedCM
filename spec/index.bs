<pre class='metadata'>
Title: Federated Credential Management API
Shortname: fedcm
Level: 1
Status: w3c/ED
Group: fedid
TR: http://www.w3.org/TR/fedcm/
ED: https://w3c-fedid.github.io/FedCM/
Prepare for TR: true
Repository: w3c-fedid/FedCM
Editor: Nicolás Peña Moreno, w3cid 103755, Google Inc. https://google.com, npm@chromium.org
Former Editor: Sam Goto, w3cid 50308, Google Inc. https://google.com, goto@google.com

Markup Shorthands: markdown yes, biblio yes
Default Biblio Display: inline

Text Macro: FALSE <code>false</code>
Text Macro: TRUE <code>true</code>
Text Macro: RP Relying Party
Text Macro: IDP Identity Provider

Abstract: A Web Platform API that allows users to login to websites with their federated accounts in a privacy-preserving manner.

Test Suite: https://github.com/web-platform-tests/wpt/tree/master/fedcm
</pre>

<pre class=anchors>
spec: ecma262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: internal method; url: sec-ordinary-object-internal-methods-and-internal-slots

spec: credential-management-1; urlPrefix: https://w3c.github.io/webappsec-credential-management/
    type: dfn
        text: same-origin with its ancestors; url: same-origin-with-its-ancestors
    type: dfn
        text: requires user mediation; url: origin-requires-user-mediation
spec: webdriver; urlPrefix: https://w3c.github.io/webdriver/
    type: dfn
        text: endpoint node; url: dfn-endpoint-node
        text: extension capability; url: dfn-extension-capability
        text: getting a property; url: dfn-getting-properties
        text: matching capabilities; url: dfn-matching-capabilities
        text: no such alert; url: dfn-no-such-alert
        text: error code; url: dfn-error-code
        text: validating capabilities; url: dfn-validate-capabilities
spec: webappsec-fetch-metadata; urlPrefix: https://w3c.github.io/webappsec-fetch-metadata/
    type: dfn
        text: Directly User-Initiated Requests; url: directly-user-initiated
spec: login-status; urlPrefix: https://w3c-fedid.github.io/login-status
    type: dfn
        text: logged-in; url: logged-in
        text: logged-out; url: logged-out
        text: unknown; url: unknown
        text: get the login status; url: get-the-login-status
        text: set the login status; url: set-the-login-status
</pre>

<pre class=link-defaults>
spec:infra; type:dfn; text:list
spec:infra; type:dfn; text:user agent
spec:html; type:dfn; for:environment settings object; text:global object
spec:html; type:dfn; for:html-origin-def; text:origin
spec:webidl; type:dfn; text:resolve
spec:webdriver2; type:dfn; text:error
spec:webdriver2; type:dfn; text:remote end steps
spec:fetch; type:dfn; for:/; text:response
spec:css-color-5; type:type; text:<color>
spec:html; type:dfn; text:allowed to use
</pre>

<style>
dl.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
dl.domintro dt a {
    color: inherit; border-bottom-style: none;
}
dl.domintro dt code {
    font-size: inherit;
}
.idp-normative-text {
    background-color: rgba(165, 42, 42, 0.3);
    margin: 16px 0px;
    padding: 8px;
    border-left: 8px solid brown;
}

/* temporary fixes to the typogram diagrams
   to support dark mode properly */
script + svg :is(polygon, line, rect):not(.grid) {
  stroke: currentcolor;
}
script + svg :is(polygon, text) {
  fill: currentcolor;
}
</style>

<script src="https://w3c-fedid.github.io/FedCM/static/underscore-min.js"></script>
<script src="https://w3c-fedid.github.io/FedCM/static/raphael.min.js"></script>
<script src="https://w3c-fedid.github.io/FedCM/static/webfont.js"></script>
<script src="https://w3c-fedid.github.io/FedCM/static/typogram.js"></script>

<!-- ============================================================ -->
# Introduction # {#introduction}
<!-- ============================================================ -->

*This section is non-normative.*

As the web has evolved there have been ongoing privacy-oriented changes
(e.g [Safari](https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/),
[Firefox](https://blog.mozilla.org/blog/2019/09/03/todays-firefox-blocks-third-party-tracking-cookies-and-cryptomining-by-default/),
[Chrome](https://blog.google/products/chrome/privacy-sustainability-and-the-importance-of-and/))
and changes to the underlying privacy principles (e.g. [[PRIVACY-MODEL]]).

With this evolution, fundamental assumptions of the web
platform are being redefined or removed. Access to cookies in a third-party
context are one of those assumptions. While overall good for the
web, the third-party cookie deprecation removes a fundamental building block
used by certain designs of federated identity.

The Federated Credential Management API aims to bridge the gap for the
federated identity designs which relied on third-party cookies.
The API provides the primitives needed to support federated identity when/where
it depends on third-party cookies, from sign-in to sign-out and revocation.

In order to provide the federated identity primitives without the use of
third-party cookies the API places the [=user agent=] as a mediator between a
<dfn><abbr title="Relying Party">RP</abbr></dfn> (website that requests user information for
federated sign in) and an <dfn><abbr title="Identity Provider">IDP</abbr></dfn> (website that provides
user information for federated sign in). This mediation requires user
permission before allowing the [=RPs=] and [=IDPs=] to know about their
connection to the user.

The specification leans heavily on changes in the [=user agent=] and [=IDP=]
and minimally on the [=RP=]. The FedCM API provides a way to fetch tokens.

<div class=example>
Example showing how a website allowing for a single logged in account
could be implemented.

```html
<html>
<head>
  <title>Welcome to my Website</title>
</head>
<body>
  <button onclick="login()">Login with idp.example</button>

  <script>
  let nonce;
  async function login() {
    try {
      // Assume there is a method returning a random number. Store the value in a variable which can
      // later be used to check against the value in the token returned.
      nonce = random();
      // Prompt the user to select an account from the IDP to use for
      // federated login within the RP. If resolved successfully, the Promise
      // returns an IdentityCredential object from which the |token| can be
      // extracted. This is an opaque string passed from the IDP to the RP.
      let token = await navigator.credentials.get({
        identity: {
          providers: [{
            configURL: "https://idp.example/manifest.json",
            clientId: "123",
            nonce: nonce,
          }]
        }
      });
    } catch(e) {
      // The FedCM call was not successful.
    }
  }
  </script>
</body>
</html>
```
</div>


At a high level, the Federated Credential Management API works by the
intermediation of cooperating [=IDP=]s and [=RP=]s.

The [[#idp-api]] defines a set of HTTP APIs that [=IDP=]s expose as well as the entry points in the
[[#browser-api]] that they can use.

<script type="text/typogram">
+-----------+                  +-----------+                      +-----------+
|           |                  |           |                      |           |
|  Relying  |                  |   User    |                      | Identity  |
|   Party   |                  |   Agent   |                      | Provider  |
|           |                  |           |                      |           |
|           |                  | Federated |                      |           |
|           |   +----------->*-+ Credential|     +------------->*-+ Well-Known|
|           |   |              | Management|     |                |           |
|           |   |              |    API    |     +------------->*-+ Config    |
|           |   |              |           |     |                |           |
|           |   |              |           |     +------------->*-+ Accounts  |
|           |   |              |           |     |                |           |
|           |   |              |           |     +------------->*-+ Assertion |
|           |   |              |           |     |                |           |
|           |   |              |           |     |                |           |
| +-------+ |   |              | +-------+ |     |                |           |
| | JS    +-+---+              | + HTTP  +-+-----+                |           |
| +-------+ |                  | +-------+ |                      |           |
|           |                  |           |                      |           |
|           |                  |           |                      |           |
+-----------+                  +-----------+                      +-----------+
</script>

<div class="issue" heading="extension">
An extension spec may add a client metadata endpoint between accounts and assertion:
<script type="text/typogram">
|           |   |              |           |     +------------->*-+ Accounts  |
|           |   |              |           |     |                |           |
|           |   |              |           |     +------------->*-+ Client    |
|           |   |              |           |     |                | Metadata  |
|           |   |              |           |     |                |           |
|           |   |              |           |     +------------->*-+ Assertion |
|           |   |              |           |     |                |           |
</script>
</div>

The user agent intermediates in a manner that makes it impractical for the
API to be used for tracking purposes, while preserving the functionality of
identity federation.

<script type="text/typogram">
    Relying                             User                            Identity
    Party                               Agent                           Provider

      |                                   |                                 |
      | "navigator.credentials.get({    " | "(1) The RP invokes the API."   |
      | "  identity: {                  " |                                 |
      | "    providers: [{              " |                                 |
      | "      configURL: 'config.json'," |                                 |
      | "      clientId: clientId,      " |                                 |
      | "      nonce: nonce,            " |                                 |
      | "    }]                         " |                                 |
      | "  }                            " |                                 |
      | "})                             " |                                 |
      |                                   |                                 |
      |---------------------------------->|                                 |
      |                                   |                                 |
      |                                   |                                 |
      | "(2) From the configURL, the    " | "GET /.well-known/web-identity" |
      | "browser makes two requests     " |-------------------------------->|
      | "in parallel.                   " |                                 |
      |                                   | "GET /config.json"              |
      |                                   |-------------------------------->|
      |                                   |                                 |
      | "(3) The IdP responds with a    " |                                 |
      | "well-known file and a          " |                                 |
      | "config file.                   " |                                 |
      |                                   |                                 |
      |                                   |                                 |
      |                                   |                                 |
      | "The well-known file            " | "Well-Known file"               |
      | "contains a list of valid       " |<--------------------------------| "{"
      | "config URLs.                   " |                                 |   "provider_urls: [ ... ]"
      |                                   |                                 | "}"
      |                                   |                                 |
      | "The config file contains       " | "Config file"                   |
      | "information about the IdP.     " |<--------------------------------| "{"
      |                                   |                                 |   "id_assertion_endpoint: ...,"
      |                                   |                                 |   "accounts_endpoint: /accounts,"
      |                                   |                                 |   "client_metadata_endpoint: ...,"
      |                                   |                                 |   "branding: ...,"
      |                                   |                                 | "}"
      |                                   |                                 |
      | "(4) The browser proceeds to    " | "GET /accounts"                 |
      | "fetch the list of accounts     " | "Cookie: name=value"            |
      | "that the user is logged in     " |-------------------------------->|
      | "to.                            " |<--------------------------------| "{"
      |                                   |                                 |   "accounts: [ ... ]"
      |                                   |                                 | "}"
      |                                   |                                 |
      |                                   |                                 |
      |                     +-------------+ "(5) With all of this, the    " |
      |                     |             | "browser asks for the user's  " |
      |                     |             | "permission to sign-in to the " |
      |  "account chooser"  |             | "RP with the IdP's account.   " |
      |                     |             |                                 |
      |                     |             |                                 |
      |                     +------------>|                                 |
      |                                   |                                 |
      |                                   |                                 |
      |                                   |                                 |
      | "(6) Once the user selects an   " | "POST /assertion"               |
      | "account and permission, the    " | "client_id, cookies, account"   |
      | "browser fetches the token.     " |-------------------------------->|
      |                                   |<--------------------------------| "{"
      |                                   |                                 |   "token: ...,"
      |                                   |                                 | "}"
      |                                   |                                 |
      |                "{ token }"        | "(7) Which is then ultimately " |
      |<----------------------------------| "used to resolve the promise. " |
      |                                   |                                 |
      |                                   |                                 |
     -+-                                 -+-                               -+-
</script>

<div class="issue" heading="extension">
The following could be added to an extension spec:

<script type="text/typogram">
      |                                   |                                 |
      | "(4.5) The browser then         " | "GET /client_metadata"          |
      | "fetches metadata about the     " | "client_id"                     |
      | "Relying Party.                 " |-------------------------------->|
      |                                   |<--------------------------------| "{"
      |                                   |                                 |   "terms_of_service_url: ...,"
      |                                   |                                 |   "privacy_policy_url: ...,"
      |                                   |                                 | "}"
      |                                   |                                 |
</script>
</div>

<!-- ============================================================ -->
# The Browser API # {#browser-api}
<!-- ============================================================ -->

The Browser API exposes APIs to [=RP=]s and [=IDP=]s to call and intermediates
the exchange of the user's identity.

The Sign-up/Sign-in API is used by the [=RP=]s to ask the browser
to intermediate the relationship with the [=IDP=] and the
provisioning of a token.

NOTE: The [=RP=] makes no delineation between Sign-up and Sign-in, but
rather calls the same API indistinguishably.

If all goes well, the Relying Party receives back an {{IdentityCredential}}
which contains a token it can use to authenticate the user.

<div class=example>
```js
const credential = await navigator.credentials.get({
  identity: {
    providers: [{
      configURL: "https://idp.example/manifest.json",
      clientId: "123",
    }]
  }
});
```
</div>

When fetches are sent with cookies, unpartitioned
[SameSite](https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#name-the-samesite-attribute-2)=None
cookies are included. It doesn't introduce security issues on the API even when third-party cookies are otherwise
disabled because the [=RP=] cannot inspect the results from the fetches on its own (i.e., the browser mediates what
the [=RP=] can receive).

<!-- ============================================================ -->
## The connected accounts set ## {#browser-connected-accounts-set}
<!-- ============================================================ -->

Each [=user agent=] has a global <dfn>connected accounts set</dfn>, an initially empty
[=ordered set=]. Its [=list/items=] are triples of the form (|rp|, |idp|, |account|) where |rp| is
the [=/origin=] of the [=RP=], |idp| is the [=/origin=] of the [=IDP=], and |account| is a string representing
an account identifier. It represents the set of triples such that the user has used FedCM to login to
the |rp| via the |idp| |account|.

Issue: the [=connected accounts set=] should be double keyed in the [=RP=] (i.e., it should include
both the requester and the embedder, or in other words the iframe and the top-level). Otherwise the
top-level's state could be used and modified by the embedder, which introduces leaks and unwanted
cross-origin communication.

If a user clears browsing data for an |origin| (cookies, localStorage, etc.), the user agent MUST
[=list/remove=] all triples with an [=/origin=] matching the |origin| from <a>connected accounts set</a>.

<div algorithm>
To <dfn>compute the connected account key</dfn> given an {{IdentityProviderConfig}} |provider|, an
{{IdentityProviderAccount}} |account|, and a |globalObject|, run the following steps. It returns a
triple of the form (rp, idp, account).
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. Let |idpOrigin| be the [=url/origin=] corresponding to |configUrl|.
    1. Let |rpOrigin| be |globalObject|'s [=associated Document=]'s [=Document/origin=].
    1. Let |accountId| be |account|'s {{IdentityProviderAccount/id}}.
    1. Return (|rpOrigin|, |idpOrigin|, |accountId|).
</div>

<div algorithm>
When asked whether an {{IdentityProviderAccount}} |account| is
<dfn>eligible for auto reauthentication</dfn> given an {{IdentityProviderConfig}} |provider| and a
|globalObject|, run the following steps. This returns a boolean.
    1. If |account| [=map/contains=] {{IdentityProviderAccount/approved_clients}} and
        |account|'s {{IdentityProviderAccount/approved_clients}} does not [=list/contain=]
        |provider|'s {{IdentityProviderConfig/clientId}}, return false.
    1. Let |triple| be the result of running [=compute the connected account key=] given |provider|,
        |account|, and |globalObject|.
    1. Return whether [=connected accounts set=] [=list/contains=] |triple|.
</div>

<div algorithm="compute the connection status">
When asked to <dfn>compute the connection status</dfn> given an {{IdentityProviderAccount}}
|account|, an {{IdentityProviderConfig}} |provider| and a |globalObject|, run the following steps.
This returns <dfn for="compute the connection status">connected</dfn> or
<dfn for="compute the connection status">disconnected</dfn>.
    1. If |account| [=map/contains=] {{IdentityProviderAccount/approved_clients}}:
        1. If |account|'s {{IdentityProviderAccount/approved_clients}} [=list/contains=]|provider|'s
            {{IdentityProviderConfig/clientId}}, return [=compute the connection status/connected=].
        1. Return [=compute the connection status/disconnected=].
    1. Let |triple| be the result of running [=compute the connected account key=] given |provider|,
        |account|, and |globalObject|.
    1. If [=connected accounts set=] [=list/contains=] |triple|, return
        [=compute the connection status/connected=].
    1. Return [=compute the connection status/disconnected=].
</div>

<div algorithm>
To <dfn>create a connection between the RP and the IdP account</dfn> given an
{{IdentityProviderConfig}} |provider|, an {{IdentityProviderAccount}} |account|, and a
|globalObject| (the [=RP=]'s), run the following steps:
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. Let |idpOrigin| be the [=url/origin=] corresponding to |configUrl|.
    1. Let |rpOrigin| be |globalObject|'s [=associated Document=]'s [=Document/origin=].
    1. Let |accountId| be |account|'s {{IdentityProviderAccount/id}}.
    1. Let |triple| be (|rpOrigin|, |idpOrigin|, |accountId|).
    1. [=set/Append=] |triple| to [=connected accounts set=].
</div>

<div algorithm>
To <dfn>remove a connection</dfn>: given |accountId|, |rpOrigin|, and |idpOrigin|, run the
following steps. It returns whether the |accountId| connection was successfully removed.
    1. Let |triple| be (|rpOrigin|, |idpOrigin|, |accountId|).
    1. If [=connected accounts set=] [=list/contains=] |triple|:
        1. [=list/Remove=] |triple| from the [=connected accounts set=].
        1. Return true.
    1. Return false.
</div>

<div algorithm>
To <dfn>remove all connections</dfn>: given |rpOrigin| and |idpOrigin|, run the following steps:
    1. For every (|rp|, |idp|, <var ignore="">accountId</var>) |triple| in the
        [=connected accounts set=]:
        1. If |rp| equals |rpOrigin| and |idp| equals |idpOrigin|, [=list/remove=] |triple| from the
            [=connected accounts set=].
</div>

<!-- ============================================================ -->
## The IdentityCredential Interface ## {#browser-api-identity-credential-interface}
<!-- ============================================================ -->

This specification introduces a new type of {{Credential}}, called an {{IdentityCredential}}:

<pre class="idl">
  dictionary IdentityCredentialDisconnectOptions : IdentityProviderConfig {
    required USVString accountHint;
  };

  [Exposed=Window, SecureContext]
  interface IdentityCredential : Credential {
    static Promise&lt;undefined&gt; disconnect(IdentityCredentialDisconnectOptions options);
    readonly attribute USVString? token;
    readonly attribute boolean isAutoSelected;
    readonly attribute USVString configURL;
  };
</pre>

<dl>
    :   <b>{{Credential/id}}</b>
    ::  The {{Credential/id}}'s attribute getter returns the empty string.
    :   <b>{{IdentityCredential/token}}</b>
    ::  The {{IdentityCredential/token}}'s attribute getter returns the value it is set to.
        It represents the minted {{IdentityAssertionResponse/token}} provided by the [=IDP=].
    :   <b>{{IdentityCredential/isAutoSelected}}</b>
    ::  {{IdentityCredential/isAutoSelected}}'s attribute getter returns the value it is
        set to. It represents whether the user's identity credential was automatically selected when
        going through the UI flow which resulted in this {{IdentityCredential}}.
    : <b>{{IdentityCredential/configURL}}</b>
    :: The {{IdentityCredential/configURL}}'s attribute getter returns the value it is set to.
        It represents the config URL corresponding to the [=IDP=] which issued this credential.
    :   <b>{{Credential/[[type]]}}</b>
    ::  The {{IdentityCredential}}'s {{Credential/[[type]]}}'s value is "<b>identity</b>".
    :   <b>{{Credential/[[discovery]]}}</b>
    ::  The {{IdentityCredential}}'s {{Credential/[[discovery]]}}'s value is
        {{Credential/[[discovery]]/remote}}.
</dl>

The main entrypoint in this specification is through the entrypoints exposed
by the [[CM]] API.

<!-- ============================================================ -->
### The disconnect method ### {#browser-api-identity-credential-disconnect}
<!-- ============================================================ -->

<div algorithm="identity-credential-disconnect">
When the static {{IdentityCredential/disconnect}} method is invoked, given an
{{IdentityCredentialDisconnectOptions}} |options|, perform the following steps:

    1. Let |globalObject| be the [=current global object=].
    1. Let |document| be |globalObject|'s [=associated Document=].
    1. If |document| is not [=allowed to use=] the [=identity-credentials-get=]
        [=policy-controlled feature=], throw a "{{NotAllowedError}}" {{DOMException}}.
    1. Let |promise| be a new {{Promise}}.
    1. [=In parallel=], [=attempt to disconnect=] given |options|, |promise|, and |globalObject|.
    1. Return |promise|.
</div>

<div algorithm>
When asked to <dfn>attempt to disconnect</dfn> given an {{IdentityCredentialDisconnectOptions}}
|options|, a {{Promise}} |promise|, and a |globalObject|, perform the following steps:

    1. Assert: these steps are running [=in parallel=].
    1. Let |configUrl| be the result of running [=parse url=] with |options|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. If |configUrl| is failure, [=reject=] |promise| with an "{{InvalidStateError}}"
        {{DOMException}}.
    1. Run a [[!CSP]] check with a [[CSP#directive-connect-src|connect-src]] directive on the URL
        passed as |configUrl|. If it fails, [=reject=] |promise| with a "{{NetworkError}}"
        {{DOMException}}.
    1. If there is another pending {{IdentityCredential/disconnect}} call for this |globalObject|
        (e.g., it has not yet thrown an exception or its associated {{Promise}} has not yet been
        resolved), [=reject=] |promise| with a "{{NetworkError}}" {{DOMException}}.
    1. If |configUrl| is not a [=potentially trustworthy origin=], [=reject=] |promise| with a
        "{{NetworkError}}" {{DOMException}}.
    1. If the user has disabled the FedCM API on the |globalObject|, [=reject=] |promise| with a
        "{{NetworkError}}" {{DOMException}}.
    1. If there does not exist an account |account| such that [=connected accounts set=]
        [=list/contains=] the result of [=compute the connected account key=] given |account|,
        |options|, and |globalObject|, then [=reject=] |promise| with a "{{NetworkError}}"
        {{DOMException}}. This check can be performed by iterating over the
        [=connected accounts set=] or by keeping a separate data structure to make this lookup fast.
    1. Let |config| be the result of running [=fetch the config file=] with
        |provider| and |globalObject|.
    1. If |config| is failure, [=reject=] |promise| with a "{{NetworkError}}" {{DOMException}}.
    1. Let |disconnectUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|.{{IdentityProviderAPIConfig/disconnect_endpoint}}, and |globalObject|.
    1. If |disconnectUrl| is failure, [=reject=] |promise| with a "{{NetworkError}}"
        {{DOMException}}.
    1. [=Send a disconnect request=] with |disconnectUrl|, |options|, and |globalObject|, and let
        |result| be the result.
    1. Let |idpOrigin| be the [=url/origin=] corresponding to |configUrl|.
    1. Let |rpOrigin| be |globalObject|'s [=associated Document=]'s [=Document/origin=].
    1. If |result| is failure:
        1. [=Remove all connections=] given |rpOrigin| and |idpOrigin|.
        1. [=Reject=] |promise| with a "{{NetworkError}}" {{DOMException}}.
        1. Return.
    1. Let |accountId| be |result| (note that it is not failure).
    1. [=Remove a connection=] using |accountId|, |rpOrigin|, and |idpOrigin|, and let
        |wasAccountRemoved| be the result.
    1. If |wasAccountRemoved| is false, [=remove all connections=] given |rpOrigin| and |idpOrigin|.
    1. [=Resolve=] |promise|.
</div>

<!-- ============================================================ -->
#### Disconnect request #### {#disconnect-request}
<!-- ============================================================ -->

The [=send a disconnect request=] algorithm sends a request to disconnect an account that has
previously been used for federated login in the [=RP=].

<div algorithm>
When asked to <dfn>send a disconnect request</dfn>, given a <a spec=url for=/>URL</a>
|disconnectUrl|, and {{IdentityCredentialDisconnectOptions}} |options|, and a |globalObject|,
perform the following steps. This returns an {{USVString}} or failure.

    1. Let |requestBody| be the result of running [=urlencoded serializer=] with a list containing:
        1. ("client_id", |options|'s {{IdentityProviderConfig/clientId}})
        1. ("account_hint",  |options|'s {{IdentityCredentialDisconnectOptions/accountHint}})
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |disconnectUrl|
        :  [=request/method=]
        :: "POST"
        :  [=request/body=]
        :: the [=UTF-8 encode=] of |requestBody|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: |globalObject|'s [=associated document=]'s [=Document/origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/x-www-form-urlencoded`
        :  [=request/credentials mode=]
        :: "include"
        :  [=request/mode=]
        :: "cors"

    1. Let |accountId| be null.
    1. [=Fetch request=] with |request| and |globalObject|, and with
        <var ignore>processResponseConsumeBody</var> set to the following steps given a
        <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to a {{DisconnectedAccount}}, |account|.
        1. If one of the previous two steps threw an exception, set |accountId| to failure
            and return.
        1. Set |accountId| to |account|'s {{DisconnectedAccount/account_id}}.
    1. Wait for |accountId| to be set.
    1. Return |accountId|.
</div>

<xmp class="idl">
dictionary DisconnectedAccount {
  required USVString account_id;
};
</xmp>

<!-- ============================================================ -->
### The CredentialRequestOptions ### {#browser-api-credential-request-options}
<!-- ============================================================ -->

This section defines the dictionaries passed into the JavaScript call:

<div class=example>
```js
const credential = await navigator.credentials.get({
  identity: { // IdentityCredentialRequestOptions
    providers: [{  // sequence<IdentityCredentialRequestOptions>
      configURL: "https://idp.example/manifest.json", // IdentityProviderConfig.configURL
      clientId: "123", // IdentityProviderConfig.clientId
      nonce: "nonce" // IdentityProviderConfig.nonce
    }]
  }
});
```
</div>

This specification introduces an extension to the {{CredentialRequestOptions}} object:

<pre class="idl">
  partial dictionary CredentialRequestOptions {
    IdentityCredentialRequestOptions identity;
  };
</pre>

The {{IdentityCredentialRequestOptions}} contains a list of
{{IdentityProviderConfig}}s that the [=RP=] supports and has
pre-registered with (i.e. the [=IDP=] has given the [=RP=] a `clientId`).
The {{IdentityCredentialRequestOptions}} also contains an
{{IdentityCredentialRequestOptionsContext}}, which the user agent can use to
provide a more meaningful dialog to users, and an
{{IdentityCredentialRequestOptionsMode}}, which the user agent can use to
specify different behaviors or dialog types.

<xmp class=idl>
enum IdentityCredentialRequestOptionsContext {
  "signin",
  "signup",
  "use",
  "continue"
};

enum IdentityCredentialRequestOptionsMode {
  "active",
  "passive"
};

dictionary IdentityCredentialRequestOptions {
  required sequence<IdentityProviderRequestOptions> providers;
  IdentityCredentialRequestOptionsContext context = "signin";
  IdentityCredentialRequestOptionsMode mode = "passive";
};
</xmp>

Each {{IdentityProviderConfig}} represents an [=IDP=] that
the [=RP=] supports (e.g. that it has a pre-registration agreement with).

<xmp class=idl>
dictionary IdentityProviderConfig {
  required USVString configURL;
  required USVString clientId;
};

dictionary IdentityProviderRequestOptions : IdentityProviderConfig {
  USVString nonce;
  DOMString loginHint;
  DOMString domainHint;
  sequence<USVString> fields;
  any params;
};
</xmp>

<dl>
    :   <b>{{IdentityProviderConfig/configURL}}</b>
    ::  The URL of the configuration file for the identity provider.
    :   <b>{{IdentityProviderConfig/clientId}}</b>
    ::  The {{id_assertion_endpoint_request/client_id}} provided to the [=RP=] out of band by the [=IDP=]
    :   <b>{{IdentityProviderRequestOptions/nonce}}</b>
    ::  A random number of the choice of the [=RP=]. It is generally used to associate a client
        session with a {{IdentityAssertionResponse/token}} and to mitigate replay attacks.
        Therefore, this value should have sufficient entropy such that it would be hard to guess.
    :   <b>{{IdentityProviderRequestOptions/loginHint}}</b>
    ::  A string representing the login hint corresponding to an account which the RP wants the user
        agent to show to the user. If provided, the user agent will not show accounts which do not
        match this login hint value. It generally matches some attribute from the desired
        {{IdentityProviderAccount}}.
    :   <b>{{IdentityProviderRequestOptions/domainHint}}</b>
    ::  A string representing the domain hint corresponding to a domain which the [=RP=] is
        interested in, or "any" if the [=RP=] wants any account associated with at least one domain
        hint. If provided, the user agent will not show accounts which do not match the domain hint
        value.
</dl>

<!-- ============================================================ -->
### The <code>\[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</code> internal method ### {#browser-api-rp-sign-in}
<!-- ============================================================ -->

The {{Credential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}
algorithm runs in parallel inside [[credential-management#algorithm-request]] to request
credentials and returns an {{IdentityCredential}} or an error.

This [=internal method=] accepts three arguments:

<dl dfn-type="argument" dfn-for="IdentityCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">
    :   <dfn>origin</dfn>
    ::  This argument is the [=relevant settings object=]'s
         [=environment settings object/origin=], as determined by the
         calling {{CredentialsContainer/get()}} implementation, i.e.,
         {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a>
         abstract operation.
    :   <dfn>options</dfn>
    ::  This argument is a {{CredentialRequestOptions}} object whose
        {{CredentialRequestOptions/identity}} member [=map/exists=].
    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the
         caller's [=environment settings object=] is
         [=same-origin with its ancestors=]. It is [FALSE] if caller is cross-origin.

        Note: Invocation of this [=internal method=] indicates that it was allowed by
        [=permissions policy=], which is evaluated at the [[!CREDENTIAL-MANAGEMENT-1]] level.
        See [[#permissions-policy-integration]]. As such,
            <var ignore=''>sameOriginWithAncestors</var> is unused.

</dl>

The <var ignore="">options</var>.{{CredentialRequestOptions/signal}} is used as an abort signal for the
requests.

<div algorithm="[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">
When the {{IdentityCredential}}'s
<dfn for="IdentityCredential" method>\[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</dfn>
algorithm is invoked, the user agent MUST execute the following steps. This returns an
{{IdentityCredential}} (or throws an error to the caller).

    1. Assert: These steps are running [=in parallel=].
    1. If
        |options|["{{CredentialRequestOptions/identity}}"]["{{IdentityCredentialRequestOptions/providers}}"]
        is [=list/empty=], [=queue a global task=] on the [=DOM manipulation task source=] given
        |globalObject| to throw a new "{{NetworkError}}" {{DOMException}}.

        Note: The |globalObject| is not currently passed onto the
        {{Credential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}
        algorithm. See <a href="https://github.com/w3c/webappsec-credential-management/issues/210">issue</a>.
    1. Let |providerList| be |options|["{{CredentialRequestOptions/identity}}"]["{{IdentityCredentialRequestOptions/providers}}"].
    1. Let |credential| be the result of running [=create an IdentityCredential=] with |providerList|,
        |options|, and |globalObject|.

        Note: The |globalObject| is not currently passed onto the
        {{Credential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}
        algorithm. See <a href="https://github.com/w3c/webappsec-credential-management/issues/210">issue</a>.

    1. If |credential| is a pair:
        1. Let |throwImmediately| be the value of the second element of the pair.
        1. The user agent SHOULD wait a random amount of time
            before the next step if all of the following conditions hold:
            * |throwImmediately| is false
            * The <dfn>promise rejection delay</dfn> was not disabled by
                [=setdelayenabled|user agent automation=]
            * The user agent has not implemented another way to prevent
                exposing to the RP whether the user has an account logged
                in to the RP

            Note: The intention here is as follows. If the the promise was resolved immediately,
                then an RP could infer that no dialog was shown because the promise was
                resolved quickly, after just the network delay. A shown dialog implies
                that the user is logged in to one or more accounts of the IDP. To prevent
                this information leakage, especially without user confirmation, this delay is specified.
                However, UAs may have different UI approaches here and prevent it in a different way.
        1. [=Queue a global task=] on the [=DOM manipulation task source=]
            to throw a new "{{NetworkError}}" {{DOMException}}.
    1. Otherwise, return |credential|.
</div>

<!-- ============================================================ -->
### Create an IdentityCredential ### {#create-identity-credential}
<!-- ============================================================ -->

The <a>create an IdentityCredential</a> algorithm invokes the various FedCM fetches, shows the user
agent UI, and creates the {{IdentityCredential}} that is then returned to the [=RP=].

<div algorithm="create an IdentityCredential">
To <dfn>create an IdentityCredential</dfn> given a [=sequence=] of  {{IdentityProviderRequestOptions}}
|providerList|, a {{CredentialRequestOptions}} |options|, and a
|globalObject|, run the following steps. This returns an {{IdentityCredential}}
or a pair (failure, bool), where the bool indicates whether to skip delaying
the exception thrown.
    1. Assert: These steps are running [=in parallel=].
    1. Let |mode| be |options|'s {{IdentityCredentialRequestOptions/mode}}.
    1. If |mode| is {{IdentityCredentialRequestOptionsMode/active}}:
        1. If |providerList|'s [=list/size=] is not equal to 1, return (failure, true).
        1. Assert: |globalObject| is a {{Window}}.
        1. If |globalObject| does not have [=transient activation=], return (failure, true).
        1. Otherwise, if there is a pending request where {{IdentityCredentialRequestOptionsMode}} is
            {{IdentityCredentialRequestOptionsMode/passive}} on |globalObject|'s [=Window/navigable=]'s
            [=navigable/top-level traversable=] or on any of its descendants, reject the pending
            request with a "{{NetworkError}}" {{DOMException}}.
    1. The user agent MAY wait an arbitrary amount of time before continuing with the next steps.
        The user agent MAY also return (failure, false) at this point or after some arbitrary wait.
        The user agent MAY also set |providerList| to a subset of itself after some arbitrary wait.

        <div class="note">
        NOTE: For example, the user agent could do any of the following:
            * Show an identity provider selector and only proceed once
                  the user confirms their desire to use an identity provider.
            * Provide a button in the URL bar and wait for user input
                  before continuing. 
            * Use previous user behavior to determine not to show any
                  UI to the user and silently reject the request.
        </div>
    1. Let |mediation| be |options|'s {{CredentialRequestOptions/mediation}}.
    1. Let |providerMap| be a new [=map=].
    1. For each |provider| in |providerList|:
        Note: The fetches performed in these steps to populate |providerMap| can be performed at the
            same time, e.g., the second [=IDP=]'s fetches can be started before the first ones finish,
            since these are indepedent.
        1. Let |providerOrigin| be the [=/origin=] of |provider|'s {{IdentityProviderConfig/configURL}}.
        1. If |providerMap| [=map/contains=] |providerOrigin|, return (failure, true).
        1. Let |loginStatus| be the result of [=get the login status=] with |providerOrigin|.
        1. If |loginStatus| is [=unknown=], a user agent MAY set it to [=logged-out=].
        1. If |loginStatus| is [=logged-out=]:
            1. If |mode| is {{IdentityCredentialRequestOptionsMode/active}}:
                1. Let |result| be the result of running
                    [=fetch the config file and show an IDP login dialog=] with
                    |provider| and |globalObject|.
                1. If |result| is failure, return (failure, true).
            1. Otherwise, set |providerMap|[|providerOrigin|] to "logged-out" and [=continue=].
        1. Let |requiresUserMediation| be |providerOrigin|'s [=requires user mediation=].
        1. If |requiresUserMediation| is true and |mediation| is
            "{{CredentialMediationRequirement/silent}}", [=continue=].
        1. Let |config| be the result of running [=fetch the config file=] with
            |provider| and |globalObject|.
        1. If |config| is failure, [=continue=].
        1. <dfn>Fetch accounts step</dfn>: Let |accountsList| be the result of
            [=fetch the accounts=] with |config|, |provider|, and |globalObject|.
        1. If |accountsList| is failure, or the size of |accountsList| is 0:
            1. [=Set the login status=] of |providerOrigin| to [=logged-out=].
                A user agent may decide to skip this step if no credentials were
                sent to server.

                Note: For example, if the fetch failed due to a DNS error, no
                    credentials were sent and therefore the [=IDP=] did not learn
                    the user's identity. In this situation, we do not know whether
                    the user is signed in or not and so we may not want to reset
                    the status.
            1. If |loginStatus| is [=logged-in=], set |providerMap|[|providerOrigin|] to "mismatch"
                and [=continue=].
        1. Assert: |accountsList| is not failure and the size of |accountsList| is not 0.
        1. [=Set the login status=] for |providerOrigin| to [=logged-in=].
        1. For each |acc| in |accountsList|:
            1. If |acc|["{{IdentityProviderAccount/picture}}"] is present, [=fetch the account picture=]
                with |acc| and |globalObject|. If the [=user agent=] displays this picture to
                the user at any point, it MUST reuse the result of this fetch instead of redownloading
                the picture.

                Note: We require downloading the pictures here before we potentially filter the account
                    list so that the identity provider cannot determine what hints were provided
                    based on which fetches occurred.
        1. If |provider|'s {{IdentityProviderRequestOptions/loginHint}} is not empty:
            1. For every |account| in |accountList|, remove |account| from |accountList| if |account|'s
                {{IdentityProviderAccount/login_hints}} does not [=list/contain=] |provider|'s
                {{IdentityProviderRequestOptions/loginHint}}.
            1. If |accountList| is now empty, set |providerMap|[|providerOrigin|] to "mismatch" and
                continue.
        1. If |provider|'s {{IdentityProviderRequestOptions/domainHint}} is not empty:
            1. For every |account| in |accountList|:
                1. If {{IdentityProviderRequestOptions/domainHint}} is "any":
                    1. If |account|'s {{IdentityProviderAccount/domain_hints}} is empty, remove
                        |account| from |accountList|.
                1. Otherwise, remove |account| from |accountList| if |account|'s
                    {{IdentityProviderAccount/domain_hints}} does not [=list/contain=] |provider|'s
                    {{IdentityProviderRequestOptions/domainHint}}.
            1. If |accountList| is now empty, set |providerMap|[|providerOrigin|] to "mismatch" and
                continue.
        1. If |config|.{{IdentityProviderAPIConfig/account_label}} is present:
            1. For every |account| in |accountList|, remove |account| from |accountList| if |account|'s
                {{IdentityProviderAccount/label_hints}} does not [=list/contain=]
                |config|.{{IdentityProviderAPIConfig/account_label}}.
            1. If |accountList| is now empty, set |providerMap|[|providerOrigin|] to "mismatch" and
                continue.
        1. Set |providerMap|[|providerOrigin|] to |accountsList|.
    1. If |providerMap| [=map/is empty=], return (failure, false).
    1. Let |registeredAccount| and |numRegisteredAccounts| be null and 0, respectively.
    1. Let |selectedAccount| be null.
    1. For each (|providerOrigin|, |value|) in |providerMap|:
        1. If |value| is not a [=list=] |accountsList|, [=continue=].
        1. For each |acc| in |accountsList|:
            1. If |acc| is [=eligible for auto reauthentication=] given the relevant |provider|, and
                |globalObject|, set |registeredAccount| to |acc|, increase |numRegisteredAccounts| by 1,
                and set |requiresUserMediation| be |providerOrigin|'s [=requires user mediation=].
    1. If |mediation| is not "{{CredentialMediationRequirement/required}}", |requiresUserMediation|
        is false, |numRegisteredAccounts| is equal to 1, and |providerMap|'s [=map/values=] do not
        [=map/contain=] "mismatch":
        1. Set |selectedAccount| to |registeredAccount| and |permission| to true. When doing this, the user
            agent MAY show some UI to the user indicating that they are being
            <dfn>auto-reauthenticated</dfn>.
        1. Set |isAutoSelected| to true.
    1. Otherwise, if |mediation| is "{{CredentialMediationRequirement/silent}}" and |providerMap|'s
        [=map/values=] do not [=map/contain=] "mismatch", return (failure, true).
    1. Let |permission|, |permissionRequested|, and |isAutoSelected| be set to false.
    1. Let |allAccounts| be an empty [=list=].
    1. Build UI by adding the following for each (|providerOrigin|, |value|) in |providerMap|:
        1. If |value| is "logged-out", the user agent adds one of the following:
            * Nothing: no UI is shown regarding this [=IDP=].
            * Prompt to continue with this [=IDP=]. If the user continues, the user
                agent SHOULD set the login status to [=unknown=]. This MAY include an
            * Return (failure, false).
            * Prompt the user whether to continue. If the user continues, the user
                agent SHOULD set |loginStatus| to [=unknown=]. This MAY include an
                affordance to [=show an IDP login dialog=].
                * If the user triggers this affordance:
                    1. Let |result| be the result of running
                        [=fetch the config file and show an IDP login dialog=]
                        with the relevant |provider| and |globalObject|.
                    1. If |result| is failure, return (failure, true).
        1. Otherwise, if |value| is "mismatch", add contents indicating this |providerOrigin|
            to the user. The contents SHOULD provide an affordance for the user to trigger
            the [=show an IDP login dialog=] algorithm with the relevant |config| and |provider|;
            this dialog is the <dfn>confirm IDP login dialog</dfn>.

            Note: This situation happens when the browser expects the user
                to be signed in, but the accounts fetch indicated that the user
                is signed out.

            Note: This dialog ensures that silent tracking of the user is
                impossible by always showing UI of some kind when credentials
                were sent to the server.

            * If the [=show an IDP login dialog=] algorithm was triggered:

                1. Let |result| be the result of that algorithm.
                1. If |result| is failure, return (failure, true). The user
                    agent MAY show a dialog to the user before or after
                    returning failure indicating this failure.
                1. Otherwise, go back to the [=fetch accounts step=] to get an updated
                    value of |providerMap| for this [=IDP=].
        1. Otherwise, |value| is a [=list=] of accounts. [=list/Extend=] |allAccounts| with |value|.
    1. Also include a UI affordance to close the dialog. If the user closes this dialog, return (failure,
        true).
    1. <dfn for="create identity credential">Show accounts</dfn> step: if |allAccounts| is not [=list/empty=], also add UI to present the account options to the user.
        If the user selects an account, perform the following steps:
            1. Set |selectedAccount| to the chosen {{IdentityProviderAccount}}.
            1. Close the dialog.
    1. If the [=user agent=] created any dialogs requesting user choice or permission in the previous
        steps, wait until they are closed.
    1. If |permission| is false, then return (failure, true).
    1. Assert: |selectedAccount| is not null.
    1. Let |credential| be the result of running the [=fetch an identity assertion=] algorithm with
        |selectedAccount|'s {{IdentityProviderAccount/id}}, |permissionRequested|, |isAutoSelected|,
        |provider|, |config|, and |globalObject|.
    1. Return |credential|.
</div>

<div class="issue" heading="extension">
An extension may use the following instead of the [=create identity credential/show accounts=] step, where
    |permissionRequested| is sometimes set:
    1. If |allAccounts| is not [=list/empty=], also add UI to present the account options to the user as follows:
        1. If |allAccounts|'s size is 1 and <var ignore="">providerMap</var>'s [=map/values=] do not [=map/contain=]
            "mismatch":
            1. Set |selectedAccount| to |allAccounts|[0].
            1. If [=compute the connection status=] of |selectedAccount|, the relevant |provider|,
                and |globalObject| returns [=compute the connection status/connected=], show a
                dialog to request user permission to sign in via |selectedAccount|, and set the
                result in |permission|. The user agent MAY use |options|'s
                {{IdentityCredentialRequestOptions/context}} and |options|'s
                {{IdentityCredentialRequestOptions/mode}} to customize the dialog.
            1. Otherwise, set |permission| to the result of running [=request permission to sign-up=]
                algorithm with |selectedAccount|, the relevant |config|, the relevant |provider|,
                and |globalObject|. Also set |permissionRequested| to true if the user agent
                [=supports showing a permission prompt=].
        1. Otherwise:
            1. Show UI to allow the user to select an account chooser displaying the options from
                <var ignore="">accountsList</var>.
            1. If the user selects an account, perform the following steps:
                1. Set |selectedAccount| to the chosen {{IdentityProviderAccount}}.
                1. If [=compute the connection status=] of |selectedAccount|, the relevant |provider|,
                    and |globalObject| is [=compute the connection status/connected=], set |permission|
                    to true.
                1. Otherwise, if |provider|.{{IdentityProviderRequestOptions/fields}} is [=list/empty=],
                    [=create a connection between the RP and the IdP account=] with |provider|, |account|,
                    and |globalObject|, and set |permission| to true.
                    Note: The connection would normally be created in the [=request permission to sign-up=]
                        algorithm, but we do not want to show an extra dialog in this case.
                1. Otherwise:
                    1. Set |permission| to the result of running the [=request permission to sign-up=]
                        algorithm with |selectedAccount|, the relevant |config|, the relevant |provider|,
                        and |globalObject|.
                    1. Set |permissionRequested| to true.
</div>


<!-- ============================================================ -->
### Fetch the config file ### {#fetch-config-file}
<!-- ============================================================ -->

The <a>fetch the config file</a> algorithm fetches both the [=well-known file=] and the config file from
the [=IDP=], checks that the config file is mentioned in the [=well-known file=], and returns the config.

<div algorithm>
To <dfn>fetch the config file</dfn> given an {{IdentityProviderRequestOptions}} |provider| and
|globalObject|, run the following steps. This returns an {{IdentityProviderAPIConfig}}
or failure.
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. If |configUrl| is failure, return failure.
    1. Run a [[!CSP]] check with a [[CSP#directive-connect-src|connect-src]] directive on the URL
        passed as |configUrl|. If it fails, return failure.
    1. If |configUrl| is not a [=potentially trustworthy URL=], return failure.
    1. Let |rootUrl| be a new [=/URL=].
    1. Set |rootUrl|'s [=url/scheme=] to |configUrl|'s [=url/scheme=].
    1. Set |rootUrl|'s [=url/host=] to |configUrl|'s [=url/host=]'s [=host/registrable domain=].
    1. Set |rootUrl|'s [=url/path=] to the <a>list</a> «".well-known", "web-identity"».
    1. Let |config|, |wellKnown|, |accounts_url|, and |login_url| be null.
    1. Let |skipWellKnown| be false.
    1. Let |rpOrigin| be |globalObject|'s [=associated Document=]'s [=Document/origin=].
    1. If |rpOrigin| is not an [=opaque origin=], and |rootUrl|'s [=url/host=] is equal
        to |rpOrigin|'s [=host/registrable domain=], and |rootUrl|'s [=url/scheme=] is
        equal to |rpOrigin|'s [=origin/scheme=], set |skipWellKnown| to true.

        Note: Because domain cookies are valid across an entire site, there is no privacy
            benefit from doing the well-known check if the RP and IDP are in the same site.
    1. Otherwise:
        1. Let |wellKnownRequest| be a new [=/request=] as follows:

            :  [=request/URL=]
            :: |rootUrl|
            :  [=request/client=]
            :: null
            :  [=request/window=]
            :: "no-window"
            :  [=request/service-workers mode=]
            :: "none"
            :  [=request/destination=]
            :: "webidentity"
            :  [=request/origin=]
            :: a unique [=opaque origin=]
            :  [=request/header list=]
            :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
                [=header/value=] set to `application/json`
            :  [=request/referrer policy=]
            :: "no-referrer"
            :  [=request/credentials mode=]
            :: "omit"
            :  [=request/mode=]
            :: "no-cors"

            Issue: The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
            with [=request/mode=] set to "user-agent-no-cors". See the relevant
            [pull request](https://github.com/whatwg/fetch/pull/1533) for details.

        1. [=Fetch request=] with |wellKnownRequest| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
            set to the following steps, given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
            1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
                |responseBody|.
            1. Set |wellKnown| to the result of [=converted to an IDL value|converting=] |json|
                to an {{IdentityProviderWellKnown}}.
            1. If one of the previous two steps threw an exception, or if the
                [=list/size=] of |wellKnown|["{{IdentityProviderWellKnown/provider_urls}}"] is
                greater than 1, set |wellKnown| to failure.

                Issue: [relax](https://github.com/fedidcg/FedCM/issues/333) the size of the
                provider_urls array.

    1. Let |configRequest| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |configUrl|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/json`
        :  [=request/referrer policy=]
        :: "no-referrer"
        :  [=request/credentials mode=]
        :: "omit"
        :  [=request/mode=]
        :: "no-cors"

        Issue: The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
        with [=request/mode=] set to "user-agent-no-cors". See the relevant
        [pull request](https://github.com/whatwg/fetch/pull/1533) for details.

    1. [=Fetch request=] with |configRequest| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderAPIConfig}} stored
            in |config|.
        1. If one of the previous two steps threw an exception, set |config| to failure.
        1. Set |login_url| to the result of [=computing the manifest URL=] with |provider|,
            |config|.{{IdentityProviderAPIConfig/login_url}}, and |globalObject|.
        1. Set |accounts_url| to the result of [=computing the manifest URL=] with |provider|,
            |config|.{{IdentityProviderAPIConfig/accounts_endpoint}}, and |globalObject|.
        1. If |login_url| or |accounts_url| is failure, set |config| to failure.
    1. Wait for |config| to be set.
    1. If |config| is failure, return failure.
    1. If |skipWellKnown| is true, return |config|.
    1. Wait for |wellKnown| to be set.
    1. If |wellKnown| is failure, return failure.
    1. If |wellKnown|.{{IdentityProviderWellKnown/accounts_endpoint}} and
        |wellKnown|.{{IdentityProviderWellKnown/login_url}} are set:
        1. Let |well_known_accounts_url| be the result of [=computing the manifest URL=] with
            |provider|, |wellKnown|.{{IdentityProviderWellKnown/accounts_endpoint}},
            and |globalObject|.
        1. Let |well_known_login_url| be the result of [=computing the manifest URL=] with |provider|,
            |wellKnown|.{{IdentityProviderWellKnown/login_url}}, and |globalObject|.
        1. If |well_known_accounts_url| is not [=url/equal=] to |accounts_url|, return failure.
        1. If |well_known_login_url| is not [=url/equal=] to |login_url|, return failure.
    1. Otherwise:
        1. Let |allowed_config_url| be the result of [=computing the manifest URL=] with |provider|,
            |wellKnown|.{{IdentityProviderWellKnown/provider_urls}}[0], and |globalObject|.
        1. If |allowed_config_url| is not [=url/equal=] to |configUrl|, return failure.
    1. Return |config|.

</div>

NOTE: a two-tier file system is used in order to prevent the [=IDP=] from easily determining the [=RP=]
that a user is visiting by encoding the information in the config file path. This issue is solved by
requiring a [=well-known file=] to be on the root of the [=IDP=]. The config file itself can be anywhere, but
it will not be used if the user agent does not find it in the [=well-known file=]. This allows the [=IDP=]
to keep their actual config files on an arbitary path while allowing the user agent to prevent config file
path manipulation to fingerprint (for instance, by including the RP in the path). See
[[#manifest-fingerprinting]].

<xmp class="idl">
dictionary IdentityProviderWellKnown {
  sequence<USVString> provider_urls;
  USVString accounts_endpoint;
  USVString login_url;
};

dictionary IdentityProviderIcon {
  required USVString url;
  unsigned long size;
};

dictionary IdentityProviderBranding {
  USVString background_color;
  USVString color;
  sequence<IdentityProviderIcon> icons;
  USVString name;
};

dictionary IdentityProviderAPIConfig {
  required USVString accounts_endpoint;
  USVString client_metadata_endpoint;
  required USVString id_assertion_endpoint;
  required USVString login_url;
  USVString disconnect_endpoint;
  IdentityProviderBranding branding;
  USVString account_label;
};
</xmp>

<!-- ============================================================ -->
### Fetch the accounts ### {#fetch-accounts}
<!-- ============================================================ -->

The <a>fetch the accounts</a> algorithm fetches the [=accounts endpoint=] to determine the
list of [=IDP=] accounts that the user is signed in to, so that the user agent can later show the
FedCM UI to the user.

<div algorithm>
To <dfn>fetch the accounts</dfn> given an {{IdentityProviderAPIConfig}} |config|, an
{{IdentityProviderRequestOptions}} |provider|, and |globalObject|, run the following steps. This
returns an {{IdentityProviderAccountList}}.
    1. Let |accountsUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|["{{IdentityProviderAPIConfig/accounts_endpoint}}"], and |globalObject|.
    1. If |accountsUrl| is failure, return an empty list.
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |accountsUrl|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/json`
        :  [=request/referrer policy=]
        :: "no-referrer"
        :  [=request/credentials mode=]
        :: "include"
        :  [=request/mode=]
        :: "no-cors"

        Issue: The credentialed fetch in this algorithm can lead to a timing attack that leaks the
        user's identities before the user grants permission. This is an active area of investigation
        that is being explored [here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1089040953).

        Issue: The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
        with [=request/mode=] set to "user-agent-no-cors". See the relevant
        [pull request](https://github.com/whatwg/fetch/pull/1533) for details.

        Note: This fetch should only send Same-Site=None cookies. Specifying this will require
        [cookie layering](https://github.com/httpwg/http-extensions/issues/2084).

    1. Let |accountsList| be null.
    1. [=Fetch request=] with |request| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderAccountList}}, and
            store the result in |accountsList|.
        1. If one of the previous two steps threw an exception, or if there is an account in
            |accountsList| that has neither {{IdentityProviderAccount/email}}, {{IdentityProviderAccount/name}},
            {{IdentityProviderAccount/tel}}, nor {{IdentityProviderAccount/username}} set, set |accountsList|
            to failure.

        Note: If the user agent only has space to display two attributes in its account choosers,
            it SHOULD display the first two that are set, in the order `name`, `username`,
            `email`, and `tel`.

        Issue: the accounts list returned here should be validated for repeated ids, as described
        [here](https://github.com/fedidcg/FedCM/issues/336).

    1. Wait for |accountsList| to be set.
    1. Return |accountsList|.
</div>

<xmp class="idl">
dictionary IdentityProviderAccount {
  required USVString id;
  USVString name;
  USVString email;
  USVString tel;
  USVString username;
  USVString given_name;
  USVString picture;
  sequence<USVString> approved_clients;
  sequence<DOMString> login_hints;
  sequence<DOMString> domain_hints;
  sequence<DOMString> label_hints;
};
dictionary IdentityProviderAccountList {
  sequence<IdentityProviderAccount> accounts;
};
</xmp>

<div algorithm>
To <dfn>fetch the account picture</dfn> given an {{IdentityProviderAccount}} |account| and a
|globalObject|, run the following steps:
    1. Let |pictureUrl| be the result of running [=parse url=] with
        |account|["{{IdentityProviderAccount/picture}}"] and |globalObject|.
    1. If |pictureUrl| is failure, abort these steps. The user agent may use a placeholder image.
    1. Let |pictureRequest| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |pictureUrl|
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "image"
        :  [=request/origin=]
        :: a unique [=opaque origin=]
        :  [=request/referrer policy=]
        :: "no-referrer"
        :  [=request/credentials mode=]
        :: "omit"
        :  [=request/mode=]
        :: "no-cors"

        Issue: The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
        with [=request/mode=] set to "user-agent-no-cors". See the relevant
        [pull request](https://github.com/whatwg/fetch/pull/1533) for details.

    1. [=Fetch request=] with |pictureRequest| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
        set to the following steps given a <var ignore=''>response</var> and a |responseBody|:
        1. If |responseBody| is null or failure, the user agent may choose an arbitrary placeholder image
            and associate it with the |account|.
        1. Otherwise, decode |responseBody| into an image, and associate it with |account| if successful. This
            allows the user agent to use the decoded image in a dialog displaying |account|.
</div>

<!-- ============================================================ -->
### Fetch an identity assertion ### {#fetch-identity-assertion}
<!-- ============================================================ -->

The <a>fetch an identity assertion</a> algorithm is invoked after the user has granted permission to
use FedCM with a specific [=IDP=] account. It fetches the [=identity assertion endpoint=] to obtain
the token that will be provided to the [=RP=].

<div algorithm="fetch an identity assertion">
To <dfn>fetch an identity assertion</dfn> given a {{USVString}}
    |accountId|, a boolean <var ignore="">permissionRequested</var>, a boolean |isAutoSelected|, an
    {{IdentityProviderRequestOptions}} |provider|, an {{IdentityProviderAPIConfig}} |config|,
    and |globalObject|, run the following steps. This returns an {{IdentityCredential}} or failure.
    1. Let |tokenUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|["{{IdentityProviderAPIConfig/id_assertion_endpoint}}"], and |globalObject|.
    1. If |tokenUrl| is failure, return failure.
    1. <dfn for="fetch identity assertion">Create a list</dfn>: let |list| be a list with the following entries:
        1. ("client_id", |provider|'s {{IdentityProviderConfig/clientId}})
        1. ("nonce", |provider|'s {{IdentityProviderRequestOptions/nonce}})
        1. ("account_id",  |accountId|)
        1. ("is_auto_selected", |isAutoSelected|)
    1. If |provider|'s {{IdentityProviderRequestOptions/params}} is not empty:
        1. Let |json| be the result of [=serializing a JavaScript value to a JSON string=]
            with |provider|'s {{IdentityProviderRequestOptions/params}}.
        1. If serializing threw an exception, return failure.
        1. Append ("params", |json|) to |list|.
    1. Let |requestBody| be the result of running [=urlencoded serializer=] with |list|.
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |tokenUrl|
        :  [=request/method=]
        :: "POST"
        :  [=request/body=]
        :: the [=UTF-8 encode=] of |requestBody|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: |globalObject|'s [=associated document=]'s [=Document/origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/x-www-form-urlencoded`
        :  [=request/credentials mode=]
        :: "include"
        :  [=request/mode=]
        :: "cors"

    1. Let |credential| be null.
    1. [=Fetch request=] with |request| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityAssertionResponse}}, |token|.
        1. If one of the previous two steps threw an exception, set |credential| to failure
            and return.
        1. If neither {{IdentityAssertionResponse/token}} nor
            {{IdentityAssertionResponse/continue_on}} was specified, set |credential| to failure
            and return.
        1. If {{IdentityAssertionResponse/token}} was specified, let |tokenString|
            be |token|'s {{IdentityAssertionResponse/token}}.
        1.  Otherwise, run these steps [=in parallel=]:
            1. Let |continueOnUrl| be the result of running [=parse url=] with |token|'s
                {{IdentityAssertionResponse/continue_on}} and |globalObject|.
            1. If |continueOnUrl| is failure, set |credential| to failure and return.
            1. If |continueOnUrl| is not [=same origin=] with |tokenUrl|, set |credential|
                to failure and return.
            1. Let |tokenPair| be the result of [=show a continuation dialog=] with |continueOnUrl|.
            1. If |tokenPair| is failure, set |credential| to failure and return.
            1. Let |tokenString| be the first entry of |tokenPair|.
            1. If the second entry of |tokenPair| is not null, set |accountId| to that second entry.
        1. Wait for |tokenString| or |credential| to be set.
        1. If |credential| is set:
            1. Assert that |credential| is set to failure.
            1. Return |credential|.
        1. [=Create a connection between the RP and the IdP account=] with |provider|, |accountId|, and
            |globalObject|.
        1. Let |credential| be a new {{IdentityCredential}} given |globalObject|'s
            <a for="global object">realm</a>.
        1. Set |credential|'s {{IdentityCredential/token}} to |tokenString|.
        1. Set |credential|'s {{IdentityCredential/isAutoSelected}} to
            |isAutoSelected|.
        1. Set |credential|'s {{IdentityCredential/configURL}} to |provider|'s
            {{IdentityProviderConfig/configURL}}.
    1. Wait for |credential| to be set.
    1. Return |credential|.
</div>

<div class="issue">
We may modify the spec to include {{IdentityProviderRequestOptions/fields}} in the
[=fetch identity assertion/create a list=] step.
</div>

<div class="issue" heading="extension">
An extension may add the following steps after the [=fetch identity assertion/create a list=] step:
    1. Let |disclosureShownFor| and |fields| be the empty list.
    1. If |permissionRequested| is true:
        1. Set |fields| to |provider|.{{IdentityProviderRequestOptions/fields}}.
        1. Set |disclosureShownFor| to the subset of strings in |fields| that are
            in the [=list of recognized fields=].
    1. If |fields| is not empty:
        1. Let |fieldsString| be the entries of |fields| concatenated with a comma ("`,`")
            between elements.
        1. Append ("fields", |fieldsString|) to |list|.
    1. If |disclosureShownFor| is not empty:
        1. Let |disclosureString| be the entries of |disclosureShownFor| concatenated
            with a comma ("`,`") between elements.
        1. Append ("disclosure_shown_for", |disclosureString|) to |list|.
    1. If |disclosureShownFor| contains all of "name", "email", and "picture", append
        ("disclosure_text_shown", true) to |list|.

        Note: This parameter exists for backwards compatibility with older identity providers
            that do not yet support `disclosure_shown_for`. At the time, the disclosure text,
            if shown, always included name, email, and picture. Newer identity providers should
            instead check `disclosure_shown_for`.
</div>

<xmp class="idl">
dictionary IdentityAssertionResponse {
  USVString token;
  USVString continue_on;
};
</xmp>

<!-- ============================================================ -->
### Extension: Request permission to sign-up ### {#request-permission-signup}
<!-- ============================================================ -->

<div class="issue" heading="extension">
The following section may be added to an extension spec.

The <a>request permission to sign-up</a> algorithm fetches the [=client metadata endpoint=] of the [=RP=],
waits for the user to grant permission to use the given account, and returns whether the user
granted permission or not.

<div algorithm="request permission to sign-up">
To <dfn>request permission to sign-up</dfn> the user with a given an {{IdentityProviderAccount}} |account|,
an {{IdentityProviderAPIConfig}} |config|, an {{IdentityProviderRequestOptions}} |provider|, and a
|globalObject|, run the following steps. This returns a boolean.
    1. Assert: These steps are running [=in parallel=].
    1. Let |fields| be |provider|.{{IdentityProviderRequestOptions/fields}} or, if not present,
        `["name", "email", "picture"]`.

        Note: Omitted is different from an explicitly present empty list.
    1. Let |metadata| be null.
    1. If |fields| is not [=list/empty=], set |metadata| to the result of running [=fetch the client
        metadata=] with |config|, |provider|, and |globalObject|.
    1. Prompt the user to gather explicit intent to create an account. The user agent MAY use the
        {{IdentityProviderBranding}} to inform the style choices of its UI. Additionally, if the user agent
        <dfn>supports showing a permission prompt</dfn>:

        Note: Identity providers should support showing their own permission prompt using
            {{IdentityAssertionResponse/continue_on}} when the `disclosure_shown_for` parameter
            does not contain the fields required by the IDP. This is to enable user agents that
            do not support showing a permission prompt.

        1. If |fields| is not [=list/empty=]:
            1. If |metadata| is not failure, |metadata|["{{IdentityProviderClientMetadata/privacy_policy_url}}"]
                is defined, and the |provider|'s {{IdentityProviderConfig/clientId}} is not in the list of
                |account|["{{IdentityProviderAccount/approved_clients}}"], then the user agent MUST display
                the |metadata|["{{IdentityProviderClientMetadata/privacy_policy_url}}"] link.
            1. If |metadata| is not failure, |metadata|["{{IdentityProviderClientMetadata/terms_of_service_url}}"]
                is defined, and the |provider|'s {{IdentityProviderConfig/clientId}} is not in the list of
                |account|["{{IdentityProviderAccount/approved_clients}}"], then the user agent MUST display
                the |metadata|["{{IdentityProviderClientMetadata/terms_of_service_url}}"] link.
            1. The user agent MUST prompt the user for permission to share the data in |fields|,
                interpreting the strings in the <dfn>list of recognized fields</dfn> as follows:
                : `"name"`
                :: The user's name as given in {{IdentityProviderAccount}}.{{IdentityProviderAccount/name}}.
                : `"email"`
                :: The user's email address as given in {{IdentityProviderAccount}}.{{IdentityProviderAccount/email}}.
                : `"tel"`
                :: The user's phone number as given in {{IdentityProviderAccount}}.{{IdentityProviderAccount/tel}}.
                : `"username"`
                :: The user's username as given in {{IdentityProviderAccount}}.{{IdentityProviderAccount/username}}.
                : `"picture"`
                :: The user's profile picture as given in {{IdentityProviderAccount}}.{{IdentityProviderAccount/picture}}.

                Any other string is ignored for forwards compatibility.
            1. The user agent MAY use the
                {{IdentityCredentialRequestOptions/context}} and |provider|'s
                {{IdentityCredentialRequestOptions/mode}} to customize the dialog shown.
    1. If the user does not grant permission, return false.
    1. Return true.
</div>

<div algorithm>
To <dfn noexport>fetch the client metadata</dfn> given an {{IdentityProviderAPIConfig}} |config| and
an {{IdentityProviderRequestOptions}} |provider|, run the following steps. This returns an
{{IdentityProviderClientMetadata}} or failure.
    1. If |config|["{{IdentityProviderAPIConfig/client_metadata_endpoint}}"] is not present, return
        failure.
    1. Let |clientMetadataUrl| be the result of [=computing the manifest URL=] given |provider|,
        |config|["{{IdentityProviderAPIConfig/client_metadata_endpoint}}"], and |globalObject|.
    1. If |clientMetadataUrl| is failure, return failure.
    1. Let |request| be a new <a spec=fetch for=/>request</a> as follows:

        :  [=request/url=]
        :: |clientMetadataUrl|
        :  [=request/redirect mode=]
        :: "error"
        :  [=request/client=]
        :: null
        :  [=request/window=]
        :: "no-window"
        :  [=request/service-workers mode=]
        :: "none"
        :  [=request/destination=]
        :: "webidentity"
        :  [=request/origin=]
        :: |globalObject|'s [=associated document=]'s [=Document/origin=]
        :  [=request/header list=]
        :: a [=list=] containing a single [=header=] with [=header/name=] set to `Accept` and
            [=header/value=] set to `application/json`
        :  [=request/credentials mode=]
        :: "omit"
        :  [=request/mode=]
        :: "no-cors"

        Issue: The spec is yet to be updated so that all <a spec=fetch for=/>requests</a> are created
        with [=request/mode=] set to "user-agent-no-cors". See the relevant
        [pull request](https://github.com/whatwg/fetch/pull/1533) for details.

    1. Let |metadata| be null.
    1. [=Fetch request=] with |request| and |globalObject|, and with <var ignore>processResponseConsumeBody</var>
        set to the following steps given a <a spec=fetch for=/>response</a> |response| and |responseBody|:
        1. Let |json| be the result of [=extract the JSON fetch response=] from |response| and
            |responseBody|.
        1. [=converted to an IDL value|Convert=] |json| to an {{IdentityProviderClientMetadata}},
            and store the result in |metadata|.
        1. If one of the previous two steps threw an exception, set |metadata| to failure.
    1. Wait until |metadata| is set.
    1. Return |metadata|.
</div>

<xmp class="idl">
dictionary IdentityProviderClientMetadata {
  USVString privacy_policy_url;
  USVString terms_of_service_url;
};
</xmp>

</div>

<!-- ============================================================ -->
### Helper algorithms ### {#helper-algorithms}
<!-- ============================================================ -->

The following helper algorithms are used during the FedCM flow.

<div algorithm>
To <dfn>parse url</dfn> given a {{USVString}} |stringUrl|, a |globalObject|, and an optional
|baseUrl| (default null), run the following steps. This returns a [=/URL=] or failure.
    1. Let |configUrl| be null.
    1. [=Queue a global task=] on the [=DOM manipulation task source=] given |globalObject| to set
        |configUrl| to the result of running [=url parser=] with |stringUrl| and |baseUrl|.

        Note: a task is queued since the [=url parser=] needs to be run within a task, not
        [=in parallel=].

    1. Wait for |configUrl| to be set.
    1. Return |configUrl|.
</div>

<div algorithm>
To <dfn>fetch request</dfn> given a [=/request=] |request|, |globalObject|, and an algorithm
|processResponseConsumeBody|, run the following steps:
  1. [=Queue a global task=] on the [=network task source=] given |globalObject| to:
      1. [=Fetch=] |request| with <a spec=fetch>processResponseConsumeBody</a> set to
          |processResponseConsumeBody|.

  Note: a task is queued since the [=fetch=] needs to be run within a task, not [=in parallel=].
</div>

<div algorithm>
When <dfn>computing the manifest URL</dfn> given an {{IdentityProviderRequestOptions}} |provider|, a
[=string=] |manifestString|, and |globalObject|, perform the following steps. This returns a
<a spec=url for=/>URL</a> or failure.
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. Let |manifestUrl| be the result of running [=parse url=] given |manifestString| (the relative
        URL), |globalObject|, and |configUrl| (the base URL).
    1. Wait until |manifestUrl| is set.

        Note: This means that passing the manifest string as either an absolute or relative URL is
        allowed.

    1. If |manifestUrl| is failure, return failure.
    1. If |manifestUrl| is not [=same origin=] with |configUrl|, return failure.
    1. If |manifestUrl| is not a [=potentially trustworthy URL=], return failure.
    1. Return |manifestUrl|.
</div>

<div algorithm>
To <dfn>extract the JSON fetch response</dfn> given a <a spec=fetch for=/>response</a> |response|
and a |responseBody|, run the following steps. This returns an [=ordered map=].
    1. Assert: These steps are running on the [=networking task source=].
    1. If |response| is a [=network error=] or its [=response/status=] is not an [=ok status=],
        throw a new "{{NetworkError}}" {{DOMException}}.
    1. Let |mimeType| be the result of <a>extracting a MIME TYPE</a> from |response|'s
        <a for=response>header list</a>.
    1. If |mimeType| is failure or is not a [=JSON MIME Type=], throw a new "{{NetworkError}}"
        {{DOMException}}.
    1. Let |json| be the result of [=parse JSON bytes to a JavaScript value=] passing |responseBody|.
    1. If |json| is a parsing exception, throw a new "{{NetworkError}}" {{DOMException}}.
    1. Return |json|.
</div>

<div algorithm>
To <dfn>show an IDP login dialog</dfn> given an {{IdentityProviderAPIConfig}} |config|, an
{{IdentityProviderConfig}} |provider|, and a |globalObject|, run the following steps. This returns
success or failure.
    1. Assert: these steps are running [=in parallel=].
    1. Let |loginUrl| be null.
    1. [=Queue a global task=] on the [=DOM manipulation task source=] given |globalObject| to set
        |loginUrl| to the result of running [=url parser=] with
        |config|.{{IdentityProviderAPIConfig/login_url}}.
    1. Wait until |loginUrl| is not null.
    1. Assert: |loginUrl| is not failure (the [=user agent=] has previously checked that
        |config|.{{IdentityProviderAPIConfig/login_url}} is a valid URL).
    1. Let |queryList| be a new [=list=].
    1. If |provider|'s {{IdentityProviderRequestOptions/loginHint}} is not empty, [=list/append=]
        ("login_hint", {{IdentityProviderRequestOptions/loginHint}}) to |queryList|.
    1. If |provider|'s {{IdentityProviderRequestOptions/domainHint}} is not empty, [=list/append=]
        ("domain_hint", {{IdentityProviderRequestOptions/domainHint}}) to |queryList|.
    1. If |queryList| is not [=list/empty=]:
        1. Let |queryParameters| be the result of the [=urlencoded serializer=] with |queryList|.
        1. If |loginUrl|'s [=url/query=] is not null or empty, prepend "&" to |queryParameters|.
        1. Append |queryParameters| to |loginUrl|'s [=url/query=].
    1. [=Create a fresh top-level traversable=] with |loginUrl|.
    1. The user agent MAY [=set up browsing context features=] or otherwise
        affect the presentation of this traversable in an implementation-defined
        way.
    1. Wait for one of the following conditions:
        * The user closes the browsing context: return failure.
        * {{IdentityProvider}}.{{IdentityProvider/close}} is called in the
            context of this new traversable:
            1. Close the traversable.
            1. Let |loginStatus| be the result of [=get the login status=]
                with the [=/origin=] of the {{IdentityProviderAPIConfig/login_url}}.

                Note: The IDP login flow may set this value to logged-in using
                    either the [JavaScript](login-status.html#login-status-javascript) or
                    [HTTP header](login-status.html#login-status-http) API during the login
                    flow. It is also possible that this change happened in
                    a different browsing context.
            1. If |loginStatus| is [=logged-in=], return success.
            1. Otherwise, return failure.
</div>

<div algorithm>
To <dfn>show a continuation dialog</dfn> given a |continueOnUrl|, run the
following steps. This returns a failure or a tuple (string, string?) (a token
and an optional account ID).
    1. Assert: these steps are running [=in parallel=].
    1. [=Create a fresh top-level traversable=] with |continueOnUrl|.
    1. The user agent MAY [=set up browsing context features=] or otherwise
        affect the presentation of this traversable in an implementation-defined
        way.
    1. Wait for the first occurence of one of the following conditions:
        * The user closes the browsing context: return failure.
        * {{IdentityProvider}}.{{IdentityProvider/close}} is called in the
            context of this new traversable:
            1. Close the traversable.
            1. Return failure.
        * {{IdentityProvider}}.{{IdentityProvider/resolve()}} is called in
            the context of this new traversable.
            1. Close the traversable.
            1. Let |token| be the token that was passed to that resolve call.
            1. If {{IdentityResolveOptions/accountId}} was specified in the
                resolve call, let |accountId| be that account ID.
            1. Otherwise, let |accountId| be null.
            1. Return (|token|, |accountId|).

</div>

<div algorithm>
To <dfn>fetch the config file and show an IDP login dialog</dfn> given an
{{IdentityProviderConfig}} |provider|, and a |globalObject|, run the following
steps. This returns success or failure.
    1. Assert: these steps are running [=in parallel=].
    1. Let |config| be the result of running [=fetch the config file=]
              with |provider| and |globalObject|.
    1. If |config| is failure, return failure.
    1. [=Show an IDP login dialog=] with |config| and |provider|.
    1. If that algorithm succeeds, return success.
    1. Otherwise, return failure.
</div>

<!-- ============================================================ -->
## The IdentityProvider Interface ## {#browser-api-identity-provider-interface}
<!-- ============================================================ -->

This specification introduces the {{IdentityUserInfo}} dictionary as well as the
{{IdentityProvider}} interface:

<pre class="idl">
  dictionary IdentityUserInfo {
    USVString email;
    USVString name;
    USVString givenName;
    USVString picture;
  };

  dictionary IdentityResolveOptions {
    USVString accountId;
  };

  [Exposed=Window, SecureContext] interface IdentityProvider {
      static undefined close();
      static undefined resolve(DOMString token, optional IdentityResolveOptions options = {});
      static Promise&lt;sequence&lt;IdentityUserInfo&gt;&gt; getUserInfo(IdentityProviderConfig config);
  };
</pre>

Issue: [Decide](https://github.com/fedidcg/FedCM/issues/476) whether {{IdentityProvider}} is the
correct location for the {{IdentityProvider/getUserInfo()}} method.

A {{IdentityProvider/close}} function is provided to signal to the browser that
the login flow is finished. The reason for this function in addition to the
header is that even when the user is already logged in, the login flow may not
be finished yet; for example, an [=IDP=] may want to prompt the user to verify
their phone number. To allow for such flows, the [=IDP=] must call
{{IdentityProvider/close}} when the flow is fully done.

See the [=show an IDP login dialog=] algorithm for more details.

An {{IdentityUserInfo}} represents user account information from a user. This information is exposed
to the [=IDP=] once the user has already used the FedCM API to login in the [=RP=]. That is, it is
exposed when there exists an account |account| such that the [=connected accounts set=] [=list/contains=]
the triple ([=RP=], [=IDP=], |account|). The information matches what is received from the
<a>accounts endpoint</a>. The [=IDP=] can obtain this information by invoking the
{{IdentityProvider/getUserInfo()}} static method from an iframe matching the [=/origin=] of its
{{IdentityProviderConfig/configURL}}.

<div class="example">
```js
const userInfo = await IdentityProvider.getUserInfo({
    configUrl: "https://idp.example/fedcm.json",
    clientId: "client1234"
});

if (userInfo.length > 0) {
  // It's up to the IDP regarding how to display the returned accounts.
  const name = userInfo[0].name;
  const givenName = userInfo[0].givenName;
  const displayName = givenName ? givenName : name;
  const picture = userInfo[0].picture;
  const email = userInfo[0].email;
}
```
</div>

<div algorithm="getUserInfo">
When invoking the {{IdentityProvider/getUserInfo()}} method given an {{IdentityProviderConfig}}
|provider|, perform the following steps:

    1. Let |globalObject| be the [=current global object=].
    1. Let |document| be |globalObject|'s [=associated Document=].
    1. If |document| is not [=allowed to use=] the [=identity-credentials-get=]
        [=policy-controlled feature=], throw a "{{NotAllowedError}}" {{DOMException}}.
    1. If there does not exist an account |account| such that [=connected accounts set=]
        [=list/contains=] the result of [=compute the connected account key=] given |account|,
        |provider|, and |globalObject|, then [=reject=] |promise| with a "{{NetworkError}}"
        {{DOMException}}. This check can be performed by iterating over the
        [=connected accounts set=] or by keeping a separate data structure to make this lookup fast.
    1. Let |configUrl| be the result of running [=parse url=] with |provider|'s
        {{IdentityProviderConfig/configURL}} and |globalObject|.
    1. If |configUrl| is failure, throw an "{{InvalidStateError}}" {{DOMException}}.
    1. If |document|'s [=Document/origin=] is not [=same origin=] as |configUrl|'s [=url/origin=],
        throw an "{{InvalidStateError}}" {{DOMException}}.
    1. Run a [[!CSP]] check with a [[CSP#directive-connect-src|connect-src]] directive on the URL
        passed as |configUrl|. If it fails, throw a new "{{NetworkError}}" {{DOMException}}.
    1. If |globalObject|'s [=Window/navigable=] is a [=/top-level traversable=], throw a new
        "{{NetworkError}}" {{DOMException}}.
    1. If the user has disabled the FedCM API on the |globalObject|'s [=Window/navigable=]'s
        [=navigable/top-level traversable=], throw a new "{{NetworkError}}" {{DOMException}}.
    1. Let |promise| be a new {{Promise}}.
    1. Perform the following steps [=in parallel=]:
        1. Let |config| be the result of running [=fetch the config file=] with |provider| and
            |globalObject|.
        1. If |config| is failure, [=reject=] |promise| with a new "{{NetworkError}}"
            {{DOMException}}.
        1. Let |accountsList| be the result of [=fetch the accounts=] with |config|, |provider|,
            and |globalObject|.
        1. Let |hasAccountEligibleForAutoReauthentication| be false.
        1. For each |account| in |accountsList|:
            1. If |account|["{{IdentityProviderAccount/approved_clients}}"] is not empty and it does not
                [=list/contain=] |provider|'s {{IdentityProviderConfig/clientId}}, continue.
            
                Note: this allows the [=IDP=] to override whether an account is a returning account.
                This could be useful for instance in cases where the user has disconnected the
                account out of band.
            
            1. If |account| is [=eligible for auto reauthentication=] given |provider| and
                |globalObject|, set |hasAccountEligibleForAutoReauthentication| to true.
        1. If |hasAccountEligibleForAutoReauthentication| is false, [=reject=] |promise| with a new
            "{{NetworkError}}" {{DOMException}}.
        1. Let |userInfoList| be a new [=list=].
        1. For each |account| in |accountsList|:
            1. [=list/Append=] an {{IdentityUserInfo}} to |userInfoList| with the following values:

                :  {{IdentityUserInfo/email}}
                :: |account|["{{IdentityProviderAccount/email}}"]   
                :  {{IdentityUserInfo/name}}
                :: |account|["{{IdentityProviderAccount/name}}"]   
                :  {{IdentityUserInfo/givenName}}
                :: |account|["{{IdentityProviderAccount/given_name}}"]   
                :  {{IdentityUserInfo/picture}}
                :: |account|["{{IdentityProviderAccount/picture}}"]
        1. [=Resolve=] a new {{Promise}} with |userInfoList|.
</div>

<!-- ============================================================ -->
# Identity Provider HTTP API # {#idp-api}
<!-- ============================================================ -->

<em>This section is non-normative.</em>

The [=IDP=] exposes a series of HTTP endpoints:

1. [[#idp-api-well-known]] that points to a Manifest
1. A [[#idp-api-config-file]] in an agreed upon location that points to
1. An [[#idp-api-accounts-endpoint]] endpoint
1. A [[#idp-api-client-id-metadata-endpoint]] endpoint
1. An [[#idp-api-id-assertion-endpoint]] endpoint
1. An [[#idp-api-disconnect-endpoint]] endpoint if it supports {{IdentityCredential/disconnect}}.

The FedCM API introduces the ability for a site to ask the browser to execute a few different
network requests. It is important for the browser
to execute these in such a way that it does not allow the user to be tracked (by an attacker
impersonating an [=IDP=]) on to the site using FedCM. The following table has information about the
network requests performed:

<table>
  <tr><td>Endpoint</td><td>cookies</td><td>client_id</td><td>origin</td></tr>
  <tr><td>manifests</td><td>no</td><td>no</td><td>no</td></tr>
  <tr><td>accounts_endpoint</td><td>yes</td><td>no</td><td>no</td></tr>
  <tr><td>client_metadata_endpoint</td><td>no</td><td>yes</td><td>yes</td></tr>
  <tr><td>id_assertion_endpoint</td><td>yes</td><td>yes</td><td>yes</td></tr>
  <tr><td>disconnect_endpoint</td><td>yes</td><td>yes</td><td>yes</td></tr>
</table>

<!-- ============================================================ -->
## The Well-Known File ## {#idp-api-well-known}
<!-- ============================================================ -->

NOTE: The browser uses the [=well-known file=] to prevent [[#manifest-fingerprinting]].

The [=IDP=] exposes a <dfn>well-known file</dfn> in a pre-defined location, specifically at the "web-identity" file at the [=IDPs=]'s path ".well-known".

The [=well-known file=] is fetched in the [=fetch the config file=] algorithm:

(a) **without** cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`, and
(c) **without** revealing the [=RP=] in the <a http-header>Origin</a> or
    [[RFC9110#field.referer|Referer]] headers.

For example:

<div class=example>
```http
GET /.well-known/web-identity HTTP/1.1
Host: idp.example
Accept: application/json
Sec-Fetch-Dest: webidentity
```
</div>

The file is parsed expecting a {{IdentityProviderWellKnown}} JSON object.

The {{IdentityProviderWellKnown}} JSON object has the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderWellKnown">
    :   <dfn>provider_urls</dfn> (required)
    ::  A list of URLs that points to valid [[#idp-api-config-file]]s.
</dl>

<!-- ============================================================ -->
## The config file ## {#idp-api-config-file}
<!-- ============================================================ -->

The <dfn>config file</dfn> serves as a discovery device to other endpoints provided by the
[=IDP=].

The [=config file=] is fetched in the [=fetch the config file=] algorithm:

(a) **without** cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(c) **without** revealing the [=RP=] in the <a http-header>Origin</a> or
    [[RFC9110#field.referer|Referer]] headers, and
(d) **without** following [[RFC9110#field.location|HTTP redirects]].

For example:

<div class=example>
```http
GET /config.json HTTP/1.1
Host: idp.example
Accept: application/json
Sec-Fetch-Dest: webidentity
```
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderAPIConfig}} without an exception.

The {{IdentityProviderAPIConfig}} object's members have the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderAPIConfig">
    :   <dfn>accounts_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-accounts-endpoint]] API.
    :   <dfn>client_metadata_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-client-id-metadata-endpoint]] API.
    :   <dfn>id_assertion_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-id-assertion-endpoint]] API.
    :   <dfn>disconnect_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-disconnect-endpoint]]
        API.
    :   <dfn>login_url</dfn>
    ::  A URL that can be used to log in to this IdP. This is a user-facing URL that can be shown in
        a popup window.
    :   <dfn>branding</dfn>
    ::  A set of {{IdentityProviderBranding}} options.
    :   <dfn>account_label</dfn>
    ::  An optional string that needs to match the {{IdentityProviderAccount/label_hints}} provided
        by the IdP.
</dl>

The {{IdentityProviderBranding}} enables an [=IDP=] to express their branding
preferences, which may be used by [=user agents=] to customize the permission prompt.

Note: The branding preferences are deliberately designed to be high level
/ abstract (rather than opinionated about a specific UI structure), to
enable different [=user agents=] to offer different UI experiences and
for them to evolve independently over time.

Its members have the following semantics:
<dl dfn-type="dict-member" dfn-for="IdentityProviderBranding">
    :   <dfn>background_color</dfn>
    ::  Background [=color=] for [=IDP=]-branded widgets such as buttons.
    :   <dfn>color</dfn>
    ::  [=color=] for text on [=IDP=] branded widgets.
    :   <dfn>icons</dfn>
    ::  A list of {{IdentityProviderIcon}} objects.
    :   <dfn>name</dfn>
    ::  A user-recognizable name for the [=IDP=].
</dl>

Note: The branding preferences are deliberately designed to be high level
/ abstract (rather than opinionated about a specific UI structure), to
enable different [=user agents=] to offer different UI experiences and
for them to evolve independently over time.


The {{IdentityProviderIcon}} has members with the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderIcon">
    :   <dfn>url</dfn>
    ::  The url pointing to the icon image, which must be square and single resolution
        (not a multi-resolution .ico). The icon needs to comply with the
        [maskable](https://www.w3.org/TR/appmanifest/#icon-masks) specification.
    :   <dfn>size</dfn>
    ::  The width/height of the square icon. The size may be omitted if the icon is in a vector
        graphic format (like SVG).
</dl>

Note: the [=user agent=] reserves a square size for the icons provided by the developer. If the
developer provides an icon that is not square, the [=user agent=] may choose to not display it at
all, trim the icon and show a square portion of it, or even transform it into a square icon and show
that.

The {{IdentityProviderBranding/color}} is a subset of CSS <<color>> syntax, namely <<hex-color>>s, ''hsl()''s, ''rgb()''s and <<named-color>>.

For example:

<div class=example>
```json
{
  "accounts_endpoint": "/accounts",
  "client_metadata_endpoint": "/metadata",
  "id_assertion_endpoint": "/assertion",
  "disconnect_endpoint": "/disconnect",
  "branding": {
    "background_color": "green",
    "color": "#FFEEAA",
    "icons": [{
      "url": "https://idp.example/icon.ico",
      "size": 25
    }],
    "name": "IDP Example"
  }
}
```
</div>

<!-- ============================================================ -->
## Accounts endpoint ## {#idp-api-accounts-endpoint}
<!-- ============================================================ -->

The <dfn>accounts endpoint</dfn> provides the list of accounts the user has at the [=IDP=].

The [=accounts endpoint=] is fetched in the [=fetch the accounts=] algorithm:

(a) **with** [=IDP=] cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(c) **without** revealing the [=RP=] in the <a http-header>Origin</a> or
    [[RFC9110#field.referer|Referer]] headers, and
(d) **without** following [[RFC9110#field.location|HTTP redirects]].

For example:

<div class=example>
```http
GET /accounts_list HTTP/1.1
Host: idp.example
Accept: application/json
Cookie: 0x23223
Sec-Fetch-Dest: webidentity
```
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderAccountList}} without an exception.

Every {{IdentityProviderAccount}} is expected to have members with the following semantics. `name`,
`email`, `username`, and `tel` are optional but at least one of them must be present and nonempty.

<dl dfn-type="dict-member" dfn-for="IdentityProviderAccount">
    :   <dfn>id</dfn>
    ::  The account unique identifier.
    :   <dfn>name</dfn>
    ::  The user's full name.
    :   <dfn>email</dfn>
    ::  The user's email address.
    :   <dfn>tel</dfn>
    ::  The user's phone number.

        Note: As this is only meant to be shown to the user, the phone number
              can be in any format.
    :   <dfn>username</dfn>
    ::  The user's username.
    :   <dfn>given_name</dfn>
    ::  The user's given name.
    :   <dfn>picture</dfn>
    ::  URL for the account's picture.
    :   <dfn>approved_clients</dfn>
    ::  A list of [=RP=]s (that gets matched against the requesting {{IdentityProviderConfig/clientId}}) this account is already registered with. Used to [=compute the connection status=] of an account.
        <div class="issue" heading="extension">
            In an extension spec, also used in the [=request permission to sign-up=] to allow the [=IDP=] to control whether
            to show the Privacy Policy and the Terms of Service.
        </div>
    :   <dfn>login_hints</dfn>
    ::  A list of strings which correspond to all of the login hints which match with this account.
        An [=RP=] can use the {{IdentityProviderRequestOptions/loginHint}} to request that only an account
        matching a given value is shown to the user.
    :   <dfn>domain_hints</dfn>
    ::  A list of strings which correspond to all of the domain hints which match with this account.
        An [=RP=] can use the {{IdentityProviderRequestOptions/domainHint}} to request that only an account
        matching a given value or containing some domain hint is shown to the user.
    :   <dfn>label_hints</dfn>
    ::  A list of strings which give the accounts a list of labels. The config file can specify a filter
        for a label string.
</dl>

For example:

<div class=example>
```json
{
 "accounts": [{
   "id": "1234",
   "given_name": "John",
   "name": "John Doe",
   "email": "john_doe@idp.example",
   "picture": "https://idp.example/profile/123",
   "approved_clients": ["123", "456", "789"],
   "login_hints": ["john_doe"],
   "domain_hints": ["idp.example"]
  }, {
   "id": "5678",
   "given_name": "Johnny",
   "email": "johnny@idp.example",
   "picture": "https://idp.example/profile/456",
   "approved_clients": ["abc", "def", "ghi"],
   "login_hints": ["email=johhny@idp.example", "id=5678"],
   "domain_hints": ["idp.example"],
   "label_hints:" ["l1"]
  }]
}
```
</div>

Issue: [Clarify](https://github.com/fedidcg/FedCM/issues/218) the IDP API response when the user is not signed in.

<!-- ============================================================ -->
## Extension: Client Metadata ## {#idp-api-client-id-metadata-endpoint}
<!-- ============================================================ -->

<div class="issue" heading="extension">

An extension may add the <dfn>client metadata endpoint</dfn>, which provides metadata about [=RP=]s.

The [=client metadata endpoint=] is fetched in the [=fetch the client metadata=] algorithm:

(a) **without** cookies,
(b) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(c) **with** the [=RP=]'s origin in the <a http-header>Origin</a> header, and
(d) **without** following [[RFC9110#field.location|HTTP redirects]].

The user agent also passes the **client_id**.

For example:

<div class=example>
```http
GET /client_medata?client_id=1234 HTTP/1.1
Host: idp.example
Origin: https://rp.example/
Accept: application/json
Sec-Fetch-Dest: webidentity
```
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityProviderClientMetadata}} without an exception.

The {{IdentityProviderClientMetadata}} object's members have the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityProviderClientMetadata">
    :   <dfn>privacy_policy_url</dfn>
    ::  A link to the [=RP=]'s Privacy Policy.
    :   <dfn>terms_of_service_url</dfn>
    ::  A link to the [=RP=]'s Terms of Service.
</dl>

For example:

<div class=example>
```json
{
  "privacy_policy_url": "https://rp.example/clientmetadata/privacy_policy.html",
  "terms_of_service_url": "https://rp.example/clientmetadata/terms_of_service.html"
}
```
</div>

</div>

<!-- ============================================================ -->
## Identity assertion endpoint ## {#idp-api-id-assertion-endpoint}
<!-- ============================================================ -->

The <dfn>identity assertion endpoint</dfn> is responsible for minting a new token.

The [=identity assertion endpoint=] is fetched in the [=fetch an identity assertion=] algorithm:

(a) as a **POST** request,
(b) **with** [=IDP=] cookies,
(c) **with** the [=RP=]'s origin in the <a http-header>Origin</a> header, and
(d) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(e) **without** following [[RFC9110#field.location|HTTP redirects]].

It will also contain the following parameters in the request body `application/x-www-form-urlencoded`:

<dl dfn-type="argument" dfn-for="id_assertion_endpoint_request">
    :   <dfn>client_id</dfn>
    ::  The [=RP=]'s unique identifier from the [=IDP=]
    :   <dfn>nonce</dfn>
    ::  The request nonce
    :   <dfn>account_id</dfn>
    ::  The account identifier that was selected.
    :   <dfn>fields</dfn>
    ::  The list of fields that the [=RP=] has requested in {{IdentityProviderRequestOptions/fields}}.
</dl>

<div class="issue" heading="extension">
    An extension may add the following:
<dl dfn-type="argument" dfn-for="id_assertion_endpoint_request">
    :   <dfn>disclosure_text_shown</dfn>
    ::  Whether the user agent has explicitly shown to the user what specific information the
        [=IDP=] intends to share with the [=RP=] (e.g. "idp.example will share your name, email...
        with rp.example"), used by the [=request permission to sign-up=] algorithm for new users. It
        is used as an assurance by the user agent to the [=IDP=] that it has indeed shown the terms
        of service and privacy policy to the user in the cases where it is required to do so.
    :   <dfn>disclosure_shown_for</dfn>
    ::  The list of fields that the user was prompted for. This can be a subset of
        {{IdentityProviderRequestOptions/fields}} if a field is requested that is not in the [=list
        of recognized fields=].
</dl>
</div>

For example:

<div class=example>
```http
POST /fedcm_assertion_endpoint HTTP/1.1
Host: idp.example
Origin: https://rp.example/
Content-Type: application/x-www-form-urlencoded
Cookie: 0x23223
Sec-Fetch-Dest: webidentity
account_id=123&client_id=client1234&nonce=Ct60bD&disclosure_text_shown=true&fields=name,email,picture&disclosure_shown_for=name,email,picture
```
</div>

<div class=idp-normative-text>
An [=IDP=] MUST check the <a http-header>Origin</a> header to ensure that a malicious [=RP=] does
not receive an ID token corresponding to another [=RP=]. In other words, the [=IDP=] MUST check that
the <a http-header>Origin</a> header value is represented by the
{{IdentityProviderConfig/clientId}}. As the {{IdentityProviderConfig/clientId}} are
[=IDP=]-specific, the [=user agent=] cannot perform this check.
</div>

The response body must be a JSON object that can be [=converted to an IDL value|converted=] to an {{IdentityAssertionResponse}} without an exception.

Every {{IdentityAssertionResponse}} is expected to have members with the following semantics:

<dl dfn-type="dict-member" dfn-for="IdentityAssertionResponse">
    :   <dfn>token</dfn>
    ::  The resulting token.
    :   <dfn>continue_on</dfn>
    ::  A URL that the user agent will open in a popup to finish the authentication process.
</dl>

Only one of `token` and `continue_on` should be specified.

The content of the {{IdentityAssertionResponse/token}} is opaque to the user agent and can contain
anything that the [=IDP=] would like to pass to the
[=RP=] to facilitate the login. For this reason the [=RP=]
is expected to be the party responsible for validating the
{{IdentityAssertionResponse/token}} passed along from the [=IDP=] using the
appropriate token validation algorithms defined. One example of how this might
be done is defined in [[OIDC-Connect-Core#IDTokenValidation]].

NOTE: For [=IDPs=], it is worth considering how
[portable](https://github.com/fedidcg/FedCM/issues/314) accounts are.
Portability is left entirely up to [=IDPs=], who can choose
between a variety of different mechanisms to accomplish it
(e.g. [OIDC's Account Porting](https://openid.net/specs/openid-connect-account-porting-1_0.html)).

For example:

<div class=example>
```json
{
  "token" : "eyJC...J9.eyJzdWTE2...MjM5MDIyfQ.SflV_adQssw....5c"
}
```
</div>

<!-- ============================================================ -->
## Disconnect endpoint ## {#idp-api-disconnect-endpoint}
<!-- ============================================================ -->

The <dfn>disconnect endpoint</dfn> is responsible for disconnecting a previously made federated
login connection between an [=RP=] and an [=IDP=] account, and returning the account's
{{IdentityProviderAccount/id}} so that the [=user agent=] can remove it from the
[=connected accounts set=].

The [=disconnect endpoint=] is fetched when invoking the {{IdentityCredential/disconnect}}
method:

(a) as a **POST** request,
(b) **with** [=IDP=] cookies,
(c) **with** the [=RP=]'s origin in the <a http-header>Origin</a> header,
(d) **with** the <a http-header>Sec-Fetch-Dest</a> header set to `webidentity`,
(e) **without** following [[RFC9110#field.location|HTTP redirects]], and
(f) in "cors" [=request/mode=].

It will also contain the following in the request body `application/x-www-form-urlencoded`:

<dl dfn-type="argument" dfn-for="disconnect_endpoint_request">
    :   <dfn>client_id</dfn>
    ::  The [=RP=]'s unique identifier from the [=IDP=]
    :   <dfn>account_hint</dfn>
    ::  An account hint for the [=IDP=] account being disconnected from the [=RP=].
</dl>

For example:

<div class=example>
```http
POST /fedcm_disconnect_endpoint HTTP/1.1
Host: idp.example
Origin: https://rp.example/
Content-Type: application/x-www-form-urlencoded
Cookie: 0x23223
Sec-Fetch-Dest: webidentity
client_id=client1234&account_hint=hint12
```
</div>

If the disconnection is unsuccessful, the [=IDP=] may respond with an error. If it is successful,
the response body must be a JSON object that can be [=converted to an IDL value|converted=] to an
{{DisconnectedAccount}} without an exception.

<dl dfn-type="dict-member" dfn-for="DisconnectedAccount">
    :   <dfn>account_id</dfn>
    ::  The {{IdentityProviderAccount/id}} of the account that was successfully disconnected.
</dl>

The [=IDP=] must return the {{DisconnectedAccount/account_id}} since it may be different from the
{{disconnect_endpoint_request/account_hint}}, and the ID is the one which allows the [=user agent=]
to disconnect the account from the [=connected accounts set=]. If the [=IDP=] returns an error or
the [=user agent=] does not find the account with the ID provided by the [=IDP=], then all accounts
associated with the relevant ([=RP=], [=IDP=]) are removed from the [=connected accounts set=].

<!-- ============================================================ -->
# Permissions Policy Integration # {#permissions-policy-integration}
<!-- ============================================================ -->

FedCM defines a [=policy-controlled feature=] identified by the string <code>"<dfn export>identity-credentials-get</dfn>"</code>.
Its [=default allowlist=] is `"self"`.

A {{Document}}’s [=Document/permissions policy=] determines whether any content
in that document is allowed to obtain a credential object using the [[#browser-api|Browser API]].
Attempting to invoke <code><a idl for="CredentialsContainer" lt="get()">navigator.credentials.get({identity:..., ...})</a></code>
in documents that are not [=allowed to use=] the [=identity-credentials-get=] feature will result
in [=a promise rejected with=] a "{{NotAllowedError}}" {{DOMException}}.

This restriction can be controlled using the mechanisms described in [[PERMISSIONS-POLICY]].

Note: Algorithms specified in [[!CREDENTIAL-MANAGEMENT-1]] perform the actual
permissions policy evaluation. This is because such policy evaluation needs to
occur when there is access to the [=current settings object=]. The [=internal method=]s
modified by this specification do not have such access since they are invoked [=in parallel=]
by {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a> abstract operation.

<!-- ============================================================ -->
# User Agent Automation # {#automation}
<!-- ============================================================ -->

For the purposes of user agent automation and website testing, this document
defines the below [[WebDriver2]] [=extension commands=] to interact with any
active FedCM dialogs.

## Extension capability ## {#webdriver-capability}

In order to advertise the availability of the [=extension commands=] defined below, a new [=extension capability=] is defined.

<figure id="table-fedcmWebdriverCapability" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>Capability</th>
                <th>Key</th>
                <th>Value Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Federated Credential Management Support</td>
                <td>`"fedcm:accounts"`</td>
                <td>boolean</td>
                <td>Indicates whether the [=endpoint node=] supports all Federated Credential Management commands.</td>
            </tr>
        </tbody>
    </table>
</figure>

When [=validating capabilities=], the extension-specific substeps to validate `"fedcm:accounts"` with `value` are the following:

    1. If `value` is not a [=boolean=] return a [=error|WebDriver Error=] with [=error code=] [=invalid argument=].
    2. Otherwise, let `deserialized` be set to `value`.

When [=matching capabilities=], the extension-specific steps to match `"fedcm:accounts"` with `value` are the following:

    1. If `value` is [TRUE] and the [=endpoint node=] does not support any of the Federated Credential Management commands,
        the match is unsuccessful.
    2. Otherwise, the match is successful.

## Cancel dialog ## {#webdriver-canceldialog}

<figure id="table-webdriver-canceldialog" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/fedcm/canceldialog`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If no FedCM dialog is currently open, return a [=error|WebDriver error=] with
    [=error code=] [=no such alert=].

1. Close the dialog and continue the [=create an IdentityCredential=] algorithm
    as if the user had canceled the dialog without choosing an account.

1. Return [=success=] with data `null`.

## Select account ## {#webdriver-selectaccount}

<figure id="table-webdriver-selectaccount" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/fedcm/selectaccount`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If |parameters| is not a JSON [[ECMASCRIPT#sec-json-object|Object]], return a
    [=error|WebDriver error=] with [=error code=] [=invalid argument=].

1. If no FedCM dialog is currently open, return a [=error|WebDriver error=] with
    [=error code=] [=no such alert=].

1. Let |accountIndex| be the result of [=getting a property=] named `"accountIndex"`
    from |parameters|.

1. If |accountIndex| is {{undefined}} or is less than 0 or greater than or
    equal to the number of accounts that the user can choose from in the
    current flow, return a [=error|WebDriver error=] with [=error code=]
    [=invalid argument=].

1. Close the dialog and continue the [=create an IdentityCredential=] algorithm
    as if the user had selected the account indicated by |accountIndex|.
    <div class="issue" heading="extension">
      An extension spec may also simulate the user to have [=request permission to sign-up|granted permission to sign-up=],
      if applicable.
    </div>
1. Return [=success=] with data `null`.

## Click dialog button ## {#webdriver-clickdialogbutton}

<figure id="table-webdriver-clickdialogbutton" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/fedcm/clickdialogbutton`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If |parameters| is not a JSON [[ECMASCRIPT#sec-json-object|Object]], return a
    [=error|WebDriver error=] with [=error code=] [=invalid argument=].

1. Let |dialogButton| be the result of [=getting a property=] named
    `"dialogButton"` from |parameters|.

1. If |dialogButton| is not a string that is "`ConfirmIdpLoginContinue`", return
    a [=error|WebDriver error=] with [=error code=] [=invalid argument=].

1. If no FedCM dialog is currently open or the dialog is not a [=confirm IDP
    login dialog=], return a [=error|WebDriver error=] with [=error code=] [=no
    such alert=].

1. Act as if the user had clicked the "continue" button in the [=confirm IDP
    login dialog=] and initiate the login flow.

1. Return [=success=] with data `null`.

## Account list ## {#webdriver-accountlist}

<figure id="table-webdriver-accountlist" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>GET</td>
                <td>`/session/{session id}/fedcm/accountlist`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If no FedCM dialog is currently open, return a [=error|WebDriver error=] with
    [=error code=] [=no such alert=].

1. Let |accounts| be the list of accounts that the user can or could choose
    from in the current flow.

1. Let |list| be an empty list.

1. For each |account| in |accounts|:
    1. Let |accountState| be the result of running the [=compute the connection status=]
        algorithm given |account| and the {{IdentityProviderRequestOptions}} of the IDP
        |account| belongs to
    1. <dfn for="fedcm webdriver error">Create dictionary</dfn>[=list/Append=] a [=dictionary=] to |list|
        with the following properties:
        1. `accountId` set to the account's {{IdentityProviderAccount/id}}
        1. `email` set to the account's {{IdentityProviderAccount/email}}
        1. `name` set to the account's {{IdentityProviderAccount/name}}
        1. `givenName` set to the account's {{IdentityProviderAccount/given_name}},
            if present
        1. `pictureUrl` set to the account's {{IdentityProviderAccount/picture}},
            if present
        1. `idpConfigUrl` set to the {{IdentityProviderConfig/configURL}} of the
            IDP this account belongs to
        1. `loginState` to `"SignUp"` if |accountState| is
            [=compute the connection status/disconnected=] and `"SignIn"` otherwise

      <div class="issue" heading="extension">
      An extension may add the following subteps to the [=fedcm webdriver error/create dictionary=] step:
          1. `termsOfServiceUrl` to the {{IdentityProviderClientMetadata/terms_of_service_url}}
              if one was provided and the `loginState` is `"SignUp"`, otherwise {{undefined}}
          1. `privacyPolicyUrl` to the {{IdentityProviderClientMetadata/privacy_policy_url}}
              if one was provided and the `loginState` is `"SignUp"`, otherwise {{undefined}}
      </div>

1. Return [=success=] with data |list|.

## Get title ## {#webdriver-gettitle}

<figure id="table-webdriver-gettitle" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>GET</td>
                <td>`/session/{session id}/fedcm/gettitle`</td>
            </tr>
        </tbody>
    </table>
</figure>

Note: This command lets automation verify that the
  [context api](#dom-identitycredentialrequestoptions-context)
     was applied properly

The [=remote end steps=] are:

1. If no FedCM dialog is currently open, return a [=error|WebDriver error=] with
    [=error code=] [=no such alert=].

1. Let |data| be a dictionary with an object with properties as follows:
    1. `title` set to the title of the open dialog
    1. `subtitle` set to the subtitle of the open dialog, if there is one

1. Return [=success=] with data |data|.

## Get dialog type ## {#webdriver-getdialogtype}

<figure id="table-webdriver-getdialogtype" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>GET</td>
                <td>`/session/{session id}/fedcm/getdialogtype`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If no FedCM dialog is currently open, return a [=error|WebDriver error=] with
    [=error code=] [=no such alert=].

1. Let |type| be a string that is "`AutoReauthn`" if the user is being [=auto-reauthenticated=],
    or "`AccountChooser`" if the dialog is an account chooser, or "`ConfirmIdpLogin`" if the
    dialog is a [=confirm IDP login dialog=].

1. Return [=success=] with data |type|.

## Set delay enabled ## {#webdriver-setdelayenabled}

<figure id="table-webdriver-setdelayenabled" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/fedcm/`<dfn>`setdelayenabled`</dfn></td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If |parameters| is not a JSON [[ECMASCRIPT#sec-json-object|Object]], return a
     [=error|WebDriver error=] with [=error code=] [=invalid argument=].

1. Let |enabled| be the result of [=getting a property=] named `"enabled"` from
    |parameters|.

1. If |enabled| is {{undefined}} or is not a boolean, return a [=error|WebDriver error=]
    with [=error code=] [=invalid argument=].

1. If |enabled| is false, disables the [=promise rejection delay=]; otherwise,
    re-enables it.

1. Return [=success=] with data `null`.

## Reset cooldown ## {#webdriver-resetcooldown}

<figure id="table-webdriver-resetcooldown" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/fedcm/resetcooldown`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

1. If the user agent uses a cooldown delay, which disables the API for an
    amount of time after the user dismissed the dialog, then this command
    resets that cooldown such that the next FedCM call can succeed again.

1. Return [=success=] with data `null`.

<!-- ============================================================ -->
# Security Considerations # {#security}
<!-- ============================================================ -->

This section provides a few of the security considerations for the FedCM API. Note that there is a
separate section for [[#privacy]].

In FedCM, there are various assets that need to be protected. All of the endpoints need basic
protections, and the credentialed ones need protections from various kinds of attacks and threats.

<!-- ============================================================ -->
## Security Assumptions ## {#security-assumptions}
<!-- ============================================================ -->

The design of FedCM relies on several key security assumptions:

<!-- ============================================================ -->
### Trusted User Agent ### {#trusted-user-agent}
<!-- ============================================================ -->

The user agent (i.e., the browser) is assumed to be a trusted entity. It is expected to faithfully 
enforce same-origin policies, execute CSP and CORS checks, and present a secure, non-forgeable UI 
that users can trust, and to not contains or executes malicious third parties scripts. The browser 
is responsible for mediating the flow and preventing unauthorized access to credentials.

<!-- ============================================================ -->
### Secure Network and Transport ### {#secure-network-transport}
<!-- ============================================================ -->

All network requests — especially those carrying sensitive information such as tokens — occur over
secure channels (e.g. HTTPS). The specification assumes that the transport layer prevents 
man-in-the-middle and other network attacks.

<!-- ============================================================ -->
### Proper Implementation of Security Headers ### {#proper-implementation-headers}
<!-- ============================================================ -->

[=IDP=] and [=RP=] implement and enforce appropriate security headers (such as CSP, CORS, 
and the mandatory use of the `Sec-Fetch-Dest: webidentity` header). These headers are key to 
distinguishing browser-initiated FedCM flows from arbitrary requests.

<!-- ============================================================ -->
### IDP and RP Integrity ### {#idp-and-rp-integrity}
<!-- ============================================================ -->

[=IDP=] and [=RP=] endpoints are implemented correctly and do not contain vulnerabilities that could 
allow an attacker to bypass the FedCM flow or extract sensitive data.

<!-- ============================================================ -->
## Threats and Attacks ## {#security-threats-aattacks}
<!-- ============================================================ -->

The following subsections cover the various security threats and the mitigations from the FedCM
spec.

<!-- ============================================================ -->
## Cross-Site Scripting ## {#cross-site-scripting}
<!-- ============================================================ -->

**Threat**

Imagine a malicious script included by (and running as) the [=RP=] attempting to execute the FedCM
API calls to a legitimate [=IDP=]. If the call is successful, this would introduce some browser UI
where all parties might look legitimate to the user. If the user logs in using the FedCM API in this
scenario, their credentials are then received by the malicious script, which can then send it to its
own server.

**Mitigation**

The protection against this attack is to sanitize all user input to prevent script
injection, and to use [[!CSP]] to restrict the execution of inline scripts.

**Threat**

A script could also instead use the FedCM API to request credentials from some [=IDP=] that is not
approved by the [=RP=]. If the user went through this flow, these credentials could also be stolen,
or the [=RP=]'s reputation could be harmed.

**Mitigation**

An additional protection for this scenario is that the origin of the [=config file=] of the
malicious [=IDP=] would not be an origin included in the allowlist specified by the
[[CSP#directive-connect-src|connect-src]] [[!CSP]] check of the [=RP=], hence preventing the
undesired FedCM UI from being shown. Since any subsequent fetches are same origin with respect to
the [=config file=] or at least dependent on the contents of the [=config file=], they do not
require additional checks.

Note that the non-same-origin fetches include, for example, the brand icon. The user agent does not
perform a [[!CSP]] check on these because they are directly specified from the manifest. In
addition, the rendering of this image is performed by the user agent, and as such this image cannot
affect the [=RP=] site nor can they be inspected by the [=RP=] in any way.

<!-- ============================================================ -->
## Unauthorized Fetching ## {#unauthorized-fetching}
<!-- ============================================================ -->

**Threat**

The FedCM API introduces several non-static endpoints on the [=IDP=]. These are meant to be invoked
only by the user agent as part of a FedCM flow. If an attacker wanted to invoke these endpoints
directly, the [=IDP=] should have the capability to revoke the fetch. This applies even if the call
originated from a valid [=RP=] so just having the origin of the fetch is not a sufficient mitigation
here.

**Mitigation**

In order to distinguish the fetches that are initiated from the FedCM flow from fetches coming from
elsewhere, the FedCM API introduces a new value for the <a http-header>Sec-Fetch-Dest</a> header, a
[=forbidden request-header=]. The requests initiated by the FedCM API have a `webidentity` value for
this header. The value cannot be set by random websites, so the [=IDP=] can be confident that the
request was originated by the FedCM browser rather than sent by a websites trying to run an XSS
attack. An [=IDP=] needs to check for this header's value in the credentialed requests it receives,
which ensures that the request was initiated by the user agent, based on the FedCM API. This
protects the new [=IDP=] endpoints from unauthorized fetches. Also note that a [=user agent=] which
does not send third-party cookies also adds a protection, since a regular fetch from an [=RP=]
context will not contain the [=IDP=]'s first-party cookies.

<!-- ============================================================ -->
## Sensitive Data Access ## {#sec-cors-header}
<!-- ============================================================ -->

**Threat**

The FedCM API allows the response from the [=identity assertion endpoint=] to be shared to the
[=RP=]. This endpoint typically contains user data that is extremly sensitive, and as such needs
enhanced protection.

**Mitigation**

To enable this, we impose the requirement that the [=IDP=] explicitly consents to this sharing
taking place by using the "cors" [=request/mode=] when fetching this endpoint. This also helps with
servers that may accidentally ignore the <a http-header>Sec-Fetch-Dest</a>: they cannot ignore CORS,
as without it the fetch will fail.

<!-- ============================================================ -->
## Browser Surface Impersonation ## {#browser-surface-impersonation}
<!-- ============================================================ -->

**Threat**

The FedCM API introduces new (trusted) user agent UI, and the user agent may choose to show the UI
entirely on top of the page's contents, if anything because the page was the one responsible for
this UI. This introduces a potential concern of a malicious site to try to replicate the FedCM UI,
gain the user's trust that the user is interacting with a trusted browser surface, and gather
information from the user that they would only give to the browser rather than the site (e.g.
usernames/passwords of **another** site).

**Mitigation**

This would be hard to achieve because the FedCM UI uses metadata about the user accounts of the
[=IDP=], which the malicious website doesn't have access to. If this is a malicious site, it would
not know the user accounts unless the user is already compromised. However, the site could have some
guess of the user identity, so the browser is encouraged to provide UI that is hard to replicate and
that clearly presents the domains of the parties involved in the website's FedCM call.

**Threat**

One impersonation attack that would work for an attacker that the user somewhat trusts consists of
the attacker first using the FedCM API. A trusting user would then login to FedCM using the browser
UI. The attacker would then gain access to the information about the user and immediately would
create a mockup of browser UI which would look almost identical in style that would request
sensitive user information such as the password of the user account that the user just logged in to
via FedCM.

**Mitigation**

This attack requires the user to somewhat trust the attacker since FedCM needs to be successfully
used first. It is mitigated by the fact that the FedCM UI does not ever require the user to enter
passwords in the UI, so the new UI will look suspicious, especially to a user who has previously
seen the FedCM flow on other sites.

Overall, an attacker trying to impersonate the browser using exclusively UI that is accessible to
the content area (e.g., iframes) to attempt to retrieve sensitive information from the user would be
noticeably different from the FedCM UI. Finally, because the FedCM UI can only be queried from the
top-level frame (or potentially from an iframe with explicit permission from the top-level frame),
the privileged UI surface is only shown when the top-level frame wants it so. A sneaky iframe cannot
force the FedCM UI to occlude important content from the main page.

<!-- ============================================================ -->
## IDP Impersonation ## {#idp-impersonation}
<!-- ============================================================ -->

**Threat**

An attacker who has some knowledge about the user via previous tracking could try to impersonate a
real [=IDP=] by pretending to be an [=IDP=] and invoking the FedCM API. However, this does not grant
much more power to the attacker: if the user logs in via FedCM to the attacker, the attacker can now
track the user more easily within the [=RP=], but the attacker was already tracking the user in
order to surface a meaningful dialog.

**Mitigation**

That said, [=IDP=] impersonation would still be poor UX for the user and it would also reflect
poorly on the real [=IDP=]. To protect from this, the user agent is encouraged to not just include
the [=IDP=] branding in the UI dialogs, but also include the origins of the relevant parties as
well. This way, the attacker can never create a FedCM dialog identical to that of the real [=IDP=]
since its origin will be different.

<!-- ============================================================ -->
## Clickbait ## {#clickbait}
<!-- ============================================================ -->

**Threat**

An attacker controlled [=IDP=] could attempt to trick the user into going through the FedCM UI by
introducing fake text into the name/email fields of the accounts endpoint response that become
visible in the UI. For example, they could enter text such as "Click here to win $100!". As this
requires the attacker to control the [=IDP=], the gain would be minimal, i.e. access to user
tracking within the [=RP=]. No sensitive information would be shared with the attacker in this case.

**Mitigation**

To mitigate this, the user agent can add [=IDP=]-independent text to ensure that the user has some
context about what the dialog is for (like 'sign in'). Because this text would not be something the
attacker can just override, it will ensure that this kind of abuse looks suspicious to the user. In
addition, the [=RP=] would likely remove such abusive caller from their site unless they are also
involved in this attack. Thus, while clickbait text is not something that the spec protects against,
the power it provides to attackers is limited, similar to how an attacker could compromise the
[=RP=] and introduce a clickbait dialog to entice the user to click on some part of the page to
enable APIs requiring user gesture. Outright trackers need to be silent, since they need to work
within pages that do not condone their practices, so this attack is not viable for them.

<!-- ============================================================ -->
## Clickjacking ## {#clickjacking}
<!-- ============================================================ -->

**Threat**

An attacker could surface UI to try to force the user into accidentally consenting to the FedCM
dialog. In this case, the attacker would likely be the [=RP=], which would want to gain valuable
user information from a real [=IDP=]. For example, an attacker could have a button 'click here 4
times' which would surface the FedCM dialog the first time it is clicked. If the timing and the
location of this button works out, an unsuspecting user would click on their account in the FedCM
dialog when it appears.

**Mitigation**

There are a couple of possible mitigations to this. One is the user agent can always show a
confirmation dialog after an account has been selected. This reduces the chance of the user
accidentally confirming the entire FedCM flow. Another is that the user agent can establish a
limited window of time during which user input is ignored, right after the FedCM dialog is shown to
the user. This allows the user to have time to react to the dialog showing up while also not
impacting the regular scenario of FedCM being used successfully. It is recommended for the user
agent to implement at least one of these two mitigations in order to prevent an attacker from
tricking the user into providing their credentials via the FedCM API. For this particular attack,
the attacker's [=RP=] might also not be trusted by the [=IDP=], so the flow would fail due to
{{id_assertion_endpoint_request/client_id}} or CORS checks.

<!-- ============================================================ -->
# Privacy Considerations # {#privacy}
<!-- ============================================================ -->

This section is intended to provide a comprehensive overview of the privacy risks associated with
federated identity on the web for the purpose of measuring the privacy risks and benefits of
proposed browser intermediation designs.

<!-- ============================================================ -->
## Principals ## {#privacy-principals}
<!-- ============================================================ -->

This section describes the four principals that would participate in an invocation of the API and
expectations around their behavior.

1. The [=user agent=] implements [[#browser-api]] and controls the execution contexts for the [=RP=]
    and [=IDP=] content. The [=user agent=] is assumed to be trusted by the user, and transitively
    trusted by the [=RP=] and [=IDP=].
1. [=RP=]s are websites that invoke the FedCM API for the purpose of
    authenticating a user to their account or for requesting information about that user. Since any
    site can invoke the API, [=RP=]s cannot necessarily be trusted to limit the user information it
    collects or use that information in an acceptable way.
1. [=IDP=]s are third-party websites that are the target of a FedCM call to
    attempt to fetch a token. Usually,the [=IDP=] has a higher level of trust than the
    [=RP=] since it already has the user’s personal information, but it is possible that the [=IDP=]
    might use the user’s information in non-approved ways. In addition, it is possible that the
    [=IDP=] specified in the API call may not be an [=IDP=] the user knows about. In this case, it
    likely does not have personal user information in advance.
1. A <dfn>tracker</dfn> is a third-party website that is not an [=IDP=] but could abuse the FedCM API
    exclusively for the purpose of tracking a user as they visit various websites. A [=tracker=] may
    be injected by the [=RP=] with or without their knowledge (e.g. injected into one of the various
    script tags that the [=RP=] embeds that is loaded dynamically), but they usually do not modify
    the UI of the website, so that it is harder to detect the tracking. A [=tracker=] that
    successfully adds tracking scripts for users in various websites may then use this information
    for various purposes, such as selling the information about the user. It should not be possible
    for [=trackers=] to use the FedCM API to track users across the web.

Based on the above, the privacy discussion makes the following assumptions:

1. It is not acceptable for an [=RP=], [=IDP=], or [=tracker=] to learn that a specific user visited a
    specific site, without any permission granted by the user. That is, the [=user agent=] needs to hide the
    knowledge that a specific user identity visited a specific site from the [=RP=], [=IDP=], and
    [=trackers=]. It may share this knowledge with the [=RP=] and [=IDP=] once the user grants permission. In
    particular, the [=RP=] should not know the user identity and the [=IDP=] should not know the
    site that the user has visited before the FedCM flow gathers the user's permission to do so.
1. It is the [=user agent=]'s responsibility to determine when the user has granted permission for the
    [=IDP=] to communicate with the [=RP=] in order to provide identification for the user.
1. Once the [=user agent=] has determined that the user has granted permission to provide their
    account information to the [=RP=], it is ok for the [=IDP=] and for the [=RP=] to learn
    information about that specific user's account, as required to provide identification. The [=RP=]
    should not learn about about any other user accounts.

<!-- ============================================================ -->
## Network requests ## {#network-requests}
<!-- ============================================================ -->

This specification ensures that the FedCM fetches are all same-origin with respect to the provider specified
by the [=RP=]. The reason for this is because fetches with cookies would use the cookies from the
origin specified, so allowing arbitrary origins would introduce confusion and potential privacy
issues with regards to which cookies are shared and with whom within the FedCM flow. The easiest way
to ensure that all of these fetches remain same-origin is by disabling redirects and checking the
origin of the fetched URLs.

* The [=config file=] fetch can't be used to track users because it is performed without cookies, {{id_assertion_endpoint_request/client_id}},
    or referrer. Thus, anyone could perform this fetch, and the information contained therein
    is considered public.

* The [=accounts endpoint=] fetch can't be used to track users because it is performed with cookies from the
    [=IDP=] but, importantly, without the {{id_assertion_endpoint_request/client_id}} or referrer. This in theory is a new power
    that the [=RP=] gains that it would not have otherwise. Preventing too many of these fetches may
    be important, but [=IDP=]s are already expected to protect against DoS attacks. In addition, the
    user agent should only allow one FedCM flow per page at any given moment, immediately rejecting
    any attempts to start another one. Since a FedCM flow can only be terminated when the user
    interacts or after a long timer, the number of fetches performed is not a concern. The [=IDP=]
    does learn a lot about the user from this fetch, but this is discussed in detail below.

<div class="issue" heading="extension">
    * The [=client metadata endpoint=] fetch can't be used to track users because it is performed without cookies
        from the [=IDP=], albeit with a {{id_assertion_endpoint_request/client_id}} and a referrer. This allows the [=IDP=] to
        communicate the relevant Privacy Policy and Terms of Service to the user agent, in case
        they need to be displayed. Again, beyond possible timing attacks described here, the [=RP=]
        gains nothing from this fetch, and the [=RP=] could already perform this fetch if it wanted to
        since it involves no cookies from the [=IDP=].
</div>

* By design, the token fetch exposes the user at the website to the [=IDP=]: it is
    peformed with cookies, {{id_assertion_endpoint_request/client_id}}, and referrer. Because of that, it is gated on the user
    interacting with the user agent UI, and enables the [=IDP=] to communicate to the [=RP=] the
    information required to perform a federated signin/signup. It is not possible for the [=RP=] or
    the [=IDP=] to force the token fetch to happen without user permission, as the user agent cannot be
    spoofed or otherwise tricked.
    
* The [=disconnect endpoint=] may only be fetched after the user has successfully gone through the
    FedCM flow at least once in the [=RP=]. It sends a credentialed request to the [=IDP=], so it
    is important that the [=user agent=] does not allow unlimited requests of such type, even after
    the user has used FedCM once. For this reason, any time that disconnection sends a credentialed
    request, at least one account is removed from the [=connected accounts set=], thus ensuring that
    this endpoint does not introduce a way for the [=RP=] to send requests to the [=IDP=] containing
    the [=IDP=] cookies forever.

<!-- ============================================================ -->
## Attack Scenarios ## {#attack-scenarios}
<!-- ============================================================ -->

This section describes the scenarios in which various agents might attempt to gain user information.
It considers the possibilities when:

  * The [=RP=] is collecting information,
  * The [=IDP=] is collecting information, or
  * Both the [=RP=] and the [=IDP=] are colluding.

For the purposes of this section, a principal is considered to be participating in the collection of
information if it directly or indirectly performs actions with the aim of realizing one of the above
threats.

Note: An example of indirect collusion would be an [=RP=] importing a script supplied by an [=IDP=]
where the [=IDP=] intends to track users.

For the purpose of discussion, this document assumes that third-party cookies are **disabled** by
default and are no longer effective for use in tracking mechanisms, and also some form of
mitigations are implemented against ‘bounce tracking’ using link decoration or postMessage. Most of
these scenarios consider how user tracking might happen **without** them. See also [[RFC7258]].

<!-- ============================================================ -->
### Manifest Fingerprinting ### {#manifest-fingerprinting}
<!-- ============================================================ -->

Suppose that the FedCM API did not have a two-tier manifest (see the [=create an IdentityCredential=]
algorithm), and instead directly had a single manifest. This would introduce the following
fingerprinting attack:

<div class=example>
```js
// The following will fetch the manifest JSON file, which will know the origin of the RP :(
const cred = await navigator.credentials.get({
  identity: {
    providers: [{
      configURL: \`https://idp.example/${window.location.href}\`
    }]
  }
});
```
</div>

NOTE: You can read more about the attack described
[here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1067029200).

Here, the [=RP=] includes identifies itself when fetching the manifest from the [=IDP=]. This
coupled with the credentialed fetches that the FedCM API performs would enable the [=IDP=] to easily
track the website that the user is visiting, without requiring any permission from the user. Our
mitigation to this problem is to use the [[#idp-api-well-known]] file. The existence of a file at
the root of the [=IDP=]'s domain is enforced to ensure that the file name does not introduce
fingerprints about the [=RP=] being visited.

The whole manifest could be in this location, but instead it only points to the real
manifest from there. This allows the flexibility in the future to allow a small constant
number of manifests, should an [=IDP=] require this in the future, instead of just a single one. It
also helps the [=IDP=]'s implementation because they any changes to the manifest are more likely to
be performed on a file located anywhere, as opposed to the root of the domain, which may have more
constraints in terms of ease of update.

<!-- ============================================================ -->
### Timing Attacks ### {#timing-attacks}
<!-- ============================================================ -->

In the timing attack, the [=RP=] and [=IDP=] collude to allow the [=IDP=] to compute the ([=RP=]'s
origin, [=IDP=]'s user identity) pair without the user's permission. This attack is not deterministic:
there is room for statistical error because it requires stitching together two separate pieces of
information to track the user. However, it is important to mitigate this attack and ensure that
it's economically impractical to perform. In this attack, it is assumed that network requests do not
have large fingerprinting vectors (e.g. IP addresses). These vary by [=user agent=] and are hard to
eliminate entirely, but in general [=user agents=] are expected to address these over time. These
bits of information tied to the network requests make the timing attack easier, making it more
important to address.

Note: this attack is described and discussed
[here](https://github.com/fedidcg/FedCM/issues/230#issuecomment-1089040953).

The attack is as follows:

1. The [=RP=] logs the time at which it invokes the API, time A and sends it to the [=IDP=] to
    learn itself by marking the time in which it receives the fetch for the [=RP=]'s client
    metadata. Time A is tied to the site.
1. A credentialed request is sent to the [=IDP=] that does not explicitly identify the [=RP=], but
    it is sent around a time that is close enough to the request above. The [=IDP=] notes the time
    in which this request has arrived, time B. Time B is tied to the user identity.
1. The [=IDP=] correlates time A and time B to find the (site, user identity) pair with high
    probability. Note that fingerprinting can make the correlation more accurate.

Note that this kind of correlation is already possible without FedCM by using simple cross-origin
top-level navigations, but using FedCM for this purpose would worsen the problem if it improved
timing resolution or if it was less visible to users (e.g. the [=IDP=] could return empty accounts
to the [=user agent=] to deliberately make no browser UI to be triggered, and hence make this attack
invisible to the user).

The [=user agent=] should mitigate this attack to protect users, in an interoperable way.

<!-- ============================================================ -->
### IDP Intrusion ### {#idp-intrusion}
<!-- ============================================================ -->

   > From [[PRIVACY-THREAT-MODEL#hl-intrusion]]
   >
   > Privacy harms don't always come from a site learning things.

   > From [[RFC6973#section-5.1.3|RFC6973: Intrusion]]
   >
   > Intrusion consists of invasive acts that disturb or interrupt one's life or activities.
   > Intrusion can thwart individuals' desires to be left alone, sap their time or attention, or
   > interrupt their activities.

In the context of federation, intrusion happens when an [=RP=] and an [=IDP=] are colluding to
invasively and aggressively recommend the user to login disproportionally to the their intent. Much
like unsolicited notifications, an [=RP=] can collude with an [=IDP=] to aggressively log users in.

The [=user agent=] can mitigate this by mediating the user controls and offering them proportionally
to the intent of the user or the privacy risks involved. For example, a [=user agent=] can choose to
show a loud / disruptive modal mediated dialog when it has enough confidence of the user's intent or
show a quiet / conservative UI hint when it doesn't.

A [=user agent=] could also choose to control disruption of the user's experience based on the risks
involved. For example, when a directed identifier is being exchanged it can be more confident of
the unintended consequeces and offer a more aggressive user experience, whereas when global
identifiers are exchanged a more conservative user experience.

<div class="image">
  <pre class=include-raw>
  path: img/mock45.svg
  </pre>
</div>

<!-- ============================================================ -->
### Cross-Site Correlation ### {#attack-scenarios-by-rp-cross-site-correlation}
<!-- ============================================================ -->

This attack happens when multiple [=RP=]s collude to use their user's data to correlate them and
build a richer profile. When a user willingly provides their full name, email address, phone number,
etc, to multiple relying parties, those relying parties can collaborate to build a profile of that
user and their activity across collaborating sites. Sometimes this is referred to as joining
since it amounts to a join of user records between the account databases of multiple RPs. This
correlation and profile-building is outside the user’s control and entirely out of the [=user
agent=]’s or [=IDP=]’s view.

<div class="image">
   <pre class=include-raw>
   path: img/mock3.svg
   </pre>
</div>

<div class="example">
    1. User signs into RP1 (which sells jewelry) with an IDP, providing to RP1
        their email address user@email.example
    1. User signs into RP2 (which sells houses) with an IDP, providing to RP2
        their email address user@email.example
    1. User browses the collection of wedding rings in RP1.
    1. Out of band, RP1 tells RP2 that user@email.example is shopping for wedding rings
    1. User browses the housing inventory in RP2.
    1. RP2 uses the fact that the user is shopping for wedding rings in RP1 to
        advertise and filters their housing inventory.
    1. User is surprised that RP2 knows that they are shopping for wedding rings.
</div>

The problem of [=RP=]s joining user data via back-channels is inherent to the proliferation of
identifying user data. This can be solved by issuing directed identifiers that provide an
effective handle to a user's identity with a given [=IDP=] that is unique and therefore cannot be
correlated with other [=RP=]s. In the past, there have been schemes to accomplish this using one-way
hashes of, for example, the user’s name, the [=IDP=], and the [=RP=]. These identifiers would be
unique, and hence it would not be possible to correlate these with other [=RP=]s.

<div class="image">
  <pre class=include-raw>
  path: img/mock37.svg
  </pre>
</div>

<!-- ============================================================ -->
### Unauthorized Data Usage ### {#unauthorized-data-usage}
<!-- ============================================================ -->

Another attack is when the [=RP=] or [=IDP=] uses user information for purposes not authorized by
the user. When the user agrees to allow the [=IDP=] to provide information to the [=RP=], the
permission is specific to certain purposes, such as sign-in and personalization. For instance, the
[=RP=] might use that data for other purposes that the user would not expect and did not authorize,
such as selling email addresses to a spam list. Spamming risk can exist even when using
directed identifiers.

<!-- ============================================================ -->
### RP Fingerprinting ### {#rp-fingerprinting}
<!-- ============================================================ -->

This attack happens when the [=RP=] employs client state-based tracking to identify user. Any
API that exposes any kind of client state to the web risk becoming a vector for fingerprinting. The
purpose of this API is for the user to provide identification to the [=RP=]. And the user should be
able to rescind the access to that identification, for instance by logging out. However, a tracking
[=RP=] could keep state to detect the user that was previously logged in:

<div class="image">
<pre class=include-raw>
path: img/mock5.svg
</pre>
</div>

<!-- ============================================================ -->
### Secondary Use ### {#secondary-use}
<!-- ============================================================ -->

Secondary use is the use of collected information about an individual without the individual's
perimssion for a purpose different from that for which the information was collected. This attack
happens when [=IDP=]s misuse the information collected to enable sign-in for other purposes.

Existing federation protocols require that the [=IDP=] know which service is requesting a token
in order to allow identity federation. Identity providers can use this fact to build profiles of
users across sites where the user has decided to use federation with the same account. This profile
could be used, for example, to serve targeted advertisements to those users browsing on sites that
the IDP controls.

This risk can exist even in the case where the [=IDP=] does not having pre-existing user account
information (for instance, if it is not a _bona fide_ IDP), because FedCM requests sent to the
[=IDP=] are credentialed. This is more likely to occur if the [=RP=] is colluding with the
[=IDP=] to enable tracking via [[#timing-attacks]].

<div class="image">
    <pre class=include-raw>
    path: img/mock23.svg
    </pre>
</div>

<div class='example'>
    1. User signs into RP1 (which sells jewelry) with an [=IDP=].
    1. User signs into RP2 (which sells houses) with the same [=IDP=].
    1. User navigates to the [=IDP=].
    1. Because the [=IDP=] knows that the user has an account with RP1 and RP2, the
        [=IDP=] can show ads about vacations for honeymoons.
    1. The user is surprised that their [=IDP=] is aware of their plans to get
        married.
</div>

Preventing tracking of users by the [=IDP=] is difficult: the [=RP=] has to be coded into the
identity token for security reasons, such as token reuse and fraud and abuse prevention. There have
been cryptographic schemes developed to blind the [=IDP=] to the [=RP=] while still
preventing token reuse(see Mozilla’s [personas](https://wiki.mozilla.org/Identity/Persona_AAR)).
These schemes have not been adopted by this specification.

<div class="image">
  <pre class=include-raw>
  path: img/mock34.svg
  </pre>
</div>

<!-- ====================================================================== -->
# Extensibility # {#extensibility}
<!-- ====================================================================== -->

Note: go over the extensibility mechanisms.

<!-- ====================================================================== -->
# Acknowledgements # {#acknowledgements}
<!-- ====================================================================== -->

Note: write down the Acknowledgements section.

<pre class="biblio">
{
  "CM": {
    "href": "https://w3c.github.io/webappsec-credential-management/",
    "title": "Credential Management"
  },
  "OIDC-Connect-Core": {
    "href": "https://openid.net/specs/openid-connect-core-1_0.html",
    "title": "OIDC Connect Core"
  },
  "PERMISSIONS-POLICY": {
    "href": "https://w3c.github.io/webappsec-permissions-policy",
    "title": "Permissions Policy"
  },
  "PRIVACY-MODEL": {
    "href": "https://github.com/michaelkleber/privacy-model",
    "title": "Privacy Model"
  },
  "PRIVACY-THREAT-MODEL": {
    "href": "https://w3cping.github.io/privacy-threat-model/",
    "title": "Target Privacy Threat Model"
  },
  "RFC7258": {
    "href": "https://datatracker.ietf.org/doc/html/rfc7258",
    "title": "Pervasive Monitoring Is an Attack"
  }
}
</pre>

<!-- ====================================================================== -->
# FPWD Issues # {#openissues}
<!-- ====================================================================== -->
Note: The WG has labeled the following issues as critical open issues that must be formally addressed before publication of a Candidate Recommendation.

<ul id="issueList">
    <li>Issue 240: <a href="https://github.com/w3c-fedid/FedCM/issues/240">Users can't use IdPs outside of the ones enumerated by RPs</a></li>
    <li>Issue 317: <a href="https://github.com/w3c-fedid/FedCM/issues/317">concerns about email in Accounts List</a></li>
    <li>Issue 319: <a href="https://github.com/w3c-fedid/FedCM/issues/319">Allow multiple IDPs to be used</a></li>
    <li>Issue 320: <a href="https://github.com/w3c-fedid/FedCM/issues/320">Why Sec-FedCM-CSRF and not Sec-Fetch-Mode</a></li>
    <li>Issue 352: <a href="https://github.com/w3c-fedid/FedCM/issues/352">Share performance measurement with IDP</a></li>
    <li>Issue 407: <a href="https://github.com/w3c-fedid/FedCM/issues/407">[Context API] - Authz / relation to ability to specificy scope</a></li>
    <li>Issue 428: <a href="https://github.com/w3c-fedid/FedCM/issues/428">Enforce CORS on the Identity Assertions endpoint</a></li>
    <li>Issue 441: <a href="https://github.com/w3c-fedid/FedCM/issues/441">The IDP has to support additional infrastructure to support FedCM</a></li>
    <li>Issue 442: <a href="https://github.com/w3c-fedid/FedCM/issues/442">A not-yet logged in IDP has no route to success with this flow</a></li>
    <li>Issue 467: <a href="https://github.com/w3c-fedid/FedCM/issues/467">Use cases for Cross-Site Cookie Access through Storage Access API after FedCM grant?</a></li>
    <li>Issue 488: <a href="https://github.com/w3c-fedid/FedCM/issues/488">Users may be confused after showing intent to sign in but the sign-in is failed</a></li>
    <li>Issue 511: <a href="https://github.com/w3c-fedid/FedCM/issues/511">Allow signing in to additional account(s)</a></li>
    <li>Issue 517: <a href="https://github.com/w3c-fedid/FedCM/issues/517">Allow user agents to use "Connected Accounts Set" with flexibility</a></li>
    <li>Issue 537: <a href="https://github.com/w3c-fedid/FedCM/issues/537">Allow setting IDP login status from same-site subresources</a></li>
    <li>Issue 552: <a href="https://github.com/w3c-fedid/FedCM/issues/552">Allow IDPs to use multiple config files within an eTLD+1</a></li>
    <li>Issue 553: <a href="https://github.com/w3c-fedid/FedCM/issues/553">Allowing IDPs to expose different account lists in different contexts</a></li>
    <li>Issue 555: <a href="https://github.com/w3c-fedid/FedCM/issues/555">Allow IdPs to continue and finish the request in a popup window</a></li>
    <li>Issue 556: <a href="https://github.com/w3c-fedid/FedCM/issues/556">Passing arbitrary parameters to the ID assertion endpoint</a></li>
    <li>Issue 559: <a href="https://github.com/w3c-fedid/FedCM/issues/559">Allow RPs to selectively request attributes of the user's profile</a></li>
    <li>Issue 578: <a href="https://github.com/w3c-fedid/FedCM/issues/578">Allow IdPs to return JSON objects rather than Strings back to RPs</a></li>
    <li>Issue 585: <a href="https://github.com/w3c-fedid/FedCM/issues/585">Allow IdP registration and RPs to match on a "type"</a></li>
    <li>Issue 587: <a href="https://github.com/w3c-fedid/FedCM/issues/587">Why must SameSite=none?</a></li>
    <li>Issue 599: <a href="https://github.com/w3c-fedid/FedCM/issues/599">OAuth profile for FedCM</a></li>
    <li>Issue 609: <a href="https://github.com/w3c-fedid/FedCM/issues/609">Spec says we send SameSite=Strict cookies</a></li>
    <li>Issue 616: <a href="https://github.com/w3c-fedid/FedCM/issues/616">Once `params` are merged into the spec, deprecate the `nonce` parameter</a></li>
    <li>Issue 618: <a href="https://github.com/w3c-fedid/FedCM/issues/618">Support chained authentication flows before reducing heuristics and classifications/lists in navigational tracking mitigations</a></li>
    <li>Issue 620: <a href="https://github.com/w3c-fedid/FedCM/issues/620">Make it easier to deploy this at the eTLD+1 for registered IdPs</a></li>
    <li>Issue 625: <a href="https://github.com/w3c-fedid/FedCM/issues/625">Returning accounts go first in getUserInfo</a></li>
    <li>Issue 626: <a href="https://github.com/w3c-fedid/FedCM/issues/626">PP/TOS requirements are different from auto reauthentication</a></li>
    <li>Issue 627: <a href="https://github.com/w3c-fedid/FedCM/issues/627">Add webdriver command to open PP/TOS</a></li>
</ul>
</body>
</html>

