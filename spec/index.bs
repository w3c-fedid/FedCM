<pre class='metadata'>
Title: Federated Credential Management API
Shortname: FedCM
Level: 1
Status: CG-DRAFT
Group: WICG
ED: http://wicg.github.io/FedCM
Repository: WICG/FedCM
Editor: Sam Goto, Google Inc. https://google.com, goto@google.com

Markup Shorthands: markdown yes, biblio yes
Default Biblio Display: inline

Text Macro: FALSE <code>false</code>
Text Macro: TRUE <code>true</code>
Text Macro: RP Relying Party
Text Macro: IDP Identity Provider

Abstract: A Web Platform API that allows users to login to websites with their federated accounts in a privacy preserving manner.

Test Suite: https://github.com/web-platform-tests/wpt/blob/master/credential-management/webid.https.html
</pre>

<pre class=anchors>
spec: ecma262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: time values; url: sec-time-values-and-time-range
        text: promise; url: sec-promise-objects
        text: internal method; url: sec-ordinary-object-internal-methods-and-internal-slots

spec: credential-management-1; urlPrefix: https://w3c.github.io/webappsec-credential-management/
    type: dictionary
        text: CredentialRequestOptions; url: dictdef-credentialrequestoptions
    for: Credential
        type: method
            text: [[CollectFromCredentialStore]](origin, options, sameOriginWithAncestors)
            text: [[Create]](origin, options, sameOriginWithAncestors)
            text: [[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)
            text: [[Store]](credential, sameOriginWithAncestors)
    type: dfn
        text: signal
        text: same-origin with its ancestors; url: same-origin-with-its-ancestors

spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/origin.html
    type: dfn
        text: origin; for: html-origin-def; url: concept-origin
</pre>

<pre class=link-defaults>
spec:infra; type:dfn; text:list
spec:infra; type:dfn; text:user agent
spec:html; type:dfn; for:environment settings object; text:global object
spec:html; type:dfn; for:html-origin-def; text:origin
spec:webidl; type:dfn; text:resolve
</pre>

<style>
dl.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
dl.domintro dt a {
    color: inherit; border-bottom-style: none;
}
dl.domintro dt code {
    font-size: inherit;
}
</style>

<!-- ============================================================ -->
# Introduction # {#introduction}
<!-- ============================================================ -->

*This section is non-normative.*

As the web has evolved there have been ongoing privacy-oriented changes
(e.g [Safari](https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/),
[Firefox](https://blog.mozilla.org/blog/2019/09/03/todays-firefox-blocks-third-party-tracking-cookies-and-cryptomining-by-default/),
[Chrome](https://blog.google/products/chrome/privacy-sustainability-and-the-importance-of-and/))
and changes to the underlying privacy principles (e.g. [[PRIVACY-MODEL]]).

With this evolution, fundamental assumptions of the web
platform are being redefined or removed. Access to cookies in a third-party
context are one of those assumptions. While overall good for the
web, the third-party cookie deprecation removes a fundamental building block
used by certain designs of federated identity.

The Federated Credential Management API aims to bridge the gap for the
federated identity designs which relied on third-party cookies.
The API provides the primitives needed to support federated identity when/where
it depends on third-party cookies, from sign-in to sign-out and revocation.

In order to provide the federated identity primitives without the use of
third-party cookies the API places the [=User Agent=] as a mediator between
[=RPs=] and [=IDPs=]. This mediation requires user consent before permitting
the [=RPs=] and [=IDPs=] to know about their connection to the user.

The specification leans heavily on changes in the [=User Agent=] and [=IDP=]
and minimally on the [=RP=]. The FedCM API provides a way to authenticate,
fetch tokens, revoke the provided tokens, and allow for front-channel logout.

<!-- ============================================================ -->
## Use Cases ## {#use-cases}
<!-- ============================================================ -->

The below use case scenarios illustrate some basic supported flows. Each
supported flow below occurs inside an iframe or in an XHR request. Additional
scenarios, including sample code, are given in the
[[Identity-Use-Cases-in-Browser-Catalog]].

<!-- ============================================================ -->
### Sign-up ### {#use-cases-sign-up}
<!-- ============================================================ -->

A Sign-up occurs when the user is registering a new account at the
[=Relying Party=] using their [=Identity Provider=].

For instance, a user navigates to a [=Relying Party=] in their browser
and creates an account. The [=Relying Party=] displays supported
[=Identity Providers=] to the user who selects their favorite. The user
is prompted "Do you want to create an account with the [=Relying Party=]?".
Upon user agreement an [=account=] is created with the [=Relying Party=] and
the user has a [=session=] initialized.

<!-- ============================================================ -->
### Sign-in ### {#use-cases-sign-in}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to
create an account by going through their [[#use-cases-sign-up]] flow,
there are two ways a user logs into their [=account=] once their [=session=] expires:

<!-- ============================================================ -->
#### Auto Sign-in #### {#use-cases-auto-sign-in}
<!-- ============================================================ -->

Auto Sign-in occurs when the [=Identity Provider=] has already gathered
permissions from the user to share their identity with the [=Relying Party=]
and automatically signs the user in.

For example, the user has previously executed the [[#use-cases-sign-up]] flow
and then changes from their phone to their laptop. On the new device the
user goes to the [=Relying Party=] and selects to sign-in using their
[=Identity Provider=]. The [=Identity Provider=] knows, and proves, the user
has signed up to the [=Relying Party=] and the [=Relying Party=] creates a
new [=session=] for the users [=account=].

<!-- ============================================================ -->
#### Explicit Sign-in #### {#use-cases-explicit-sign-in}
<!-- ============================================================ -->

An explicit sign-in occurs when the [=Identity Provider=] believes it is
necessary to gather an explicit permission from the user to sign into a
[=Relying Party=], typically after the user goes through a
[[#use-cases-sign-out]] flow.

For example, after the user has done the [[#use-cases-sign-out]] flow of the
[=Relying Party=] they decide to log in again. The user visits the
[=Relying Party=] and selects their [=Identity Provider=] to sign-in. The
[=Identity Provider=] knows:
    * the user already has an account with the [=Relying Party=].
    * the user has logged out of the [=Relying Party=].

The user is then prompted, "Do you want to sign-in with the [=Relying Party=]?"
and upon user agreement the [=Relying Party=] creates a new [=session=] with
the users existing [=account=].

<!-- ============================================================ -->
### Sign-out ### {#use-cases-sign-out}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to
create an [=account=] by going through their [[#use-cases-sign-up]] flow,
there are two ways a user can clear their [=session=]s:

<!-- ============================================================ -->
#### RP Sign-out #### {#use-cases-rp-sign-out}
<!-- ============================================================ -->

The user can log out through the [=Relying Party=] by using a provided
sign-out button or link provided by the [=Relying Party=]. This then
removes the users [=session=] and, when the user visits the [=Relying Party=]
again they will need to go through the [[#use-cases-explicit-sign-in]] flow
in order to establish a new session.

<!-- ============================================================ -->
#### IDP Sign-out #### {#use-cases-idp-sign-out}
<!-- ============================================================ -->

The user can log out through the [=Identity Provider=] by using a provided
sign-out system provided by the [=Identity Provider=]. After using the
sign-out system the [=Identity Provider=] will log the user out of all
[=Relying Parties=] the user has signed into along with logging the user
out of the [=Identity Provider=] itself. Upon returning to any associated
[=Relying Party=], or the [=Identity Provider=], the user will have to
go through the [[#use-cases-explicit-sign-in]] flow.

<!-- ============================================================ -->
### Revocation ### {#use-cases-revocation}
<!-- ============================================================ -->

After a user has created an account with a [=Relying Party=] there are two
ways a user can cancel their account with the [=Relying Party=]:

<!-- ============================================================ -->
#### RP Revocation #### {#use-cases-rp-revocation}
<!-- ============================================================ -->

The user can delete their account through the [=Relying Party=] by using
the provided cancel account system. The [=Relying Party=] informs the
[=Identity Provider=] that the user has deleted (revoked) their account.
When the user returns to the [=Relying Party=] they will need to complete
the [[#use-cases-sign-up]] flow in order to access the site.

<!-- ============================================================ -->
#### IDP Revocation #### {#use-cases-idp-revocation}
<!-- ============================================================ -->

The user can delete their account with a [=Relying Party=] by revoking
[=Relying Party=] access through the [=Identity Provider=]. This can be done
by going to the [=Identity Provider=] and using their revoke access system.
Once access is revoked, when the user returns to the [=Relying Party=] they
will need to complete the [[#use-cases-sign-up]] flow in order to access the
site.

<!-- ============================================================ -->
### Access ### {#use-cases-access}
<!-- ============================================================ -->

The [=Identity Provider=] while authenticating the user may also authorize
access to users resources such as calendars, contacts, etc. The granting
of access can be done at either sign-up or post sign-up by requesting
permission from the user.

For example, a user executes the [[#use-cases-sign-up]] flow with a
[=Relying Party=]. During the flow the [=Relying Party=] has informed the
[=Identity Provider=] they need calendar access for the user. The user will
be presented with a prompt, "Do you want to give access to your Calendar
to the [=Relying Party=]?". The user consents to providing access and when
the flow is complete the [=Relying Party=] shows the user their calendar
entries provided by the [=Identity Provider=].

<!-- ============================================================ -->
# Examples # {#examples}
<!-- ============================================================ -->

This specification extends the {{FederatedCredential}} type and internal
algorithms to allow the exchange of identity between [=IDP=]s and [=RP=]s.
When it succeeds, it returns to the [=RP=] a signed [=id token=] which the
[=RP=] can use to authenticate the user.

<!-- ============================================================ -->
# Single Account Example # {#example-single-user}
<!-- ============================================================ -->
<div class=example>
Example showing how a website allowing for a single logged in account
could be implemented.

```html
<html>
<head>
  <title>Welcome to my Website</title>
</head>
<body>
  <button onclick="login()">Login with idp.example</button>
  <button onclick="revoke()">Revoke tokens</button>
  <button onclick="logout()">Logout</button>

  <script>
  async function login() {
    const credential = getFederatedCredential();

    // This will prompt when !credential[“consented”], but
    // it won’t when credential[“consented”].
    //
    // If !credential["consented"] and mediation == silent will `reject`.
    //
    // If the user selects an account updates the credential["consented"]
    // state and stores any needed account information.
    return await credential.login({ nonce: "456" });
  }

  async function logout() {
    const credential = getFederatedCredential();
    // This never prompts, rejects the promise in case !credential[“consented”]
    return credential.logout();
  }

  async function revoke() {
    const credential = getFederatedCredential();
    // This never prompts, rejects the promise in case !credential[“consented”]
    return credential.revoke();
  }

  async function getFederatedCredential() {
    // This never prompts. A FederatedCredential object will always be returned.
    // The object will be either consented or unconsented and store information
    // on if the user should be prompted based on the mediation flag.
    return await navigator.credentials.get({
      mediated: “optional”, // “optional” is the default
      federated: {
        providers: [{
          url: "https://idp.example",
          clientId: "123"
        }]
      }
    });
  }
  </script>
</body>
</html>
```
</div>

<!-- ============================================================ -->
# Multiple Account Example # {#example-multiple-account}
<!-- ============================================================ -->
<div class=example>
Example showing how a website allowing for multiple logged in accounts
could be implemented.

```html
<html>
<head>
  <title>Welcome to my Website</title>
</head>
<body>
  <button onclick="login()">Login with idp.example</button>
  <button onclick="revoke()">Revoke tokens</button>
  <button onclick="multiLogin()">Switch account</button>
  <button onclick="logout()">Logout</button>

  <script>
  async function login() {
    const id = ...; /* site gets stored id if available */
    const credential = await navigator.credentials.get({
      mediation: "optional",
      federated: {
        providers: [{
          url: "https://idp.example",
          clientId: "123",
          hint: id
        }]
      }
    });
    const tokens = await credential.login({ nonce: "456" });
    /* site stores id somewhere */
    return tokens;
  }

  async function multiLogin() {
    const credential = await navigator.credentials.get({
      mediation: "required",
      federated: {
        providers: [{
          url: "https://idp.example",
          clientId: "123",
        }]
      }
    });
    const tokens = await credential.login({ nonce: "456" });
    /* site stores id somewhere */
    return tokens;
  }

  async function logout() {
    const credential = await getLoggedInCredential();
    return credential.logout();
  }

  async function revoke() {
    const credential = await getLoggedInCredential();
    return credential.revoke();
  }

  async function getLoggedInCredential() {
    const id = ...; /* site gets stored id if available */
    return navigator.credentials.get({
      mediation: "silent",
      federated: {
        providers: [{
          url: "https://idp.example",
          clientId: "123",
          hint: id,
        }]
      }
    });
  }
  </script>
</body>
</html>
```
</div>

<!-- ============================================================ -->
# Terminology # {#terminology}
<!-- ============================================================ -->

[[HTML]] defines an [=origin=] as the tuple of a scheme, hostname, and port that
provides the main security boundary on the web.

: <dfn>account</dfn>
:: TODO(goto): find existing definition.

: <dfn>authentication</dfn>
:: Process used by an [=Identity Provider=] to achieve sufficient confidence in
    the binding between the user and a presented identity.

    Note that in some discussions and documentation, the term _authentication_ is
    used to refer to the [=federated sign-in=] process. However, the user does not
    authenticate to the [=RP=] during [=federated sign-in=]. The user
    authenticates to the [=IDP=], which then provides a claim to the [=RP=]
    asserting the user’s identity. The user does not prove their identity to the
    [=RP=].

    See also:
    * [[OIDC-Connect-Core#Terminology]]
    * [[OIDC-Connect-Core#Authentication]]
    * [[SAML-Glossary]]

: <dfn>directed identifier</dfn>
:: A [=user identifier=] that that is unique for each [=site=] the user visits. A
    goal of anti-tracking policy is to promote [=user identifiers=] to become
    [=directed identifiers=]. See the [[#privacy-threat-model]] for more information.

: <dfn>first party</dfn>
:: The first-party for a user action is the [=party=] that controls the
    [=origin=] of the [=top-level browsing context=] under which the action
    happened. Intuitively, this is the owner of the domain in the browser's URL bar.

    This differs from <a href="https://wiki.mozilla.org/Security/Anti_tracking_policy#Tracking_Definition">Mozilla's definition</a>
    in that Mozilla defines other parties as first parties if the user can easily
    discover which party it is and intends to interact with that party, for
    example to allow sign-in widgets to be first-party.

: <dfn>global identifier</dfn>
:: A string that identifies a particular [=user=] independent of which site
    they're visiting (e.g. email addresses and phone numbers). Users generally
    have relatively few global identifiers and can usually list and recognize
    them. A goal of anti-tracking policy is to prevent [=user identifiers=] from
    becoming [=global identifiers=].

: <dfn>high-level API</dfn>
:: A use case specific API, as opposed to a [=low-level API=]. See also
    [high level vs low level](https://w3ctag.github.io/design-principles/#high-level-low-level).

: <dfn>id token</dfn>
:: TODO(goto): find existing definition.

: <dfn>Identity Provider</dfn>
: <dfn>IDP</dfn>
:: A service that has information about the user and can grant that information
    to [=Relying Parties=].

    See also:
    * [[OIDC-Connect-Core#Terminology]]

: <dfn>joining</dfn>
:: TODO(goto): find existing definition.

: <dfn>logged in</dfn>
:: TODO(goto): find existing definition.

: <dfn>logged out</dfn>
:: TODO(goto): find existing definition.

: <dfn>low-level API</dfn>
:: A general purpose API, as opposed to a [=high-level API=]. See also
    [high level vs low level](https://w3ctag.github.io/design-principles/#high-level-low-level)

: <dfn>minting</dfn>
: <dfn>minted</dfn>
:: The act of a new token being creating

: <dfn>out-of-band</dfn>
:: Outside of the user agent's context.

: <dfn>party</dfn>
:: Defined by [[tracking-dnt]] as "a natural person, a legal entity, or a set of
    legal entities that share common owner(s), common controller(s), and a group
    identity that is easily discoverable by a user."

: <dfn>registered</dfn>
:: TODO(goto): find existing definition.

: <dfn>Relying Party</dfn>
: <dfn>RP</dfn>
: <dfn noexport>Website</dfn>
:: A service that requests user information from an [=Identity Provider=] for
    [=federated sign-in=] or for other purposes.

    See also:
    * [[OIDC-Connect-Core#Terminology]]
    * [[SAML-Glossary]]

: <dfn>session</dfn>
:: TODO(goto): find existing definition.

: <dfn>Federated sign-in</dfn>
:: Process used by a [=Relying Party=] to obtain a [=user identifier=] from an
    [=Identity Provider=] to which the user performed [=authentication=].

    See also:
    * [[OIDC-Connect-Core]]

: <dfn>site</dfn>
:: A set of [=origins=] that are all [=same site=] with each other. Note that
    there are problems ([[PSL-PROBLEMS]]) with using [=registrable domains=] as
    a logical boundary.

: <dfn>third party</dfn>
:: A third-party for a user action is any party that isn't the [=first party=]
    or the user (the second party).

: <dfn>unregistered</dfn>
:: TODO(goto): find existing definition.

: <df>unsanctioned tracking</dfn>
:: [[UNSANCTIONED-TRACKING]]

: <dfn>user</dfn>
:: A human or program that controls a user agent.

: <dfn>user identifier</dfn>
:: A pair of a [=site=] and a (potentially-large) integer
    allocated by that site that is used to identify a [=user=] on that site. A
    single user will generally have many user IDs that refer to them, and a single
    site may or may not know that multiple user identifiers refer to the same user.

<!-- ============================================================ -->
# High Level Design # {#high-level-design}
<!-- ============================================================ -->

At a high level, the Identity Federation Management API works by the
intermediation of cooperating [=IDP=]s and [=RP=]s.

The [[#idp-api]] and the [[#rp-api]] defines a set of HTTP APIs that cooperating
[=IDP=]s and [=IDP=]s exposes as well as the entry points in the [[#browser-api]]
that they can use.

<div class='image'>
<pre class=include-raw>
path: img/mock43.svg
</pre>
</div>

The user agent intermediates in such a matter that makes it impractical for the
API to be used for tracking purposes, while preserving the functionality of
identity federation.

This document defines the APIs in the following order:

1. The [[#idp-api]]
1. The [[#rp-api]]
1. The [[#browser-api]]

<!-- ============================================================ -->
# The Identity Provider API # {#idp-api}
<!-- ============================================================ -->

The [=IDP=] proactively and cooperatively exposes itself as a comformant agent
by exposing a series of HTTP endpoints:

1. A [[#idp-api-manifest]] endpoint in an agreed upon location that points to
1. An [[#idp-api-accounts-endpoint]] endpoint
1. A [[#idp-api-client-id-metadata-endpoint]] endpoint
1. An [[#idp-api-id-token-endpoint]] endpoint
1. A [[#idp-api-revocation-endpoint]] endpoint

<!-- ============================================================ -->
## Manifest ## {#idp-api-manifest}
<!-- ============================================================ -->

The manifest discovery endpoint is an endpoint located at the [=IDP=]'s
`fedcm.json` file and serves as a discovery device to other endpoints provided
by the [=IDP=].

The manifest discovery endpoint is fetched:

(a) **without** cookies and
(b) **with** a special [[#Sec-FedCM-CSRF]] header, and
(c) **without** following [[RFC7231#header.location|HTTP redirects]].

For example:

<div class=example>
```http
GET /fedcm.json HTTP/1.1
Host: idp.example
Accept: application/json
Sec-FedCM-CSRF: ?1
```
</div>

The file is parsed expecting the following properties:

<dl dfn-type="argument" dfn-for="Manifest">
    :   <dfn>accounts_endpoint</dfn> (required)
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-accounts-endpoint]] API.
    :   <dfn>client_metadata_endpoint</dfn> (required)
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-client-id-metadata-endpoint]] API.
    :   <dfn>id_token_endpoint</dfn> (required)
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-id-token-endpoint]] API.
    :   <dfn>revocation_endpoint</dfn> (optional)
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-revocation-endpoint]] API.
    :   <dfn>branding</dfn> (optional)
    ::  A set of [=Branding JSON=] options.
</dl>

The <dfn>Branding JSON</dfn> enables an [=IDP=] to express their branding
preferences, which may be used by User Agents to customize the user agent
consent prompt.

Note: The branding preferences are deliberately designed to be high level
/ abstract (rather than opinionated about a specific UI structure), to
enable different [=User Agents=] to offer different UI experiences and
for them to evolve independently over time.

It may have the following properties:
<dl dfn-type="argument" dfn-for="manifest_branding">
    :   <dfn>background_color</dfn> (optional)
    ::  Background [=color=] for [=IDP=]-branded widgets such as buttons.
    :   <dfn>color</dfn> (optional)
    ::  [=color=] for text on [=IDP=] branded widgets using
        [=background_color=].
    :   <dfn>icons</dfn> (optional)
    ::  A list of [=Icon JSON=] objects.
</dl>

The <dfn>Icon JSON</dfn> may have the following properties:

<dl dfn-type="argument" dfn-for="manifest_branding_icons">
    :   <dfn>url</dfn> (required)
    ::  The url pointing to the icon image.
        The icon needs to comply with the
        [maskable](https://www.w3.org/TR/appmanifest/#icon-masks) specification.
    :   <dfn>size</dfn> (optional)
    ::  The size of the icon. The icon is assumed to be square and single resolution
        (not a multi-resolution .ico). The size may be omitted if the icon is in
        a vector graphic format (like SVG).
</dl>

The <dfn>color</dfn> is a subset of CSS <<color>> syntax, namely <<hex-color>>s, ''hsl()''s, ''rgb()''s and <<named-color>>.

For example:

<div class=example>
```json
{
  "accounts_endpoint": "/accounts.php",
  "client_metadata_endpoint": "/metadata.php",
  "id_token_endpoint": "/idtokens.php",
  "revocation_endpoint": "/revocation.php",
  "branding": {
    "background_color": "green",
    "color": "0xFFEEAA",
    "icons": [{
      "url": "https://idp.example/icon.ico",
      "size": 10
    }]
  }
}
```
</div>

<!-- ============================================================ -->
## Accounts List ## {#idp-api-accounts-endpoint}
<!-- ============================================================ -->

The accounts list endpoint provides the list of accounts the user has at the [=IDP=].

The accounts list endpoint is fetched
(a) **with** [=IDP=] cookies,
(b) **with** a special [[#Sec-FedCM-CSRF]] header,
(c) **without** a [[RFC7231#header.referer|Referer]] header, and
(d) **without** following [[RFC7231#header.location|HTTP redirects]].

For example:

<div class=example>
```http
GET /accounts_list.php HTTP/1.1
Host: idp.example
Accept: application/json
Cookie: 0x23223
Sec-FedCM-CSRF: ?1
```
</div>

The response is expected to have the following properties:

<dl dfn-type="argument" dfn-for="accounts_endpoint_response">
    :   <dfn>accounts</dfn> (required)
    ::  A list of [=Account JSON=].
</dl>

Every <dfn>Account JSON</dfn> is expected to have the following properties:

<dl dfn-type="argument" dfn-for="accounts_endpoint_response_accounts">
    :   <dfn>id</dfn> (required)
    ::  The account unique identifier.
    :   <dfn>name</dfn> (required)
    ::  The user's full name.
    :   <dfn>email</dfn> (required)
    ::  The user's email address.
    :   <dfn>given_name</dfn> (optional)
    ::  The user's given name.
    :   <dfn>approved_clients</dfn> (optional)
    ::  A list of [=RP=]s (in the form of Client IDs) this account is already registered with.
</dl>

For example:

<div class=example>
```json
{
 "accounts": [{
   "id": "1234",
   "given_name": "John",
   "name": "John Doe",
   "email": "john_doe@idp.example",
   "picture": "https://idp.example/profile/123",
   "approved_clients": ["123", "456", "789"]
  }, {
   "id": "5678",
   "given_name": "Johnny",
   "name": "Johnny",
   "email": "johnny@idp.example",
   "picture": "https://idp.example/profile/456"
   "approved_clients": ["abc", "def", "ghi"]
  }]
}
```
</div>

<!-- ============================================================ -->
## Client Metadata ## {#idp-api-client-id-metadata-endpoint}
<!-- ============================================================ -->

The client metadata endpoint provides metadata about [=RP=]s.

The client medata endpoint is fetched
(a) **without** cookies,
(b) **with** a special [[#Sec-FedCM-CSRF]] header,
(c) **with** a [[RFC7231#header.referer|Referer]] header indicating the [=RP=]'s origin
    (as if [[referrer-policy#referrer-policy-strict-origin|Referer-Policy: strict-origin]]
    was in use), and
(d) **without** following [[RFC7231#header.location|HTTP redirects]].

The user agent also passes the **client_id**.

For example:

<div class=example>
```http
GET /client_medata.php?client_id=1234 HTTP/1.1
Host: idp.example
Referer: https://rp.example/
Accept: application/json
Sec-FedCM-CSRF: ?1
```
</div>

The file is parsed expecting the following properties:

<dl dfn-type="argument" dfn-for="client_metadata_endpoint_response">
    :   <dfn>privacy_policy_url</dfn> (required)
    ::  A link to the [=RP=]'s privacy policy.
    :   <dfn>terms_of_service_url</dfn> (optional)
    ::  A link to the [=RP=]'s terms of service.
</dl>

For example:

<div class=example>
```json
{
  "privacy_policy_url": "https://rp.example/clientmetadata/privacy_policy.html",
  "terms_of_service_url": "https://rp.example/clientmetadata/terms_of_service.html"
}
```
</div>

<!-- ============================================================ -->
## ID Token ## {#idp-api-id-token-endpoint}
<!-- ============================================================ -->

The ID Token endpoint is responsible for [=minting=] a new [=id token=] for the user.

The ID Token endpoint is fetched
(a) as a **POST** request,
(b) **with** [=IDP=] cookies,
(c) **with** a [[RFC7231#header.referer|Referer]] header indicating the [=RP=]'s origin
    (as if [[referrer-policy#referrer-policy-strict-origin|Referer-Policy: strict-origin]]
    was in use),
(d) **with** a special [[#Sec-FedCM-CSRF]] header, and
(e) **without** following [[RFC7231#header.location|HTTP redirects]].

It will also contain the following parameters in the request body `application/x-www-form-urlencoded`:

<dl dfn-type="argument" dfn-for="id_token_endpoint_request">
    :   <dfn>client_id</dfn>
    ::  The [=RP=]'s client it
    :   <dfn>nonce</dfn>
    ::  The request nonce
    :   <dfn>account_id</dfn>
    ::  The account identifier that was selected.
    :   <dfn>consent_acquired</dfn>
    ::  Whether the privacy policy and the terms of service were displayed to the user.
</dl>

For example:

<div class=example>
```http
POST /fedcm_token_endpoint HTTP/1.1
Host: idp.example
Referer: https://rp.example/
Content-Type: application/x-www-form-urlencoded
Cookie: 0x23223
Sec-FedCM-CSRF: ?1
account_id=123&client_id=client1234&nonce=Ct60bD&consent_acquired=true
```
</div>

The response is parsed as a JSON file expecting the following properties:

<dl dfn-type="argument" dfn-for="id_token_endpoint_response">
    :   <dfn>id_token</dfn>
    ::  The resulting [=id token=].
</dl>

For example:

<div class=example>
```json
{
  "id_token" : "eyJC...J9.eyJzdWTE2...MjM5MDIyfQ.SflV_adQssw....5c"
}
```
</div>

<!-- ============================================================ -->
## Revocation ## {#idp-api-revocation-endpoint}
<!-- ============================================================ -->


The revocation endpoint is responsible for revoking all [=id token=]s for the
specified client ID for the user.

The request is made:

(a) as a **POST** request,
(b) **with** [=IDP=] cookies,
(c) **with** a special [[#Sec-FedCM-CSRF]] header,
(d) **with** a [[RFC7231#header.referer|Referer]] header indicating the [=RP=]'s origin
    (as if [[referrer-policy#referrer-policy-strict-origin|Referer-Policy: strict-origin]]
    was in use), and
(e) **without** following [[RFC7231#header.location|HTTP redirects]].

It will also contain the following parameters in the request body `application/x-www-form-urlencoded`:

<dl dfn-type="argument" dfn-for="revocation_endpoint_request">
    :   <dfn>account_id</dfn>
    :: The account identifier for the user (e.g. email).
    :   <dfn>client_id</dfn>
    :: The [=RP=]'s client id
</dl>

For example:

<div class=example>
```http
POST /fedcm_revocation_endpoint HTTP/1.1
Host: idp.example
Referer: https://rp.example/
Content-Type: application/x-www-form-urlencoded
Cookie: 0x23223
Sec-FedCM-CSRF: ?1
account_id=123&client_id=client1234
```
</div>

If successful, the response is an empty response with an HTTP 204 code,
otherwise an HTTP error code.

<!-- ============================================================ -->
## <code><dfn data-export="">`Sec-FedCM-CSRF`</dfn></code> ## {#Sec-FedCM-CSRF}
<!-- ============================================================ -->

All FedCM HTTP requests sent by the browser must contain a header
`Sec-FedCM-CSRF` with value `?1`. This allows servers to verify that the request
was initiated by the browser and not untrusted JavaScript because
it is a [=forbidden header name=].

<!-- ============================================================ -->
# The Relying Party API # {#rp-api}
<!-- ============================================================ -->

[=RP=]'s expose a [[#rp-api-logout-endpoint]] to facilitate with [[#use-cases-idp-sign-out]].

<!-- ============================================================ -->
## Logout ## {#rp-api-logout-endpoint}
<!-- ============================================================ -->

When [=IDP=]s call the [[#browser-api-idp-sign-out]] API, every [=RP=] gets a
chance to log the user out (e.g. clear cookies, clear local storage)
via the logout endpoint.

The logout endpoint is an endpoint that is registered with the [=IDP=]
[=out-of-band=].

The logout endpoint is called
(a) with a **GET** and
(b) with the [=RP=]'s cookies.

Note: the logout API introduces a credentialed request from the [=IDP=] to
the [=RP=]s, so it exposes a potential tracking surface area. It is a fairly
limited and controlled tracking area because the logout API is only available
when accounts **and** sessions are already established between the [=IDP=] and
the [=RP=].

<!-- ============================================================ -->
# The Browser API # {#browser-api}
<!-- ============================================================ -->

The Browser API exposes APIs to [=RP=]s and [=IDP=]s to call and intermediates
the exchange of the user's identity.

For [=RP=]s, it allows them to:

1. The [[#browser-api-sign-in]] allows [=RP=]'s users to [[#use-cases-sign-up]]
    and [[#use-cases-sign-in]]
1. The [[#browser-api-revocation]] allows [=RP=]'s users to go through
    [[#use-cases-rp-revocation]] of their accounts
1. The [[#browser-api-rp-sign-out]] API allows [=RP=]s to
    [[#use-cases-rp-sign-out]] of their accounts.

For [=IDP=]s, it allows them to:

1. The [[#browser-api-idp-sign-out]] API allows [=IDP=]s to
    [[#use-cases-idp-sign-out]] of their accounts.
1. The [[#browser-api-sign-in]] API allows [=IDP=]s to
    [[#use-cases-sign-in]]

The Browser API manages the lifecycle of the user's accounts and sessions with
an internal [[#browser-api-state-machine]].

<!-- ============================================================ -->
## The State Machine ## {#browser-api-state-machine}
<!-- ============================================================ -->

Internally, the account management and session management APIs allows the user
to explicitly move through the different stages of their accounts. At each
stage, the state machine manages the [=RP=]'s and the [=IDP=]'s access to the
appropriate browser capabilities.

<div class='image'>
<pre class=include-raw>
path: img/mock42.svg
</pre>
</div>

<dl dfn-type="argument" dfn-for="StateMachine">
    :   <dfn>Account State</dfn>
    ::  Keeps track of whether the user has an account or not. Can be
         [=registered=] or (by default) [=unregistered=].
    :   <dfn>Session State</dfn>
    ::  Keeps track of whether the user has an open or closed session. Can be
         [=logged in=] or (by default) [=logged out=].
</dl>

<!-- ============================================================ -->
## The FederatedCredential Object ## {#browser-api-federated-credential}
<!-- ============================================================ -->
The {{FederatedCredential}} object is the primary way to interact with the
FedCM API.

<div class=example>
```js
const credential = await navigator.credentials.get({
  federated: {
    providers: [{
      url: "https://idp.example",
      clientId: "123",
      hint: "dan@example.com"
    }]
  }
});
```
</div>

The most important parameter to the API call is the set of
[=Identity Provider=]s that the [=Relying Party=] supports and has
pre-registered with (i.e. it has a `clientId`).

The set of [=Identity Provider=]s is an extension to the
{{FederatedCredentialRequestOptions}} adding a list of {{FederatedIdentityProvider}}s:

<xmp class=idl>
partial dictionary FederatedCredentialRequestOptions {
  sequence<(DOMString or FederatedIdentityProvider)> providers;
};

dictionary FederatedIdentityProvider {
  required USVString url;
  required USVString clientId;
  USVString hint;
};
</xmp>

The {{CredentialRequestOptions/mediation}} flag is used to determine if the user
is prompted to select an account.

The {{CredentialRequestOptions/signal}} is used as an abort signal for the
requests.

<dl dfn-type="argument" dfn-for="FederatedIdentityProvider">
    :   <dfn>url</dfn>
    ::  The URL of the identity provider.
    :   <dfn>clientId</dfn>
    ::  The client ID provided to the [=RP=] out of band by the [=IDP=]
    :   <dfn>hint</dfn>
    ::  Optional |accountId| hint. Maybe used by the UA when displaying the
</dl>

This specification overrides the {{FederatedCredential}}'s
<code><dfn for="FederatedCredential" method>
 \[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</dfn></code>
method.

This algorithm runs in parallel inside the [[CM#algorithm-request]] to request
credentials and returns a set of {{FederatedCredential}} for the requested
[=Identity Provider=]s.

This [=internal method=] accepts three arguments:

<dl dfn-type="argument" dfn-for="FederatedCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">
    :   <dfn>origin</dfn>
    ::  This argument is the [=relevant settings object=]'s
         [=environment settings object/origin=], as determined by the
         calling {{CredentialsContainer/get()}} implementation, i.e.,
         {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a>
         abstract operation.
    :   <dfn>options</dfn>
    ::  This argument is a {{CredentialRequestOptions}} object whose
         <code>|options|.{{CredentialRequestOptions/federated}}</code> member
         contains a {{FederatedCredentialRequestOptions}} object specifying the
         exchange options.
    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the
         caller's [=environment settings object=] is
         [=same-origin with its ancestors=]. It is [FALSE] if caller is cross-origin.
</dl>

NOTE: This algorithm is currently out of date and will be updated to match the
examples.

When this method is invoked, the user agent MUST execute the following algorithm:

  1.  If <var ignore>sameOriginWithAncestors</var> is `false`, return a
      "{{NotAllowedError}}" {{DOMException}}.

      Note: This restriction aims to address the concern raised
      in [[Security-Origin-Confusion]].
  1.  Assert: |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"] [=map/exists=].
  1.  Assert: |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"] [=list/size=] is 1.

       Note: At some point we would like to support choosing accounts from
       multiple [=Identity Provider=]s.
  1. Let |provider| be |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"][0].
  1. Assert: |provider|["{{FederatedIdentityProvider/url}}"] [=map/exists=].
  1. Assert: |provider|["{{FederatedIdentityProvider/clientId}}"] [=map/exists=].
  1. Let |mode| be |options|["{{CredentialRequestOptions/mediation"] or "optional" if none provided
  1. if |mode| is {{CredentialMediationRequirement/required}}
      1. Return the result of running the [=create-credential=] algorithm.

  1. if |mode| is {{CredentialMediationRequirement/silent}}
      1. If |options|["{{FederatedIdentityProvider/hint}}"] does not [=map/exists=]
         1. Reject
      1. If a {{FederatedCredential}} with id == |options|["{{FederatedIdentityProvider/hint}}"] exists
         1. Return credential
      1. Reject

  1. If a single {{FederatedCredential}} exists, return it
  1. Otherwise, return the result of running teh [=create-credential=] algorithm.

To <dfn>create-credential</dfn> run this algorithm:
    1. Let |manifest| be the result of running the [=fetch the manifest=]
        algorithm with the |provider|.
    1. Let |accounts list| be the result of running the
        [=fetch the accounts list=] algorithm.
    1. Let |account| be the result of running the [=select an account=] from the
        |accounts list| algorithm.
    1. If the {{StateMachine/Account State}} is [=unregistered=]
        1. Return the result of running the [=sign-up=] algorithm.
    1.  If the {{StateMachine/Session State}} is  [=logged out=] then
        1. Return the result of running the [=explicit sign-in=] algorithm.
    1. Return the result of running the [=auto sign-in=] algorithm.

To <dfn>sign-up</dfn> the user run this algorithm:
    1. Gather explicit intent to create an account
    1. Gather explicit agreement with the [=Privacy Policy=]
    1. Gather explicit agreement with the [=Terms of Service=]
    1. Set the account's {{StateMachine/Account State}} from [=unregistered=]
        to [=registered=].
    1. Set the account's {{StateMachine/Session State}} from [=logged out=]
        to [=logged in=].
    1. Return a {{FederatedCredential}} object

To <dfn>select an account</dfn> from the accounts list run this algorithm:
    1. If |accounts list|'s [=list/size=] is 1
        1. Let |account| be |accounts list|[0]
        1. Return |account|
    1. If the |hint| is provided and an account matches |hint|
        1. Return |account|
    1. Display an account chooser
    1. Let |account| be an account that the user manually selects from the
        accounts chooser
    1. Return |account|

To <dfn>sign-in</dfn> the user run this algorithm:
    1. Assert that the {{StateMachine/Account State}} is [=registered=]
    1. Set the account's {{StateMachine/Session State}} from [=logged out=] to
        [=logged in=].
    1. Return a {{FederatedCredential}} object

To <dfn>auto sign-in</dfn> the user run this algorithm:
    1. Return the result of running the [=sign-in=] algorithm.

To <dfn>explicit sign-in</dfn> the user run this algorithm:
    1. Gather explicit confirmation that the user wants to sign-in to
        [=Relying Party=] with their [=Identity Provider=]'s |account|
    1. Return the result of running the [=sign-in=] algorithm.

To <dfn>fetch the manifest</dfn> configuration file, run this algorithm:
    1. Run a [[!CSP]] check with a [[CSP#directive-connect-src|connect-src]]
        directive on the URL passed as |provider|["{{FederatedIdentityProvider/url}}"]
        and abort this algorithm if the check fails.
    1. Let the |manifest url| be the file "fedcm.json" relative to the directory
        prefix passed as |provider|["{{FederatedIdentityProvider/url}}"]
    1. Return the result of fetching the |manifest url| with the
        [[#Sec-FedCM-CSRF|Sec-FedCM-CSRF]] header but without the
        [=Identity Provider=]'s cookies.  This request MUST NOT follow
        [[RFC7231#header.location|HTTP redirects]] and instead abort with an
        error if there are any.

To <dfn>fetch the accounts list</dfn> run this algorithm:
    1. Let the |accounts_endpoint| url be the relative url
        |manifest|["{{Manifest/accounts_endpoint}}"] of
        |provider|["{{FederatedIdentityProvider/url}}"]
    1. Let the |accounts list| be the result of fetching the |accounts_endpoint|
        with the [=Identity Provider=]'s cookies.  This request MUST NOT follow
        [[RFC7231#header.location|HTTP redirects]] and instead abort with an
        error if there are any.
    1. Return the |accounts list|

To <dfn noexport>fetch the client metadata</dfn> run this algorithm:
    1. Let the |client_metadata_endpoint| url be the relative url
        |manifest|["{{Manifest/client_metadata_endpoint}}"] of
        |provider|["{{FederatedIdentityProvider/url}}"]
    1. Let the |policies| be the result of fetching the
        |client_metadata_endpoint| with the [[#Sec-FedCM-CSRF|Sec-FedCM-CSRF]]
        header but without the [=Identity Provider=]'s cookies.  This request
        MUST NOT follow [[RFC7231#header.location|HTTP redirects]] and instead
        abort with
        an error if there are any.
    1. Return |policies|

The <dfn>Privacy Policy</dfn> are the policies described at
{{client_id_metadata_endpoint_response/privacy_policy_url}}.

The <dfn>Terms of Service</dfn> are the policies described at
{{client_id_metadata_endpoint_response/terms_of_service_url}}.

<!-- ============================================================ -->
## The Sign-in API ## {#browser-api-sign-in}
<!-- ============================================================ -->

<!-- ============================================================ -->
### RP Sign-in API ### {#browser-api-rp-sign-in}
<!-- ============================================================ -->

The Sign-up and Sign-in APIs used by the [=Relying Party=]s to ask the browser
to intermediate the relationship with the [=Identity Provider=] and the
provisioning of an [=id token=].

The [=Relying Party=] makes no delineation between Sign-up and Sign-in, but
rather calls the same API indistinguishably.

If all goes well, the [=Relying Party=] receives back a |tokens| object which
contains an [=id token=] in the form of a signed [[JWT]] which it can use to
authenticate the user.

The Sign-in API will request the [=id token=] to be [=minted=] by the IDP.

<div class=example>
```js
const tokens = credential.login({
  signal: signal,
  nonce: "my_nonce"
});
```
</div>

<xmp class=idl>
[Exposed=Window, SecureContext]
dictionary FederatedAccountLoginRequest {
  AbortSignal signal;
  USVString nonce;
};

[Exposed=Window, SecureContext]
partial interface FederatedCredential {
  Promise<FederatedTokens> login(optional FederatedAccountLoginRequest request = {});
};

[Exposed=Window, SecureContext]
dictionary FederatedTokens {
  USVString idToken;
};
</xmp>

<dl dfn-type="argument" dfn-for="FederatedAccountLoginRequest">
    :   <dfn>nonce</dfn>
    :: A random number of the choice of the [=RP=]
    :   <dfn>signal</dfn>
    ::  Abort signal
</dl>

<dl dfn-type="argument" dfn-for="FederatedTokens">
    :   <dfn>idToken</dfn>
    ::  The minted ID token
</dl>

When this method is invoked, the user agent MUST execute the following algorithm:

1. Let |tokens| be the result of making a POST request to the
    |manifest|["{{Manifest/id_token_endpoint}}"] with:
    * Let the {{id_token_endpoint_request/account_id}} be
        |account|["{{accounts_endpoint_response_accounts/account_id}}"].
    * Let the |id_token_endpoint_request| be a new object with
       * Let {{id_token_endpoint_request/client_id}} be
          |provider|["{{FederatedIdentityProvider/clientId}}"].
       * Let the {{id_token_endpoint_request/nonce}} be
          |provider|["{{FederatedAccountLoginRequest/nonce}}"].
    * This request MUST NOT follow [[RFC7231#header.location|HTTP redirects]]
        and instead abort with an error if there are any.
1. Return a new {{FederatedTokens}} as:
    * {{FederatedTokens/idToken}} as |token|


<!-- ============================================================ -->
## The Revocation API ## {#browser-api-revocation}
<!-- ============================================================ -->

Whenever the user decides to delete their account on the [=Relying Party=]
the [=Relying Party=] can call an API to let the [=Identity Provider=] and
the browser know.

Upon return to the [=Relying Party=], the user goes through a
[[#use-cases-sign-up]] flow instead of a [[#use-cases-sign-in]] flow.

<div class=example>
```js
credential.revoke();
```
</div>

This specification extends the {{FederatedCredential}} interface with a `revoke`
method:

<xmp class=idl>
[Exposed=Window, SecureContext]
partial interface FederatedCredential {
  Promise<undefined> revoke();
};
</xmp>

Note: go over the revocation API.

<!-- ============================================================ -->
## The Sign-out API ## {#browser-api-sign-out}
<!-- ============================================================ -->

<!-- ============================================================ -->
### RP Sign-out ### {#browser-api-rp-sign-out}
<!-- ============================================================ -->

When a user wants to log out of their session in the [=Relying Party=],
the [=Relying Party=] can let the browser know that it wants the [[#use-cases-auto-sign-in]]
flow to be disabled, so that the user doesn't get into an infinite loop.

<div class=example>
```js
credential.logout();
```
</div>

This specification extends the {{FederatedCredential}} interface with a `logout`
method:

<xmp class=idl>
[Exposed=Window, SecureContext]
partial interface FederatedCredential {
  Promise<undefined> logout();
};
</xmp>

Note: go over the RP sign-out API.

<!-- ============================================================ -->
### IDP Sign-out ### {#browser-api-idp-sign-out}
<!-- ============================================================ -->

In enterprise scenarios, it is common for the user to want to clear all of
their existing sessions in all of the [=Relying Party=]s they are logged into.

It does so by being navigated to their [=Identity Provider=] who initiates
what's called a [[Front-Channel-Logout]].

The browser exposes an API that takes the list of [=Relying Party=]s that the
[=Identity Provider=] wants to initiate the logout which are loaded in parallel
with cookies.

Each [=Relying Party=] endpoint is responsible for clearing its local state
(e.g. clearing cookies).

After the completion of this API, the user's session is cleared and will go
through an [[#use-cases-explicit-sign-in]] upon return.

<div class='image'>
<pre class=include-raw>
path: img/mock31.svg
</pre>
</div>

<div class=example>
```js
await FederatedCredential.logoutRPs([{
    url: "https://rp1.example",
    accountId: "123"
  }, {
    url: "https://rpN.example",
    accountId: "456"
  }]);
```
</div>

[=IDP=]s can call <code><a idl for="FederatedCredential" lt="logout()">FederatedCredential.logoutRPs(...)</a></code>
to log the user out of the [=RP=]s they are signed into.

<xmp class=idl>
dictionary FederatedCredentialLogoutRpsRequest {
  required USVString url;
  required USVString accountId;
};

[Exposed=Window, SecureContext]
partial interface FederatedCredential {
  static Promise<undefined> logoutRPs(sequence<FederatedCredentialLogoutRpsRequest> logoutRequests);
};
</xmp>

Note: go over how this is implemented.

<!-- ============================================================ -->
## Backwards Compatibility ## {#browser-api-backwards-compatibility}
<!-- ============================================================ -->

Note: go over how we are planning to deal with backwards compatibility.

<!-- ============================================================ -->
# Security # {#security}
<!-- ============================================================ -->

Note: go over security.

<!-- ============================================================ -->
# Privacy # {#privacy}
<!-- ============================================================ -->

<!-- ============================================================ -->
## Privacy Threat Model ## {#privacy-threat-model}
<!-- ============================================================ -->

This section is intended to provide a comprehensive overview of the privacy
risks associated with federated identity on the web for the purpose of
measuring the privacy risks and benefits of proposed browser intermediation
designs.

See also:

    * [[PRINCIPLES]]
    * [[ETHICS]]
    * [[SELF-REVIEW#threats]]
    * [[PRIVACY-CONSIDERATIONS#privacy-threats]]
    * [[RFC6973#section-5]]
    * [[PRIVACY-MODEL]]
    * [Editor’s Draft for a Web Privacy Threat Model](https://w3cping.github.io/privacy-threat-model/)
    * [Security and Privacy Considerations for SAML V2.0](https://docs.oasis-open.org/security/saml/v2.0/saml-sec-consider-2.0-os.pdf)

<!-- ============================================================ -->
### Principals ### {#privacy-threat-model-principals}
<!-- ============================================================ -->

This section describes the three principals that would participate in an
invocation of the API and expectations around their behavior.

1. The [=User Agent=] implements [[#browser-api]] and controls the execution
    contexts for the [=RP=] and [=IDP=] content. The user agent is assumed to be
    trusted by the user, and transitively trusted by the RP and IDP.
1. [=Relying Party=]s ([=RP=]s) are [=first party=] websites that invoke the
    FedCM API for the purpose of authenticating a user to their account or for
    requesting information about that user. A well-behaving RP would only invoke
    the API following a clear user signal -- typically, clicking a sign-in
    button. Since any site can invoke the API, RPs cannot necessarily be trusted
    to limit the user information it collects or use that information in an
    acceptable way.
1. [=Identity Provider=]s ([=IDP=]s) are [=third party=] websites that are the
    target of a FedCM call to attempt to fetch an ID token. Usually the IDP has a
    higher level of trust than the RP since it already has the user’s personal
    information, but it is possible that the IDP might use the user’s information
    in non-approved ways. It is possible that the IDP specified in the API call
    may not be an IDP the user knows about, or may not be a bona fide IDP at all,
    in which case it likely does not have personal user information in advance,
    but also might be less accountable for its behavior.

<!-- ============================================================ -->
### High-level threats ### {#privacy-threat-model-high-level-threats}
<!-- ============================================================ -->

[[RFC6973]] describes the following high-level privacy threats, which the TAG
has adopted into [[security-privacy-questionnaire#threats]]:

: <dfn noexport>Surveillance</dfn>
:: Surveillance is the observation or monitoring of an individual’s
    communications or activities.

: <dfn noexport>Stored Data Compromise</dfn>
:: End systems that do not take adequate measures to secure stored data from
    unauthorized or inappropriate access.

: <dfn noexport>Intrusion</dfn>
:: Intrusion consists of invasive acts that disturb or interrupt one’s life or
    activities.

: <dfn noexport>Misattribution</dfn>
:: Misattribution occurs when data or communications related to one individual
    are attributed to another.

: <dfn noexport>Correlation</dfn>
:: Correlation is the combination of various pieces of information related to an
    individual or that obtain that characteristic when combined.

: <dfn noexport>Identification</dfn>
:: Identification is the linking of information to a particular individual to
    infer an individual’s identity or to allow the inference of an individual’s
    identity.

: <dfn noexport>Secondary Use</dfn>
:: Secondary use is the use of collected information about an individual without
    the individual’s consent for a purpose different from that for which the
    information was collected.

: <dfn noexport>Disclosure</dfn>
:: Disclosure is the revelation of information about an individual that affects
    the way others judge the individual.

: <dfn noexport>Exclusion</dfn>
:: Exclusion is the failure to allow individuals to know about the data that
    others have about them and to participate in its handling and use.

These threats combine into the particular concrete threats we want web
specifications to defend against, described in subsections here:

<!-- ============================================================ -->
### Attack Scenarios ### {#attack-scenarios}
<!-- ============================================================ -->

This section describes the scenarios in which various agents might attempt to
gain user information. It considers the possibilities when:
    * [[#attack-scenarios-by-rp|The RP is collecting information]],
    * [[#attack-scenarios-by-idp|The IDP is collecting information]], or
    * [[#attack-scenarios-by-idp-by-collusion|Both the RP and the IDP are colluding]].

For the purposes of this section, a principal is considered to be participating
in the collection of information if it directly or indirectly performs actions
with the aim of realizing one of the above threats.

Note: An example of indirect collusion would be an RP importing a script
supplied by an IDP where the IDP intends to track users.

For the purpose of discussion this document assumes that third-party cookies
are **disabled** by default and are no longer effective for use in tracking
mechanisms, and also some form of mitigations are implemented against ‘bounce
tracking’ using link decoration or postMessage. Most of these scenarios consider
how user tracking might happen **without** them.

See also:
    1. [[RFC7258]]

<!-- ============================================================ -->
#### By the RP #### {#attack-scenarios-by-rp}
<!-- ============================================================ -->

<!-- ============================================================ -->
##### Cross-Site Correlation ##### {#attack-scenarios-by-rp-cross-site-correlation}
<!-- ============================================================ -->

Related to:
    * [[PRIVACY-THREAT-MODEL#hl-recognition-cross-site]]
    * [[PRIVACY-CONSIDERATIONS#privacy-threats| Privacy Considerations for Web Protocols: Correlation]]
    * [[RFC6973#section-5.2.1|RFC6973: Correlation]]

Correlation is the combination of various pieces of information related to an
individual or that obtain that characteristic when combined.

This attack happens when multiple [=RP=]s collude to use their user's data to
correlate them and build a richer profile.

When a user willingly provides their full name, email address, phone number, etc,
to multiple relying parties, those relying parties can collaborate to build a
profile of that user and their activity across collaborating sites.

Sometimes this is referred to as [=joining=] since it amounts to a join of user
ecords between the account databases of multiple RPs.

This correlation and profile-building is outside the user’s control and entirely
out of the [=User Agent=]’s or [=IDP=]’s view.

<div class="image">
   <pre class=include-raw>
   path: img/mock3.svg
   </pre>
</div>

<div class="example">
    1. User signs into RP1 (which sells jewelry) with an IDP, providing to RP1
        their email address user@email.example
    1. User signs into RP2 (which sells houses) with an IDP, providing to RP2
        their email address user@email.example
    1. User browses the collection of wedding rings in RP1.
    1. Out of band, RP1 tells RP2 that user@email.example is shopping for wedding rings
    1. User browses the housing inventory in RP2.
    1. RP2 uses the fact that the user is shopping for wedding rings in RP1 to
        advertise and filters their housing inventory.
    1. User is surprised that RP2 knows that they are shopping for wedding rings.
</div>

A generalization of [[#attack-scenarios-by-rp-cross-site-correlation]] is:

(<dfn noexport>RP Secondary Use</dfn>) Relying Party uses user information for
purposes not authorized by the user:

When the user agrees to allow the IDP to provide information to the RP,
the consent is specific to certain purposes, such as sign-in and personalization.
The RP might use that data for other purposes that the user would not expect and
did not authorize, such as selling email addresses to a spam list.

Spamming risk can exist even when using [=directed identifiers=].

<!-- ============================================================ -->
##### Same-Site Identification ##### {#attack-scenarios-by-rp-same-site-identification}
<!-- ============================================================ -->

Identification is the linking of information to a particular individual
to infer an individual’s identity or to allow the inference of an
individual’s identity.

This attack happens when the Relying Party employs client state-based
tracking to identify user.

Any API that exposes any kind of client state to the web risk becoming a
vector for fingerprinting or ‘supercookies’.

This risk would be increased by any proposal for browser mediation that
adds directly (or indirectly) detectable client state.

<div class="image">
<pre class=include-raw>
path: img/mock5.svg
</pre>
</div>

<div class='example'>
For example, an RP can use the browser state of the FedCM to add bits of entropy
and fingerprint the user.
</div>

See also:

   1. [[FINGERPRINTING-GUIDANCE]]

<!-- ============================================================ -->
##### Data Compromise ##### {#attack-scenarios-by-rp-data-compromise}
<!-- ============================================================ -->

This attack scenario happens when the [=RP=] takes advantage of
inadequate measures (by the [=IDP=] or the UA) to secure stored data to
obtain personal user information without their consent.

This can happen if user consent mechanisms are missing, inadequate,
or susceptible to bypass.

<div class="example">
An RP can use clickjacking to trick the user into signing-into their site.
</div>

<div class="example">
An RP can impersonate another RP to phish the user into signing-into their site.
</div>

See also:
    1. [[PRIVACY-THREAT-MODEL#stored-data-compromise]]
    1. [[RFC6973#section-5.1.2]]

<!-- ============================================================ -->
#### By the IDP #### {#attack-scenarios-by-idp}
<!-- ============================================================ -->

<!-- ============================================================ -->
##### Secondary Use ##### {#attack-scenarios-by-idp-secondary-use}
<!-- ============================================================ -->

Related to:
    * [[SELF-REVIEW#third-party-tracking]]

Secondary use is the use of collected information about an individual
without the individual's consent for a purpose different from that
for which the information was collected.

This attack happens when Identity Providers misuses the the information
collected to enable sign-in for other purposes.

Existing federation protocols require that the IDP know which service is
requesting an ID token in order to allow identity federation (e.g. the IDP must
know the OAuth `client_id`).

Identity providers can use this fact to build profiles of users across sites
where the user has decided to use federation with the same account. This profile
could be used, for example, to serve targeted advertisements to those users
browsing on sites that the IDP controls.

This risk can exist even in the case where the IDP does not having pre-existing
user account information (for instance, if it is not a _bona fide_ IDP), because
FedCM requests sent to the IDP are credentialed. This is more likely to occur if
the RP is colluding with the IDP to enable tracking; expanded variants are
described in [[#attack-scenarios-by-idp-timing-attacks]].

<div class="image">
    <pre class=include-raw>
    path: img/mock23.svg
    </pre>
</div>

<div class='example'>
    1. User signs into RP1 (which sells jewelry) with an IDP.
    1. User signs into RP2 (which sells houses) with the same IDP.
    1. User navigates to the IDP.
    1. Because the IDP knows that the user has an account with RP1 and RP2, the
        IDP can show ads about vacations for honeymoons.
    1. The user is surprised that their IDP is aware of their plans to get
        married.
</div>

<!-- ============================================================ -->
##### Impersonation ##### {#attack-scenarios-by-idp-impersonation}
<!-- ============================================================ -->

Since IDPs have unconstrained ability to issue ID tokens, they are capable
of logging in to users’ federated accounts without user knowledge or action,
impersonating the user and potentially gaining full access to the user's account
on the RP.

<div class="example">
    1. User signs into RP1 (which is a online dating site) with an IDP.
    1. An evil employee at IDP is an ex-spouse of the user.
    1. The evil employee impersonates themselves as the User and gains access
        to RP1
    1. The evil employee looks at the user's dating history.
    1. The user is surprised by their ex-spouse's knowledge of their recent
        dating affairs.
</div>

<!-- ============================================================ -->
#### By Collusion #### {#attack-scenarios-by-idp-by-collusion}
<!-- ============================================================ -->

<!-- ============================================================ -->
##### Intrusion ##### {#attack-scenarios-by-idp-intrusion}
<!-- ============================================================ -->

   > From [[PRIVACY-THREAT-MODEL#hl-intrusion]]
   >
   > Privacy harms don't always come from a site learning things.

   > From [[RFC6973#section-5.1.3|RFC6973: Intrusion]]
   >
   > Intrusion consists of invasive acts that disturb or interrupt one's
   > life or activities.  Intrusion can thwart individuals' desires to be
   > left alone, sap their time or attention, or interrupt their
   > activities.

In the context of federation, intrusion happens when an RP and an IDP
are colluding to invasively and aggressively recommend the user to
login disproportionally to the their intent.

Much like unsolicited notifications, an [=RP=] can collude with an [=IDP=]
to aggressively log users in.

See also:
    1. [[DESIGN-PRINCIPLES#safe-to-browse]]

<!-- ============================================================ -->
##### Back channel ##### {#attack-scenarios-by-idp-back-channel}
<!-- ============================================================ -->

This attack scenario happens when IDP exceed the user’s information sharing
permission.

Existing federated identity protocols are clear on what information an RP
is requesting, which the IDP can provide. While the browser can inspect
the request and response and consider whether user permission has been
granted for that transfer, it is difficult to know that there is no
additional information embedded in the response. An example could be if
the IDP encodes an identifier that could be used to load user-targeted
advertisements on RP pages, which could be of value where the IDP has much
more profiling information about the user.

Another example is if identifying information is shared out-of-band,
invisible to the browser, in which case it could contain anything.

<div class="example">
    1. User signs into RP1 (which sells jewelry) with an IDP, providing to RP1
        their [=directed identifier=] email address SHA256(user + RP1)@email.example
    1. User signs into RP2 (which sells houses) with an IDP, providing to RP2
        their [=directed identifier=] email address SHA256(user + RP2)@email.example
    1. User browses the collection of wedding rings in RP1.
    1. Out of band, RP1 colludes with the IDP and exchanges
        SHA256(user + RP1)@email.example to user@email.example.
    1. RP1 tells RP2 that user@email.example is shopping for wedding rings
    1. User browses the housing inventory in RP2.
    1. Out of band, RP2 colludes with the IDP and exchanges
        SHA256(user + RP2)@email.example to user@email.example.
    1. RP2 uses the fact that the user is shopping for wedding rings in RP1 to
        advertise and filters their housing inventory.
    1. User is surprised that RP2 knows that they are shopping for wedding rings.
</div>

<!-- ============================================================ -->
##### Timing Attacks ##### {#attack-scenarios-by-idp-timing-attacks}
<!-- ============================================================ -->

The potential for IDPs profiling users based on their visits to RPs
[[#attack-scenarios-by-idp-secondary-use]] can be partially mitigated by hiding
the RP from the IDP until after the user has consented to that tracking risk.

However, there is residual risk in cases where the RP and IDP are colluding.

If a credentialed request is sent to the IDP that does not explicitly identify
the RP, either of the following would still allow tracking by the IDP (again,
possibly not a _bona fide_ IDP that has existing knowledge of the user):

* The RP controlling any field in the request that can be used to convey
    identifying data in the request that the IDP could correlate to other
    requests from other RPs;

* The RP being able to provide fine-resolution timing information about
    the request to the IDP out of band.

The timing information can enable tracking in the following way:

    1. The RP logs the time at which it invoked the API, and
    1. The IDP logs the time at which it received a credentialed FedCM request
        from the user, and later
    1. They attempt to link the invocation and the request together using that
        information.

Notably, this is possible without FedCM using simple cross-origin top-level
navigations, but using FedCM for this purpose would worsen the problem if it
improved timing resolution or was less visible to users.

See also:
    1. [[DESIGN-PRINCIPLES#safe-to-browse]]

## Mitigation Strategies ## {#mitigation-strategies}

In this section we'll go over some strategies used in this specification to
mitigate the [privacy threats](#privacy-threat-model).

### Minimal Disclosure ### {#mitigation-minimal-disclosure}

There is a series of privacy threats that can be mitigated by disclosing the
least amount of identifying information and limiting its use as much as
possible. Two notable strategies are described in the sections below.

#### Directed Identifiers #### {#mitigation-directed-identifiers}

Mitigates:
    * [[#attack-scenarios-by-rp-cross-site-correlation]]

Note: directed, sharding, partitioning

The problem of RPs joining user data via back-channels is inherent
to the proliferation of identifying user data. This can be solved
by issuing [=directed identifiers=] that provide an effective handle
to a user's identity with a given IDP that is unique and therefore
cannot be correlated with other RPs.

In the past, there have been schemes to accomplish this using one-way
hashes of, for example, the user’s name, the IDP and the RP.

<div class="image">
  <pre class=include-raw>
  path: img/mock37.svg
  </pre>
</div>

Note: this mitigation is not robust against [[#attack-scenarios-by-idp-back-channel]],
or the [[#attack-scenarios-by-idp-secondary-use]]. Also, collaborating RPs might
be able to defeat this mitigation by sharing the same CLIENT_ID, although
possibly this could be detected and presumably would violate RP agreements with
IDPs with [[#mitigation-pre-registration]].

#### Self Presentation #### {#mitigation-self-presentation}

Mitigates:
    * [[#attack-scenarios-by-idp-secondary-use]] and
    * [[#attack-scenarios-by-idp-timing-attacks]]

Note: unbundling issuing from presentation

Preventing tracking of users by the IDP is difficult because the RP has to be
coded into the identity token for security reasons, to prevent reuse of the
token. There have been cryptographic schemes developed to blind the IDP to the
RP while still preventing token reuse in that way
(see Mozilla’s [personas](https://wiki.mozilla.org/Identity/Persona_AAR)) but
there are other valid uses that the IDP has for knowing the RP, such as fraud
and abuse prevention.

<div class="image">
  <pre class=include-raw>
  path: img/mock34.svg
  </pre>
</div>

### Mediation ### {#mitigation-mediation}

Mitigates:
    * [[#attack-scenarios-by-rp-cross-site-correlation]],
    * [[#attack-scenarios-by-rp-data-compromise]],
    * [[#attack-scenarios-by-idp-timing-attacks]]
    * [[#attack-scenarios-by-idp-intrusion]]

IDPs, whom the user has entrusted with their personal data, are currently
responsible for ensuring that the user consents to their information being
shared. With browser mediation in place, the user agent might have to assume
responsibility for ensuring the user understands what is being shared and that
it is intentional. This is certainly the case if the browser is able to entirely
intermediate the identity flow without showing any IDP web content, but also
might be desirable if there are concerns that the IDP is not collecting consent
in an adequate manner.

Additionally, a consent prompt preceding the sharing of the RP’s request to the
IDP can mitigate risks around IDP tracking of user visits to RPs.

<div class="image">
  <pre class=include-raw>
  path: img/mock46.svg
  </pre>
</div>

See also:
  1. [[DESIGN-PRINCIPLES#consent]]
  1. [[SELF-REVIEW#user-mediation]]
  1. [[RFC6973#page-23]]
  1. [[ETHICS|Ethical Principles]]: [[ETHICS#verify|The web must make it possible for people to verify the information they see]]
  1. [[ETHICS|Ethical Principles]]: [[ETHICS#control|The web must enhance individuals' control and power]]
  1. [[LEAST-POWER]]

#### Verification #### {#mitigation-verification}

Mitigates:
    * [[#attack-scenarios-by-rp-cross-site-correlation]],

The [=User Agent=] can mitigate [[#attack-scenarios-by-rp-cross-site-correlation]]
by inspecting the contents of the data exchange, and providing the necessary
user controls.

For example, it can inspect the email address that is being exchanged and verify
whether it is a [=directed identifier=] or not (and warn the user proportionally).

#### Activation #### {#activation}

The [=User Agent=] can mitigate [[#attack-scenarios-by-idp-intrusion]] by
mediating the user controls and offering them proportionally to the intent of
the user or the privacy risks involved.

For example, a [=User Agent=] can choose to show a loud / disruptive modal
mediated dialog when it has enough confidence of the user's intent or show a
quiet / conservative UI hint when it doesn't.

A [=User Agent=] could also choose to control disruption of the user's
experience based on the risks involved.

For example, when a [=directed identifier=] is being exchanged it can be more
confident of the unintended consequeces and offer a more aggressive user
experience, whereas when global identifiers are exchanged a more conservative
user experience.

<div class="image">
  <pre class=include-raw>
  path: img/mock45.svg
  </pre>
</div>

See also:
    * [Requiring user gesture to call WebAuthn API](https://github.com/w3c/webauthn/issues/1293)
    * [Require user gesture to request notification permissions](https://github.com/wicg/interventions/issues/49)
    * [WHATWG User Activation](https://html.spec.whatwg.org/multipage/interaction.html#tracking-user-activation)
    * [Querying User Activation](https://github.com/dtapuska/useractivation)

### Policy ### {#mitigation-policy}

Mitigates:
    * [[#attack-scenarios-by-idp-impersonation]],
    * [[#attack-scenarios-by-idp-back-channel]]

Beyond technical constraints, the browser can recognize explicit assertions by
the IDP about the privacy characteristics it provides and rely on those
assertions in order to guide the user appropriately. An example is a
hypothetical case in which the IDP asserts it will only issue
[=directed identifiers=] and will not provide identifying information to the
RPs out of view of the browser. In that case the browser may not have to warn
the user about sharing personalized information.

### Denylists ### {#mitigation-denylists}

Mitigates:
    * Potentially all threats, but is subject to the likelihood of bad behavior
        being detected, which for some might be difficult.

Any RPs or IDPs observed to be using this API to compromise user privacy in a
deceptive or abusive manner could be explicitly blocked from using it, or
potentially added to the SafeBrowsing blocklist so that they cannot be loaded
at all.

### Pre-registration ### {#mitigation-pre-registration}

Mitigates:
    * [[#attack-scenarios-by-rp-data-compromise]],
    * [[#attack-scenarios-by-rp-cross-site-correlation]]

Currently, IDPs require that an RP pre-registers and agrees to specific terms
before the IDP will issue an ID token to them.  This conflicts with
[the previous mitigation](#mitigation-self-presentation), but can provide a
measure of RP accountability.

### 2FA ### {#mitigation-2fa}

Mitigates:
    * [[#attack-scenarios-by-idp-impersonation]],

<!-- ====================================================================== -->
# Extensibility # {#extensibility}
<!-- ====================================================================== -->

Note: go over the extensibility mechanisms.

<!-- ====================================================================== -->
# Acknowledgements # {#acknowledgements}
<!-- ====================================================================== -->

Note: write down the Acknowledgements section.

<pre class="biblio">
{
  "CM": {
    "href": "https://w3c.github.io/webappsec-credential-management/",
    "title": "Credential Management"
  },
  "ETHICS": {
   "href": "https://www.w3.org/2001/tag/doc/ethical-web-principles",
   "title": "W3C TAG Ethical Web Principles"
  },
  "FINGERPRINTING-GUIDANCE": {
    "href": "https://w3c.github.io/fingerprinting-guidance/",
    "title": "Mitigating Browser Fingerprinting in Web Specifications"
  },
  "Front-Channel-Logout": {
    "authors": [ "M. Jones" ],
    "href": "https://openid.net/specs/openid-connect-frontchannel-1_0.html",
    "title": "Front-Channel Logout"
  },
  "Identity-Use-Cases-in-Browser-Catalog": {
    "authors": [ "V. Bertocci", "G. Fletcher" ],
    "href": "https://datatracker.ietf.org/doc/html/draft-bertocci-identity-in-browser-00",
    "title": "Identity Use Cases in Browser Catalog"
  },
  "JWT": {
    "authors": [ "M. Jones", "J. Bradley", "N. Sakimura" ],
    "href": "https://datatracker.ietf.org/doc/html/rfc7519",
    "title": "JWT"
  },
  "OAuth": {
    "authors": ["D. Hardt"],
    "href": "https://datatracker.ietf.org/doc/html/rfc6749",
    "title": "OAuth"
  },
  "OIDC-Connect-Core": {
    "href": "https://openid.net/specs/openid-connect-core-1_0.html",
    "title": "OIDC Connect Core"
  },
  "OpenID": {
    "href": "https://openid.net/developers/specs/",
    "title": "OpenID"
  },
  "PRINCIPLES": {
    "href": "https://w3ctag.github.io/design-principles",
    "title": "Web Platform Design Principles"
  },
  "PRIVACY-CONSIDERATIONS": {
    "href": "https://w3c.github.io/privacy-considerations/",
    "title": "Privacy Considerations for Web Protocols"
  },
  "PRIVACY-MODEL": {
    "href": "https://github.com/michaelkleber/privacy-model",
    "title": "Privacy Model"
  },
  "PRIVACY-THREAT-MODEL": {
    "href": "https://w3cping.github.io/privacy-threat-model/",
    "title": "Target Privacy Threat Model"
  },
  "PSL-PROBLEMS": {
    "authors": ["Ryan Sleevi"],
    "href": "https://github.com/sleevi/psl-problems",
    "title": "Public Suffix List Problems"
  },
  "RFC6973": {
    "href": "https://datatracker.ietf.org/doc/html/rfc6973",
    "title": "Privacy Considerations for Internet Protocols"
  },
  "RFC7258": {
    "href": "https://datatracker.ietf.org/doc/html/rfc7258",
    "title": "Pervasive Monitoring Is an Attack"
  },
  "SAML": {
    "href": "http://saml.xml.org/saml-specifications",
    "title": "SAML"
  },
  "SAML-Glossary": {
    "href": "https://docs.oasis-open.org/security/saml/v2.0/saml-glossary-2.0-os.pdf",
    "title": "SAML glossary"
  },
  "Security-Origin-Confusion": {
    "href": "https://w3c.github.io/webappsec-credential-management/#security-origin-confusion",
    "title": "Security Origin Confusion"
  },
  "SELF-REVIEW": {
    "href": "https://www.w3.org/TR/security-privacy-questionnaire/",
    "title": "Self-Review Questionnaire: Security and Privacy"
  }
}
</pre>
